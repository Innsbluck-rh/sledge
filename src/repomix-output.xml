This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app.tsx
components/BottomInfo.tsx
components/canvas/CanvasArea.tsx
components/canvas/CanvasAreaInteract.tsx
components/canvas/Controls.tsx
components/canvas/stacks/CanvasOverlaySVG.tsx
components/canvas/stacks/CanvasStack.tsx
components/canvas/stacks/ImagePool.tsx
components/canvas/stacks/LayerCanvas.tsx
components/canvas/stacks/TouchableCanvas.tsx
components/common/ColorBox.tsx
components/common/companion/Companion.tsx
components/common/companion/QuotePool.ts
components/common/Dropdown.tsx
components/common/DSLButton.tsx
components/common/DSLEditor.tsx
components/common/ImportImageButton.tsx
components/common/LayerPreview.tsx
components/common/Light.tsx
components/common/Slider.tsx
components/common/ToggleSwitch.tsx
components/EdgeInfo.tsx
components/section/CanvasSettings.tsx
components/section/Color.tsx
components/section/GlobalSettings.tsx
components/section/item/ColorPicker.tsx
components/section/item/LayerItem.tsx
components/section/item/PenItem.tsx
components/section/LayerList.tsx
components/section/PenConfig.tsx
components/section/Project.tsx
components/SideSections.tsx
components/TitleBar.tsx
components/ToastContainer.tsx
io/global/globalIO.ts
io/internal/export.ts
io/internal/import.ts
io/project/project.ts
main.tsx
models/dsl/DSL.ts
models/dsl/DSLRunner.ts
models/dsl/nodes/AvailableNodes.ts
models/dsl/nodes/DSLNodes.ts
models/dsl/nodes/effect/Brightness.ts
models/dsl/nodes/effect/EffectNode.ts
models/dsl/nodes/effect/GrayScale.ts
models/dsl/nodes/effect/Invert.ts
models/dsl/nodes/effect/Sepia.ts
models/dsl/nodes/fracture/FractureNode.ts
models/dsl/nodes/fracture/JpegGlitch.ts
models/dsl/nodes/pass/LayerIn.ts
models/dsl/nodes/pass/LayerOut.ts
models/dsl/nodes/pass/PassNode.ts
models/factories/addLayer.ts
models/factories/canvasPreview.ts
models/factories/createLayer.ts
models/factories/createPen.ts
models/factories/removeLayer.ts
models/factories/utils.ts
models/layer_canvas/DrawState.ts
models/layer_canvas/LayerCanvasOperator.ts
models/layer_image/agents/RawLayerImageAgent.ts
models/layer_image/agents/TileLayerImageAgent.ts
models/layer_image/HistoryManager.ts
models/layer_image/LayerImageAgent.ts
models/layer_image/LayerImageManager.ts
models/layer_image/Tile.ts
models/layer/layerImage.ts
models/tools/DrawUtils.ts
models/tools/eraser/EraserTool.ts
models/tools/fill/FillTool.ts
models/tools/fill/LegacyFills.ts
models/tools/fill/PixelFloodFill.ts
models/tools/fill/TileFloodFill.ts
models/tools/pen/PenTool.ts
models/tools/ToolBase.ts
models/types/Canvas.ts
models/types/Layer.ts
models/types/LayerImage.ts
models/types/Tool.ts
models/types/Vector.ts
routes/[...404].tsx
routes/editor/index.tsx
routes/index.tsx
routes/start.css.ts
stores/global/globalStore.ts
stores/internal/colorStore.ts
stores/internal/toastStore.ts
stores/internal/toolsStore.ts
stores/project/canvasStore.ts
stores/project/layerImageStore.ts
stores/project/layerStore.ts
stores/project/projectStore.ts
styles/components/bottom_info.css.ts
styles/components/canvas/canvas_area.css.ts
styles/components/canvas/canvas_stack.module.css
styles/components/canvas/controls.module.css
styles/components/canvas/image_pool.module.css
styles/components/canvas/layer_canvas.css.ts
styles/components/companion.module.css
styles/components/dropdown.css.ts
styles/components/dsl_button.module.css
styles/components/edge_info.module.css
styles/components/layer_preview.module.css
styles/components/light.module.css
styles/components/slider.module.css
styles/components/title_bar.css.ts
styles/components/toast.module.css
styles/components/toggle_switch.css.ts
styles/global.css.ts
styles/reset.css.ts
styles/section_global.css.ts
styles/section/canvas.css.ts
styles/section/color.css.ts
styles/section/layer.css.ts
styles/section/pen.css.ts
styles/section/project.css.ts
styles/snippets.css.ts
utils/colorUtils.ts
utils/DSLUtils.ts
utils/ImageUtils.ts
utils/pathUtils.ts
utils/tauriUtils.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app.tsx">
// @refresh reload
import { MetaProvider } from "@solidjs/meta";
import { Route, Router } from "@solidjs/router";
import { onMount, Suspense } from "solid-js";
import TitleBar from "./components/TitleBar";
import ToastContainer from "./components/ToastContainer";
import { loadGlobalSettings } from "./io/global/globalIO";
import Home from "./routes";
import Editor from "./routes/editor";

import { sledgeLogo } from "./styles/global.css";
import { flexCol, h100 } from "./styles/snippets.css";

export default function App() {
  return (
    <Router
      root={(props) => (
        <MetaProvider>
          <title>Sledge</title>
          <Suspense>
            <div
              class={[flexCol, h100].join(" ")}
              style={{ "pointer-events": "all" }}
            >
              <TitleBar />

              <main>{props.children}</main>

              <ToastContainer />

              {/* <p class={sledgeLogo}>sledge.</p> */}
            </div>
          </Suspense>
        </MetaProvider>
      )}
    >
      <Route path="/" component={Home} />
      <Route path="/editor" component={Editor} />
    </Router>
  );
}
</file>

<file path="components/BottomInfo.tsx">
import { Component, createSignal } from "solid-js";

import {
  bottomInfoRoot,
  bottomInfoText as bottomInfoTextStyle,
} from "~/styles/components/bottom_info.css";

const [bottomInfoText, setBottomInfoText] = createSignal("");

const BottomInfo: Component<{}> = (props) => {
  return (
    <div class={bottomInfoRoot}>
      <p class={bottomInfoTextStyle}>sledge.</p>
      &nbsp;
      <p class={bottomInfoTextStyle}>{bottomInfoText()}</p>
      {/* <p class={sideAreaEdgeText}>{projectStore.name || "name N/A"}</p> */}
    </div>
  );
};

export const setBottomInfo = (text: string) => {
  setBottomInfoText(text);
};

export default BottomInfo;
</file>

<file path="components/canvas/CanvasArea.tsx">
import CanvasStack from "./stacks/CanvasStack";

import {
  adjustZoomToFit,
  canvasStore,
  centeringCanvas,
  setCanvasStore,
} from "~/stores/project/canvasStore";

import { createMemo, onCleanup, onMount } from "solid-js";
import Controls from "./Controls";

import { canvasArea } from "~/styles/components/canvas/canvas_area.css";
import CanvasAreaInteract from "./CanvasAreaInteract";

export default () => {
  let wrapper: HTMLDivElement;
  let canvasStack: HTMLDivElement;

  let interact: CanvasAreaInteract = new CanvasAreaInteract();

  onMount(() => {
    // set Canvas to center
    setCanvasStore("canvasAreaSize", {
      width: wrapper.clientWidth,
      height: wrapper.clientHeight,
    });
    adjustZoomToFit();
    centeringCanvas();

    interact.setInteractListeners(wrapper, canvasStack);
  });

  onCleanup(() => {
    if (interact !== undefined) {
      interact.removeInteractListeners(wrapper, canvasStack);
    }
  });

  const offsetX = () => canvasStore.offsetOrigin.x + canvasStore.offset.x;
  const offsetY = () => canvasStore.offsetOrigin.y + canvasStore.offset.y;

  const transform = createMemo(() => {
    return `translate(${offsetX()}px, ${offsetY()}px) scale(${canvasStore.zoom})`;
  });

  return (
    <div class={canvasArea}>
      <div
        id="zoompan-wrapper"
        ref={(el) => {
          wrapper = el;
        }}
        style={{
          display: "flex",
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          padding: 0,
          margin: 0,
          width: "100%",
          height: "100%",
          "touch-action": "none",
        }}
      >
        <div
          ref={(el) => (canvasStack = el)}
          style={{
            padding: 0,
            margin: 0,
            "transform-origin": "0 0",
            transform: transform(),
          }}
        >
          <CanvasStack />
        </div>
      </div>

      <Controls />
    </div>
  );
};
</file>

<file path="components/canvas/CanvasAreaInteract.tsx">
import { Vec2 } from "~/models/types/Vector";
import {
  canvasStore,
  getReferencedZoom,
  setCanvasStore,
} from "~/stores/project/canvasStore";

class CanvasAreaInteract {
  private dragPosition: Vec2 = { x: 0, y: 0 };

  private lastX: number[] = [0, 0];
  private lastY: number[] = [0, 0];
  private lastDist: number = 0;

  constructor() { }

  private getMutualMove = (move0: number, move1: number) => {
    // 逆方向なら0
    if (Math.sign(move0) !== Math.sign(move1)) return 0;
    return Math.min(move1, move0);
  };

  private handleTouchMove(e: TouchEvent, canvasStack: HTMLDivElement) {
    if (canvasStore.isInStroke) return;

    if (e.touches.length === 1) {
      const xMove0 = e.touches[0].clientX - this.lastX[0];
      if (xMove0 !== 0 && this.lastX[0] !== 0) {
        setCanvasStore("offset", {
          x: canvasStore.offset.x + xMove0,
          y: canvasStore.offset.y,
        });
      }
      const yMove0 = e.touches[0].clientY - this.lastY[0];
      if (yMove0 !== 0 && this.lastY[0] !== 0) {
        setCanvasStore("offset", {
          x: canvasStore.offset.x,
          y: canvasStore.offset.y + yMove0,
        });
      }
      this.lastX[0] = e.touches[0].clientX;
      this.lastY[0] = e.touches[0].clientY;
    }
    if (e.touches.length >= 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist =
        Math.sqrt(dx * dx + dy * dy) * canvasStore.touchZoomSensitivity;
      if (this.lastDist !== 0) {
        const scaleFactor = dist / this.lastDist;
        const zoomOld = canvasStore.zoom;
        const zoomNew = zoomOld * scaleFactor;
        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const rect = canvasStack.getBoundingClientRect();
        const canvasX = (midX - rect.left) / zoomOld;
        const canvasY = (midY - rect.top) / zoomOld;
        setCanvasStore("zoom", zoomNew);
        setCanvasStore("offset", {
          x: canvasStore.offset.x + canvasX * (zoomOld - zoomNew),
          y: canvasStore.offset.y + canvasY * (zoomOld - zoomNew),
        });
      }
      const xMove0 = e.touches[0].clientX - this.lastX[0];
      const xMove1 = e.touches[1].clientX - this.lastX[1];
      const mutualMoveX = this.getMutualMove(xMove0, xMove1);
      if (mutualMoveX !== 0 && this.lastX[0] !== 0 && this.lastX[1] !== 0) {
        setCanvasStore("offset", {
          x: canvasStore.offset.x + mutualMoveX,
          y: canvasStore.offset.y,
        });
      }
      const yMove0 = e.touches[0].clientY - this.lastY[0];
      const yMove1 = e.touches[1].clientY - this.lastY[1];
      const mutualMoveY = this.getMutualMove(yMove0, yMove1);
      if (mutualMoveY !== 0 && this.lastY[0] !== 0 && this.lastY[1] !== 0) {
        setCanvasStore("offset", {
          x: canvasStore.offset.x,
          y: canvasStore.offset.y + mutualMoveY,
        });
      }
      this.lastX[0] = e.touches[0].clientX;
      this.lastX[1] = e.touches[1].clientX;
      this.lastY[0] = e.touches[0].clientY;
      this.lastY[1] = e.touches[1].clientY;
      this.lastDist = dist;
    }
  }

  private handleTouchEnd(e: TouchEvent) {
    this.lastX = [0, 0];
    this.lastY = [0, 0];
    this.lastDist = 0;
  }

  private handleWheel(e: WheelEvent, canvasStack: HTMLDivElement) {
    e.preventDefault();
    const referencedZoom = getReferencedZoom();
    const delta =
      (e.deltaY > 0 ? -canvasStore.wheelZoomStep : canvasStore.wheelZoomStep);

    const zoomOld = canvasStore.zoom;
    const zoomNew = Math.max(
      canvasStore.zoomMin * referencedZoom,
      Math.min(canvasStore.zoomMax * referencedZoom, canvasStore.zoom + delta),
    );
    const rect = canvasStack.getBoundingClientRect();
    const canvasX = (e.clientX - rect.left) / zoomOld;
    const canvasY = (e.clientY - rect.top) / zoomOld;
    setCanvasStore("zoom", zoomNew);
    setCanvasStore("offset", {
      x: canvasStore.offset.x + canvasX * (zoomOld - zoomNew),
      y: canvasStore.offset.y + canvasY * (zoomOld - zoomNew),
    });
  }

  private handleMouseDown(e: MouseEvent) {
    if (e.buttons === 4 || (e.buttons === 1 && canvasStore.isCtrlPressed)) {
      e.preventDefault();
      e.stopPropagation();
      setCanvasStore("isDragging", true);
      this.dragPosition = { x: e.clientX, y: e.clientY };
    }
  }

  private handleMouseMove(e: MouseEvent) {
    if (e.buttons === 4 || (e.buttons === 1 && canvasStore.isCtrlPressed)) {
      e.preventDefault();
      e.stopPropagation();
      if (canvasStore.isDragging) {
        const dx = e.clientX - this.dragPosition.x;
        const dy = e.clientY - this.dragPosition.y;
        setCanvasStore("offset", {
          x: canvasStore.offset.x + dx,
          y: canvasStore.offset.y + dy,
        });
        this.dragPosition = { x: e.clientX, y: e.clientY };
      }
    }
  }

  private handleMouseOff(e: MouseEvent) {
    setCanvasStore("isDragging", false);
  }

  private handleKeyDown(e: KeyboardEvent) {
    if (e.ctrlKey) setCanvasStore("isCtrlPressed", true);
  }

  private handleKeyUp(e: KeyboardEvent) {
    if (e.key === "Control") setCanvasStore("isCtrlPressed", false);
  }

  public setInteractListeners(
    wrapper: HTMLDivElement,
    canvasStack: HTMLDivElement,
  ) {
    wrapper.addEventListener("touchmove", (e) =>
      this.handleTouchMove.bind(this)(e, canvasStack),
    );
    wrapper.addEventListener("touchend", this.handleTouchEnd.bind(this));

    wrapper.addEventListener("wheel", (e) =>
      this.handleWheel.bind(this)(e, canvasStack),
    );

    wrapper.addEventListener("mousedown", this.handleMouseDown.bind(this));
    wrapper.addEventListener("mousemove", this.handleMouseMove.bind(this));
    wrapper.addEventListener("mouseup", this.handleMouseOff.bind(this));
    wrapper.addEventListener("mouseleave", this.handleMouseOff.bind(this));
    wrapper.addEventListener("mouseout", this.handleMouseOff.bind(this));

    window.addEventListener("keydown", this.handleKeyDown.bind(this));
    window.addEventListener("keyup", this.handleKeyUp.bind(this));
  }

  public removeInteractListeners(
    wrapper: HTMLDivElement,
    canvasStack: HTMLDivElement,
  ) {
    wrapper.removeEventListener("touchmove", (e) =>
      this.handleTouchMove.bind(this)(e, canvasStack),
    );
    wrapper.removeEventListener("touchend", this.handleTouchEnd.bind(this));

    wrapper.removeEventListener("wheel", (e) =>
      this.handleWheel.bind(this)(e, canvasStack),
    );

    wrapper.removeEventListener("mousedown", this.handleMouseDown.bind(this));
    wrapper.removeEventListener("mousemove", this.handleMouseMove.bind(this));
    wrapper.removeEventListener("mouseup", this.handleMouseOff.bind(this));
    wrapper.removeEventListener("mouseleave", this.handleMouseOff.bind(this));
    wrapper.removeEventListener("mouseout", this.handleMouseOff.bind(this));

    window.removeEventListener("keydown", this.handleKeyDown.bind(this));
    window.removeEventListener("keyup", this.handleKeyUp.bind(this));
  }
}

export default CanvasAreaInteract;
</file>

<file path="components/canvas/Controls.tsx">
import { Component, For } from "solid-js";
import { canvasStore } from "~/stores/project/canvasStore";
import { activeLayer, layerStore } from "~/stores/project/layerStore";

import styles from "@styles/components/canvas/controls.module.css";
import { layerImageManager } from "./stacks/CanvasStack";
import { canRedo, canUndo } from "~/stores/project/layerImageStore";

const Controls: Component<{}> = (props) => {
  // const zoom = () => canvasStore.zoom;
  const lastMouseWindow = () => canvasStore.lastMouseWindow;
  const lastMouseOnCanvas = () => canvasStore.lastMouseOnCanvas;

  return (
    <>
      <p>canvas.</p>
      <p>
        ({lastMouseWindow().x}, {lastMouseWindow().y}) ON WINDOW.
      </p>
      <p>
        ({lastMouseOnCanvas().x}, {lastMouseOnCanvas().y}) ON CANVAS.
      </p>
      {/* <p>x{zoom().toFixed(2)}</p> */}
      <p>active: {activeLayer()?.name}</p>
      <p>
        offset:({canvasStore.offset.x}, {canvasStore.offset.y})
      </p>
      <p>zoom.</p>
      <p>
        x {canvasStore.zoom}
      </p>

      <p>UNDO STACKS.</p>
      <For each={layerImageManager.getAgent(activeLayer()?.id)?.getHistoryManager()?.getUndoStack()}>
        {(item, i) => {
          if (i() === 0) {
            <>
              <p>pixel diffs: {item.diffs.values().toArray().filter(d => d.kind === "pixel").length}px.</p>
              <p>tile diffs: {item.diffs.values().toArray().filter(d => d.kind === "tile").length}px.</p>
            </>
          } else return <></>
        }
        }
      </For>
      <div class={styles["top-right-button-container"]}>
        {/* <ImportImageButton />
        <p class={styles.button} onClick={() => exportActiveLayerUpscaled()}>
          export
        </p> */}
      </div>
      <div class={styles["top-right-nav"]}>
        <img
          class={styles.undo_redo}
          src="/undo.png"
          style={{
            opacity: canUndo() ? "1.0" : "0.3",
            cursor: canUndo()
              ? "pointer"
              : "unset",
          }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            layerImageManager.getAgent(layerStore.activeLayerId)?.undo();
          }}
        />
        <img
          class={styles.undo_redo}
          src="/redo.png"
          style={{
            opacity: canRedo() ? "1.0" : "0.3",
            cursor: canRedo()
              ? "pointer"
              : "unset",
          }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            layerImageManager.getAgent(layerStore.activeLayerId)?.redo();
          }}
        />

        {/* <DSLEditor /> */}
      </div>
    </>
  );
};

export default Controls;
</file>

<file path="components/canvas/stacks/CanvasOverlaySVG.tsx">
import { Component, For } from "solid-js";
import Tile from "~/models/layer_image/Tile";
import { currentTool } from "~/stores/internal/toolsStore";
import { canvasStore } from "~/stores/project/canvasStore";

const CanvasOverlaySVG: Component<{ dirtyRects?: Tile[] }> = (props) => {
  const borderWidth = () => canvasStore.canvas.width * canvasStore.zoom;
  const borderHeight = () => canvasStore.canvas.height * canvasStore.zoom;

  const zoomedPenSize = () => currentTool().size * canvasStore.zoom;

  return (
    <svg
      viewBox={`0 0 ${borderWidth()} ${borderHeight()}`}
      xmlns="http://www.w3.org/2000/svg"
      style={{
        position: "absolute",
        top: 0,
        left: 0,
        "pointer-events": "none",
        "image-rendering": "pixelated",
      }}
    >
      {/* border rect */}
      <rect
        width={borderWidth()}
        height={borderHeight()}
        fill="none"
        stroke="black"
        stroke-width={1}
        pointer-events="none"
      />

      {/* pen hover preview */}
      <rect
        width={zoomedPenSize()}
        height={zoomedPenSize()}
        x={
          Math.round(canvasStore.lastMouseOnZoomedCanvas.x) -
          zoomedPenSize() / 2
        }
        y={
          Math.round(canvasStore.lastMouseOnZoomedCanvas.y) -
          zoomedPenSize() / 2
        }
        fill="none"
        stroke="black"
        stroke-width={1}
        pointer-events="none"
      />

      <For each={props.dirtyRects}>
        {dirtyRect => {
          return <rect
            width={dirtyRect.globalTileSize * canvasStore.zoom}
            height={dirtyRect.globalTileSize * canvasStore.zoom}
            x={dirtyRect.getOffset().x * canvasStore.zoom}
            y={dirtyRect.getOffset().y * canvasStore.zoom}
            fill={dirtyRect.isDirty ? "#ff000060" : "#00ffff60"}
            stroke="none"
            pointer-events="none"
          />
        }}
      </For>
    </svg >
  );
};

export default CanvasOverlaySVG;
</file>

<file path="components/canvas/stacks/CanvasStack.tsx">
import { Component, createEffect, createSignal, For, onMount } from "solid-js";
import { canvasStore } from "~/stores/project/canvasStore";
import {
  activeLayer,
  allLayers,
} from "~/stores/project/layerStore";

import styles from "@styles/components/canvas/canvas_stack.module.css";

import CanvasOverlaySVG from "./CanvasOverlaySVG";
import { LayerCanvas, LayerCanvasRef } from "./LayerCanvas";
import { TouchableCanvas } from "./TouchableCanvas";
import LayerCanvasOperator from "~/models/layer_canvas/LayerCanvasOperator";
import { LayerImageManager } from "~/models/layer_image/LayerImageManager";
import TileLayerImageAgent from "~/models/layer_image/agents/TileLayerImageAgent";
import Tile from "~/models/layer_image/Tile";

export const layerImageManager = new LayerImageManager();

const CanvasStack: Component<{}> = (props) => {
  const layerCanvasRefs: {
    [id: string]: LayerCanvasRef;
  } = {};

  const [dirtyRects, setDirtyRects] = createSignal<Tile[]>();

  const activeCanvasRef = () => {
    const active = activeLayer();

    if (active) return layerCanvasRefs[active.id];
    else return undefined;
  };

  onMount(() => {
    window.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key === "z") {
        const active = activeLayer();
        if (active) {
          const agent = layerImageManager.getAgent(active.id);
          agent?.undo();
        }
      } else if (e.ctrlKey && e.key === "y") {
        const active = activeLayer();
        if (active) {
          const agent = layerImageManager.getAgent(active.id);
          agent?.redo();
        }
      }
    });
  });

  createEffect(() => {
    const active = activeLayer();

    if (active) {
      const agent = layerImageManager.getAgent(active.id);
      console.log(agent)
      if (!agent) return;
      agent.setOnDrawingBufferChangeListener("stack_dirty_rect", () => {
        setDirtyRects([...getDirtyRects()]);
      })
      agent.setOnImageChangeListener("stack_dirty_rect", () => {
        setDirtyRects([...getDirtyRects()]);
      })
    }
  })

  const getDirtyRects = () => {
    const active = activeLayer();
    if (active) {
      const agent = layerImageManager.getAgent(active.id);
      if (agent instanceof TileLayerImageAgent) {
        return (agent as TileLayerImageAgent).getDirtyTilesInAction();
      }
    }
    return [];
  }

  return (
    <div style={{ position: "relative" }}>
      <CanvasOverlaySVG dirtyRects={dirtyRects()} />

      <div
        class={styles.canvas_stack}
        style={{
          width: `${canvasStore.canvas.width}px`,
          height: `${canvasStore.canvas.height}px`,
        }}
      >
        <TouchableCanvas operator={new LayerCanvasOperator(() => activeCanvasRef()!!)} />

        <For each={allLayers()}>
          {(layer, index) => (
            <LayerCanvas manager={layerImageManager}
              ref={layerCanvasRefs[layer.id]}
              layer={layer}
              zIndex={allLayers().length - index()}
            />
          )}
        </For>
      </div>
    </div>
  );
};

export default CanvasStack;
</file>

<file path="components/canvas/stacks/ImagePool.tsx">
import interact from "interactjs";
import { Component, onMount } from "solid-js";

import styles from "@styles/components/canvas/image_pool.module.css";

const ImagePool: Component<{}> = (props) => {
  let imageRef: HTMLDivElement;

  onMount(() => {
    interact(imageRef)
      .resizable({
        // resize from all edges and corners
        edges: { left: true, right: true, bottom: true, top: true },

        listeners: {
          move(event) {
            var target = event.target;
            var x = parseFloat(target.getAttribute("data-x")) || 0;
            var y = parseFloat(target.getAttribute("data-y")) || 0;

            // update the element's style
            target.style.width = event.rect.width + "px";
            target.style.height = event.rect.height + "px";

            // translate when resizing from top or left edges
            x += event.deltaRect.left;
            y += event.deltaRect.top;

            target.style.transform = "translate(" + x + "px," + y + "px)";

            target.setAttribute("data-x", x);
            target.setAttribute("data-y", y);
          },
        },
        modifiers: [
          // keep the edges inside the parent
          interact.modifiers.restrictEdges({
            outer: "parent",
          }),

          // minimum size
          interact.modifiers.restrictSize({
            min: { width: 100, height: 50 },
          }),
        ],

        inertia: true,
      })
      .draggable({
        listeners: {
          move(event) {
            event.preventDefault();
            event.stopPropagation();
            const target = event.target;
            const x =
              (parseFloat(target.getAttribute("data-x")) || 0) + event.dx;
            const y =
              (parseFloat(target.getAttribute("data-y")) || 0) + event.dy;

            target.style.transform = `translate(${x}px, ${y}px)`;
            target.setAttribute("data-x", x);
            target.setAttribute("data-y", y);
          },
        },
      });
  });

  return (
    <div
      class={styles["resize-drag-container"]}
      ref={(r) => (imageRef = r)}
      onMouseDown={(e) => e.preventDefault()}
    >
      <div
        class={styles["image-container"]}
        onMouseDown={(e) => e.preventDefault()}
      >
        {/* <img class={styles["resize-image"]} src="/333121.jpg" /> */}
      </div>
    </div>
  );
};

export default ImagePool;
</file>

<file path="components/canvas/stacks/LayerCanvas.tsx">
import {
  Component,
  createEffect,
  createRenderEffect,
  createSignal,
  onMount,
  Ref,
} from "solid-js";
import { Layer } from "~/models/types/Layer";
import { canvasStore } from "~/stores/project/canvasStore";
import { layerImageStore } from "~/stores/project/layerImageStore";

import styles from "@styles/components/canvas/layer_canvas.module.css";
import { LayerImageManager } from "~/models/layer_image/LayerImageManager";
import LayerImageAgent from "~/models/layer_image/LayerImageAgent";
import { layerCanvas } from "~/styles/components/canvas/layer_canvas.css";
import { getCanvasImageRenderingAttribute, globalStore } from "~/stores/global/globalStore";

type Props = {
  manager: LayerImageManager,
  ref?: LayerCanvasRef;
  layer: Layer;
  zIndex: number;
};

export type LayerCanvasRef = {
  getLayer: () => Layer;
  getManager: () => LayerImageManager;
  getAgent: () => LayerImageAgent;
};

export const LayerCanvas: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;
  let ctx: CanvasRenderingContext2D | null = null;

  const agent = () => props.manager.getAgent(props.layer.id);

  createRefContent(
    () => props.ref,
    () => ({
      getLayer() {
        return props.layer
      },
      getManager() {
        return props.manager
      },
      getAgent() {
        return agent()
      },
    }),
  );

  const styleWidth = () => canvasStore.canvas.width;
  const styleHeight = () => canvasStore.canvas.height;
  const internalWidth = () =>
    canvasStore.canvas.width / props.layer.dotMagnification;
  const internalHeight = () =>
    canvasStore.canvas.height / props.layer.dotMagnification;

  onMount(() => {
    const agent = props.manager.registerAgent(props.layer.id, layerImageStore[props.layer.id]?.current)

    ctx = canvasRef?.getContext("2d") ?? null;
    if (ctx) agent.putImageInto(ctx)

    agent.setOnImageChangeListener("layercanvas_refresh", () => {
      if (ctx) {
        agent.putImageIntoForce(ctx)
      }
    })
    agent.setOnDrawingBufferChangeListener("layercanvas_refresh", () => {
      if (ctx) {
        agent.putDrawingBufferIntoForce(ctx)
      }
    })
  });

  const [renderAttr, setRenderAttr] = createSignal(getCanvasImageRenderingAttribute(globalStore.canvasRenderingMode))

  createEffect(() => {
    const image = layerImageStore[props.layer.id].current
    agent()?.setImage(image, true)
    if (ctx) agent()?.putImageIntoForce(ctx)

    setRenderAttr(getCanvasImageRenderingAttribute(globalStore.canvasRenderingMode))
  });

  return (
    <canvas
      ref={canvasRef}
      id={`canvas-${props.layer.id}`}
      data-layer-id={props.layer.name}
      class={layerCanvas({
        rendering: renderAttr(),
        hidden: !props.layer.enabled
      })}
      width={internalWidth()}
      height={internalHeight()}
      style={{
        width: `${styleWidth()}px`,
        height: `${styleHeight()}px`,
        "z-index": props.zIndex,
      }}
    />
  );
};

function createRefContent<T extends Exclude<unknown, Function>>(
  getRef: () => Ref<T>,
  createRef: () => T,
) {
  createRenderEffect(() => {
    const refProp = getRef();
    if (typeof refProp !== "function") {
      throw new Error(
        "Should never happen, as solid always passes refs as functions",
      );
    }

    let refFunc = refProp as (value: T) => void;

    refFunc(createRef());
  });
}
</file>

<file path="components/canvas/stacks/TouchableCanvas.tsx">
import { Component, createEffect, createSignal, onCleanup, onMount } from "solid-js";
import { canvasStore, setCanvasStore } from "~/stores/project/canvasStore";
import { Vec2 } from "~/models/types/Vector";
import LayerCanvasOperator from "~/models/layer_canvas/LayerCanvasOperator";
import { DrawState } from "~/models/layer_canvas/DrawState";
import { LayerImageManager } from "~/models/layer_image/LayerImageManager";

interface Props {
  operator: LayerCanvasOperator,
}

// レイヤーごとのキャンバスの上でタッチイベントを受けるだけのキャンバス
export const TouchableCanvas: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;

  const styleWidth = () => canvasStore.canvas.width;
  const styleHeight = () => canvasStore.canvas.height;

  const [lastPos, setLastPos] = createSignal<
    Vec2 | undefined
  >(undefined);
  const [temporaryOut, setTemporaryOut] = createSignal(false);

  function getOffset() {
    const rect = canvasRef!.getBoundingClientRect();
    return { x: rect.left, y: rect.top };
  }

  function getWindowMousePosition(e: MouseEvent | PointerEvent | TouchEvent) {
    let x = 0;
    let y = 0;

    if ("clientX" in e && "clientY" in e) {
      x = e.clientX;
      y = e.clientY;
    } else if ("touches" in e && e.touches.length > 0) {
      console.log("touch");
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }
    return { x, y };
  }

  function getCanvasMousePosition(e: MouseEvent | PointerEvent | TouchEvent) {
    const offset = getOffset();

    let x = 0;
    let y = 0;

    if ("clientX" in e && "clientY" in e) {
      x = e.clientX;
      y = e.clientY;
    } else if ("touches" in e && e.touches.length > 0) {
      console.log("touch");
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }

    const zoom = canvasStore.zoom;

    return {
      x: (x - offset.x) / zoom,
      y: (y - offset.y) / zoom,
    };
  }

  function isDrawableClick(e: PointerEvent): boolean {
    if (e.pointerType === "touch" || canvasStore.isCtrlPressed) return false;
    // right=1, left=2, middle=4
    // console.log(e.buttons)
    if (e.pointerType === "mouse" && e.buttons !== 1) return false;

    return true;
  }

  function handlePointerDown(e: PointerEvent) {
    if (!isDrawableClick(e)) return;

    const position = getCanvasMousePosition(e);
    props.operator.handleDraw(DrawState.start, position, lastPos());
    setCanvasStore("isInStroke", true);
    setLastPos(position);
  }

  function handlePointerCancel(e: PointerEvent) {
    console.warn("pointercancel", e);
    endStroke(getCanvasMousePosition(e));
  }

  function handlePointerMove(e: PointerEvent) {
    const windowPosition = getWindowMousePosition(e);
    const position = getCanvasMousePosition(e);
    setCanvasStore("lastMouseWindow", windowPosition);
    setCanvasStore("lastMouseOnCanvas", position);
    setCanvasStore("lastMouseOnZoomedCanvas", {
      x: position.x * canvasStore.zoom,
      y: position.y * canvasStore.zoom,
    });

    if (!isDrawableClick(e)) return;

    // 押したまま外に出てから戻ってきたときはそこから再開
    if (temporaryOut()) {
      setTemporaryOut(false);
      setCanvasStore("isInStroke", true);
      setLastPos(position);
    }
    if (!canvasStore.isInStroke || !lastPos()) return;

    props.operator.handleDraw(DrawState.move, position, lastPos());
    setLastPos(position);
  }

  function handlePointerUp(e: PointerEvent) {
    const position = getCanvasMousePosition(e);
    if (canvasStore.isInStroke) endStroke(position);
  }

  function handlePointerOut(e: PointerEvent) {
    // 出た時点でストロークを切る場合
    // const position = getCanvasMousePosition(e);
    // if (canvasStore.isInStroke) endStroke(position);

    // 出た時点でも押したままキャンバス内に戻ってきたらストロークを再開する場合
    if (canvasStore.isDragging) {
      const position = getCanvasMousePosition(e);
      props.operator.handleDraw(DrawState.move, position, lastPos());
      setTemporaryOut(true);
    }
  }

  function handleWheel(e: WheelEvent) {
    const windowPosition = getWindowMousePosition(e);
    const position = getCanvasMousePosition(e);
    setCanvasStore("lastMouseWindow", windowPosition);
    setCanvasStore("lastMouseOnCanvas", position);
    setCanvasStore("lastMouseOnZoomedCanvas", {
      x: position.x * canvasStore.zoom,
      y: position.y * canvasStore.zoom,
    });
  }

  function endStroke(position: Vec2) {
    props.operator.handleDraw(DrawState.end, position, lastPos());
    setCanvasStore("isInStroke", false);
    setLastPos(undefined);
    setTemporaryOut(false);
  }

  onMount(() => {
    window.addEventListener("pointerup", handlePointerUp);
    window.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("pointercancel", handlePointerCancel);
    window.addEventListener("wheel", handleWheel);
  });

  onCleanup(() => {
    window.removeEventListener("pointerup", handlePointerUp);
    window.removeEventListener("pointermove", handlePointerMove);
    window.removeEventListener("pointercancel", handlePointerCancel);
    window.removeEventListener("wheel", handleWheel);
  });

  createEffect(() => {
    if (canvasRef)
      setCanvasStore("canvasElementSize", {
        width: canvasRef.clientWidth,
        height: canvasRef.clientHeight,
      });
  })

  return (
    <canvas
      ref={(el) => {
        canvasRef = el;
      }}
      width={canvasStore.canvas.width}
      height={canvasStore.canvas.height}
      onPointerDown={handlePointerDown}
      onPointerOut={handlePointerOut}
      style={{
        "touch-action": "none",
        width: `${styleWidth()}px`,
        height: `${styleHeight()}px`,
        "pointer-events": "all",
        "z-index": "100", // どのレイヤーよりも上だが、image poolよりも下
      }}
    />
  );
};
</file>

<file path="components/common/ColorBox.tsx">
import { Component } from "solid-js";
import { toolStore } from "~/stores/internal/toolsStore";
import { sayRandomQuote } from "./companion/QuotePool";

interface ColorBoxProps {
  enableUsingSelection?: boolean;
  sizePx?: number;
  color: string;
  onClick?: (color: string) => void;
}

const ColorBox: Component<ColorBoxProps> = (props: ColorBoxProps) => {
  const size = props.sizePx || 10;

  const isSelected = () =>
    props.enableUsingSelection &&
    toolStore.tools[toolStore.usingIndex].color === props.color;
  const isWhiteOrNone = () =>
    props.color === "none" || props.color.toLowerCase() === "#ffffff";

  const onColorClicked = (color: string) => {
    sayRandomQuote("color-pick", { color: color });
    if (props.onClick) props.onClick(color);
  };

  return (
    <div
      style={{
        position: "relative",
        display: "flex",
        width: `${size}px`,
        height: `${size}px`,
        "align-items": "center",
        "justify-content": "center",
        cursor: "pointer",
        "background-color": props.color,
        border:
          isWhiteOrNone() || isSelected()
            ? "0.05rem solid black"
            : "0.05rem solid transparent",
      }}
      onClick={() => {
        onColorClicked(props.color);
      }}
    >
      {props.enableUsingSelection && isSelected() && (
        <div
          style={{
            width: `${Math.round(size / 3)}px`,
            height: `${Math.round(size / 3)}px`,
            margin: 0,
            padding: 0,
            "background-color": "black",
          }}
          onClick={() => {
            onColorClicked(props.color);
          }}
        />
      )}
    </div>
  );
};

export default ColorBox;
</file>

<file path="components/common/companion/Companion.tsx">
import { Component, createEffect, createSignal } from "solid-js";

import styles from "@styles/components/companion.module.css";

const [sayRequest, setSayRequest] = createSignal<string | null>(null);

export const CompanionEvents = {
  sayRequest,
  setSayRequest,
};

const Companion: Component = () => {
  const [quote, setQuote] = createSignal("");

  const say = (text: string) => {
    window.speak?.(text, {
      amplitude: 5,
      pitch: 10,
      speed: 200,
      wordgap: 0,
    });
  };

  createEffect(() => {
    const message = CompanionEvents.sayRequest();
    if (message) {
      say(message);
      setQuote(message);
      const element = document.getElementById("companion");
      setTimeout(() => {
        setQuote("");
        if (element)
          element.className = element.className.replace(
            ` ${styles["giggle"]}`,
            "",
          );
      }, 5000);
      window.requestAnimationFrame(function (time) {
        window.requestAnimationFrame(function (time) {
          if (element) element.className += ` ${styles["giggle"]}`;
        });
      });
      CompanionEvents.setSayRequest(null); // 一度で消費
    }
  });

  return (
    <div class={styles.root}>
      <div class={styles.wrapper}>
        <div class={styles.companion} id="companion">
          <img src="/companion.png" alt="you challenge me?" />
        </div>
        {quote() && (
          <div class={styles.quote_box_container}>
            <div class={styles.quote_box}>
              <p class={styles.quote}>{quote()}</p>
            </div>
          </div>
        )}
      </div>
      <div id="audio" />
    </div>
  );
};

let lastSpoke = 0;
export const smartSay = (text: string): boolean => {
  const now = Date.now();
  if (now - lastSpoke > 5000) {
    CompanionEvents.setSayRequest(text);
    lastSpoke = now;
    return true;
  }
  return false;
};

export default Companion;
</file>

<file path="components/common/companion/QuotePool.ts">
import { smartSay } from "./Companion";

type QuoteCategory =
  | "color-pick"
  | "pen-resize"
  | "canvas-resize"
  | "undo-spam"
  | "random";

const lastSaidIndexes = {
  "color-pick": -1,
  "pen-resize": -1,
  "canvas-resize": -1,
  "undo-spam": -1,
  random: -1,
};
export const quotePool = {
  "color-pick": [
    "That color again? You really love it, huh.",
    "A fine choice, but not the finest.",
    "I see you're going with [color]. Bold.",
  ],
  "pen-resize": [
    "Hmm, Not quite my size.",
    "Go bigger, I'll crash 'em harder.",
    'Have you ever heard of the word "pixel perfect"?',
  ],
  "canvas-resize": [
    "Shrinking the canvas? Afraid of commitment?",
    "Small canvas, big ideas. I like it.",
  ],
  "undo-spam": [
    "UNDO UNDO UNDO—are you OK?",
    "That's the 5th undo. I’m getting dizzy.",
  ],
  random: ["Daisy, Daisy, give me your answer do do do"],
};

export const sayRandomQuote = (category: QuoteCategory, context?: any) => {
  const quotes = quotePool[category];
  let index = Math.floor(Math.random() * quotes.length);
  // 前になんか言った
  if (lastSaidIndexes[category] != -1) {
    console.log(
      `I previously said ${lastSaidIndexes[category]}. try saying something new.`,
    );
    if (quotes.length == 1) {
      console.log(`argh. nothing to say.`);
      // もう言えることない
      return "";
    } else {
      // console.log(`how about this?. ${index}`);
      // あるなら抽選続ける
      while (index === lastSaidIndexes[category]) {
        index = Math.floor(Math.random() * quotes.length);
        // console.log(`NO. how about this?. ${index}`);
      }
      console.log(`yeah. ${index} is a brand new. let's say it.`);
    }
  }
  let quote = quotes[index];
  quote = context?.color ? quote.replace("[color]", context.color) : quote;
  if (smartSay(quote)) {
    console.log(`◯ yay!`);
    lastSaidIndexes[category] = index;
  } else {
    console.log(`✕ hmm maybe I'd keep silence now?`);
  }
};
</file>

<file path="components/common/Dropdown.tsx">
import { Component, JSX } from "solid-js";
import { dropdownRoot } from "~/styles/components/dropdown.css";

export type DropdownOption<T extends string | number> = {
    label: string;
    value: T;
};

interface Props<T extends string | number = string> {
    value: T | (() => T);
    selected: T | (() => T);
    /** 選択候補 */
    options: DropdownOption<T>[];
    /** 値変更時に呼び出される */
    onChange?: (value: T) => void;
    /** aria-label など任意で渡す */
    props?: JSX.SelectHTMLAttributes<HTMLSelectElement>;
}

const Dropdown = <T extends string | number>(p: Props<T>) => {
    const getValue = () => typeof p.value === "function" ? (p.value as () => T)() : p.value;

    return <select
        {...p.props}
        class={dropdownRoot}
        value={String(getValue())}
        onChange={(e) => p.onChange?.(e.currentTarget.value as unknown as T)}
    >
        {p.options.map((o) => (
            <option selected={p.selected === o.value} value={String(o.value)}>{o.label}</option>
        ))}
    </select>
}

export default Dropdown;
</file>

<file path="components/common/DSLButton.tsx">
import styles from "@styles/components/dsl_button.module.css";
import { Component } from "solid-js";

interface Props {
  onClick?: (e: MouseEvent) => {};
}

const DSLButton: Component<Props> = (props: Props) => {
  return (
    <div
      class={styles.root}
      onMouseOver={(e) => {
        e.preventDefault();
        e.stopPropagation();
      }}
      onClick={props.onClick}
    >
      <img src="/DSL.png" />
    </div>
  );
};

export default DSLButton;
</file>

<file path="components/common/DSLEditor.tsx">
import { Component, createSignal, For, onMount } from "solid-js";
import { ALL_NODES } from "~/dsl/nodes/AvailableNodes";
import {
  activeIndex,
  activeLayer,
  setLayerStore,
} from "~/stores/project/layerStore";

const DSLEditor: Component<{}> = (props) => {
  let [activeDSLStr, setDSLStr] = createSignal("");

  onMount(() => {
    setDSLStr(activeLayer()?.dsl.toString() || "");
  });

  return (
    <div style={{ display: "flex", position: "relative" }}>
      <p style={{ "white-space": "pre-wrap" }}>{activeDSLStr()}</p>
      <div
        style={{
          display: "flex",
          "flex-direction": "column",
          gap: "10px",
          "z-index": 10,
        }}
      >
        <p>select command.</p>
        <For each={ALL_NODES}>
          {(node) => {
            return (
              <a
                onClick={async () => {
                  const dsl = activeLayer()?.dsl;
                  if (dsl === undefined) return;
                  dsl.addNode(node);
                  setLayerStore("layers", activeIndex(), "dsl", dsl);
                  setDSLStr(dsl.toString());
                }}
                style={{ cursor: "pointer" }}
              >
                &lt; {node.name}
              </a>
            );
          }}
        </For>
      </div>
      ;
    </div>
  );
};

export default DSLEditor;
</file>

<file path="components/common/ImportImageButton.tsx">
import { importImageToActiveLayer } from "~/io/internal/import"; // 上で作った関数

const ImportImageButton = () => {
  let fileInputRef: HTMLInputElement | undefined;

  const handleClick = () => {
    fileInputRef?.click(); // hidden input を手動でクリック
  };

  const handleFileChange = (e: Event) => {
    const target = e.currentTarget as HTMLInputElement;
    const file = target.files?.[0];
    if (file) {
      importImageToActiveLayer(file);
      target.value = ""; // 同じファイルを再選択可能にする
    }
  };

  return (
    <>
      <button onClick={handleClick}>Import</button>

      <input
        type="file"
        accept="image/*"
        ref={fileInputRef}
        style={{ display: "none" }}
        onChange={handleFileChange}
      />
    </>
  );
};

export default ImportImageButton;
</file>

<file path="components/common/LayerPreview.tsx">
import { Component, createEffect, onMount } from "solid-js";
import { Layer } from "~/models/types/Layer";

import styles from "@styles/components/layer_preview.module.css";
import { layerImageStore } from "~/stores/project/layerImageStore";
import { layerImageManager } from "../canvas/stacks/CanvasStack";
import { v4 as uuidv4 } from "uuid";

interface Props {
  layer: Layer;
  maxWidth?: number;
  maxHeight?: number;
  onClick?: () => void;
}

const LayerPreview: Component<Props> = (props: Props) => {
  const id = uuidv4();
  let wrapperRef: HTMLDivElement;
  let canvasRef: HTMLCanvasElement;

  const updatePreview = (originalImage: ImageData, targetHeight: number) => {
    const aspectRatio = originalImage.width / originalImage.height;
    const targetWidth = Math.round(targetHeight * aspectRatio);

    // 描画対象キャンバスの解像度とCSSサイズを一致させる
    canvasRef.width = targetWidth;
    canvasRef.height = targetHeight;

    const maxWidth = props.maxWidth
    const maxHeight = props.maxHeight
    let zoom = 1;
    // if (maxWidth && targetWidth > maxWidth) zoom = maxWidth / targetWidth;
    // if (maxHeight && targetHeight > maxHeight && zoom < maxHeight / targetHeight) zoom = maxHeight / targetHeight;

    canvasRef.style.width = `${targetWidth * zoom}px !important`;
    canvasRef.style.height = `${targetHeight * zoom}px !important`;

    wrapperRef.style.width = `${targetWidth * zoom}px !important`;
    wrapperRef.style.height = `${targetHeight * zoom}px !important`;

    const tmpCanvas = document.createElement("canvas");
    tmpCanvas.width = originalImage.width;
    tmpCanvas.height = originalImage.height;
    tmpCanvas.getContext("2d")!.putImageData(originalImage, 0, 0);

    const ctx = canvasRef.getContext("2d")!;
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, targetWidth, targetHeight);

    ctx.drawImage(
      tmpCanvas,
      0,
      0,
      originalImage.width,
      originalImage.height,
      0,
      0,
      targetWidth,
      targetHeight,
    );
  };

  onMount(() => {
    const agent = layerImageManager.getAgent(props.layer.id)
    agent?.setOnImageChangeListener("layer_preview_" + id, () => {
      const height = wrapperRef.clientHeight;
      updatePreview(agent.getImage(), height);
    })
  })

  return (
    <div ref={(el) => (wrapperRef = el)}>
      <canvas
        class={styles.canvas}
        ref={(el) => (canvasRef = el)}
        onClick={(e) => {
          if (props.onClick) props.onClick()
        }
        } />
    </div>
  );
};

export default LayerPreview;
</file>

<file path="components/common/Light.tsx">
import styles from "@styles/components/light.module.css";
import { Component, Show } from "solid-js";

interface LightProps {
  class?: string;
  on?: boolean;
}

const Light: Component<LightProps> = (props: LightProps) => {
  const width = 8;
  const height = 8;
  const radius = 2;

  return (
    <svg
      class={props.class}
      style={{
        width: `${width}px`,
        height: `${height}px`,
        overflow: "visible",
      }}
      viewBox={`0 0 ${width} ${height}`}
      xmlns="http://www.w3.org/2000/svg"
    >
      <Show when={true}>
        <g class={`${styles["light-inner"]} ${props.on && styles["on"]}`}>
          <circle cx={width / 2} cy={height / 2} r={radius} fill="red" />
        </g>
      </Show>
    </svg>
  );
};

export default Light;
</file>

<file path="components/common/Slider.tsx">
import styles from "@styles/components/slider.module.css";
import { Component, createSignal } from "solid-js";

interface SliderProps {
  min: number;
  max: number;
  default: number;
  allowFloat?: boolean;

  onValueChanged?: (newValue: number) => void;
}

const Slider: Component<SliderProps> = (props) => {
  let sliderRef: HTMLDivElement | undefined;
  const [isDrag, setDrag] = createSignal(false);
  const [value, setValue] = createSignal(props.default);

  const percent = () => ((value() - props.min) / (props.max - props.min)) * 100;

  const handlePointerDown = (e: PointerEvent) => {
    setDrag(true);

    window.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("pointerup", handlePointerUp);
  };

  const handlePointerMove = (e: PointerEvent) => {
    if (!sliderRef || !isDrag()) return;
    const rect = sliderRef.getBoundingClientRect();
    let pos = e.clientX - rect.left;
    pos = Math.max(0, Math.min(pos, rect.width)); // clamp

    const newValueRaw =
      props.min + (pos / rect.width) * (props.max - props.min);
    const newValue = props.allowFloat ? newValueRaw : Math.round(newValueRaw);
    setValue(newValue);
    if (props.onValueChanged) props.onValueChanged(newValue);
  };

  const handlePointerUp = (e: PointerEvent) => {
    setDrag(false);
    window.removeEventListener("pointermove", handlePointerMove);
    window.removeEventListener("pointerup", handlePointerUp);
  };

  const onLineClick = (e: MouseEvent) => {
    if (!sliderRef) return;
    const rect = sliderRef.getBoundingClientRect();
    let pos = e.clientX - rect.left;
    pos = Math.max(0, Math.min(pos, rect.width)); // clamp

    const newValueRaw =
      props.min + (pos / rect.width) * (props.max - props.min);
    const newValue = props.allowFloat ? newValueRaw : Math.round(newValueRaw);
    setValue(newValue);
    if (props.onValueChanged) props.onValueChanged(newValue);
  };

  return (
    <div class={styles.root}>
      <div class={styles.slider} ref={sliderRef}>
        <div
          class={styles["line-hitbox"]}
          onPointerDown={handlePointerDown}
          onClick={onLineClick}
        >
          <div class={styles.line} />
        </div>
        <div style={{ left: `${percent()}%` }} class={styles.handle} />
      </div>
    </div>
  );
};

export default Slider;
</file>

<file path="components/common/ToggleSwitch.tsx">
import { Component } from "solid-js";
import {
    toggleWrapper,
    toggleTrack,
    toggleThumb,
    toggleInput,
} from "~/styles/components/toggle_switch.css";

interface Props {
    checked: boolean;
    onChange?: (checked: boolean) => void;
    /** 任意でラベル等を配置する場合の slot */
    children?: any;
}

const ToggleSwitch: Component<Props> = (p) => (
    /* label 全体でクリック可能に */
    <label class={toggleWrapper}>
        {p.children}
        <input
            type="checkbox"
            checked={p.checked}
            onInput={(e) => p.onChange?.(e.currentTarget.checked)}
            class={toggleInput}
        />
        <span class={toggleTrack}>
            <span class={toggleThumb} />
        </span>
    </label>
);

export default ToggleSwitch;
</file>

<file path="components/EdgeInfo.tsx">
import { Component } from "solid-js";

import { projectStore } from "~/stores/project/projectStore";
import { sideAreaEdge, sideAreaEdgeText } from "~/styles/global.css";

const EdgeInfo: Component<{}> = (props) => {
  return (
    <div class={sideAreaEdge}>
      <p class={sideAreaEdgeText}>
        &nbsp;&nbsp;{projectStore.path || "path N/A"}
      </p>
      {/* <p class={sideAreaEdgeText}>{projectStore.name || "name N/A"}</p> */}
    </div>
  );
};

export default EdgeInfo;
</file>

<file path="components/section/CanvasSettings.tsx">
import { Component, createSignal } from "solid-js";
import { initLayerImage } from "~/models/layer/layerImage";
import { canvasStore, setCanvasStore } from "~/stores/project/canvasStore";
import { allLayers, layerStore } from "~/stores/project/layerStore";

import { adjustZoomToFit } from "~/stores/project/canvasStore";
import {
  canvasSizeButton,
  canvasSizeForm,
  canvasSizeInput,
  canvasSizeLabel,
} from "~/styles/section/canvas.css";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";

const CanvasSettings: Component<{}> = (props) => {
  const [width, setWidth] = createSignal(canvasStore.canvas.width);
  const [height, setHeight] = createSignal(canvasStore.canvas.height);

  const changeCanvasSize = (e: any) => {
    e.preventDefault();
    setCanvasStore("canvas", "width", width());
    setCanvasStore("canvas", "height", height());

    allLayers().forEach((layer, i) => {
      initLayerImage(layer.id, layer.dotMagnification);
    });

    adjustZoomToFit(width(), height());
  };

  const resetAllLayers = (e: any) => {
    layerStore.layers.forEach((l) => {
      initLayerImage(l.id, l.dotMagnification);
    });
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>canvas.</p>

      <form
        class={sectionContent}
        onSubmit={(e) => {
          changeCanvasSize(e);
        }}
      >
        <div class={canvasSizeForm}>
          <div>
            <p class={canvasSizeLabel}>width</p>
            <input
              class={canvasSizeInput}
              type="number"
              name="width"
              onChange={(e) => setWidth(Number(e.target.value))}
              value={width()}
              min={0}
              max={10000}
              required
            />
          </div>
          <div>
            <p class={canvasSizeLabel}>height</p>
            <input
              class={canvasSizeInput}
              type="number"
              name="height"
              onChange={(e) => setHeight(Number(e.target.value))}
              value={height()}
              min={0}
              max={10000}
              required
            />
          </div>
          <button class={canvasSizeButton} type="submit">
            change
          </button>
        </div>
      </form>

      <button class={canvasSizeButton} onClick={resetAllLayers}>
        RESET ALL LAYERS
      </button>
    </div>
  );
};

export default CanvasSettings;
</file>

<file path="components/section/Color.tsx">
import { Component, For } from "solid-js";
import { colorStore } from "~/stores/internal/colorStore";

import ColorPicker from "~/components/section/item/ColorPicker";
import { setCurrentToolColor } from "~/models/types/Tool";
import {
  colorElemDescription,
  descriptionContainer,
  swatchContainer,
} from "~/styles/section/color.css";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";
import ColorBox from "../common/ColorBox";

const Color: Component<{}> = (props) => {
  const onColorClicked = (color: string, index: number) => {
    setCurrentToolColor(color);
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>color.</p>
      <div
        class={sectionContent}
        style={{ "flex-direction": "row", margin: "8px 0" }}
      >
        <div class={descriptionContainer}>
          <p class={colorElemDescription}>swatch.</p>
        </div>
        <div class={swatchContainer}>
          <For each={colorStore.swatches}>
            {(item, index) => (
              <ColorBox
                color={item}
                sizePx={8}
                onClick={(color) => onColorClicked(color, index())}
                enableUsingSelection={true}
              />
            )}
          </For>
        </div>
        <div class={descriptionContainer}>
          <p class={colorElemDescription}>picker.</p>
        </div>
        <ColorPicker />
      </div>
    </div>
  );
};

export default Color;
</file>

<file path="components/section/GlobalSettings.tsx">
import { Component, createEffect, createSignal, onMount } from "solid-js";
import {
    sectionCaption,
    sectionContent,
    sectionRoot,
} from "~/styles/section_global.css";
import Dropdown, { DropdownOption } from "../common/Dropdown";
import ToggleSwitch from "../common/ToggleSwitch";
import { CanvasRenderingMode, globalStore, setGlobalStore } from "~/stores/global/globalStore";
import { loadGlobalSettings, saveGlobalSettings } from "~/io/global/globalIO";

const renderingOptions: DropdownOption<CanvasRenderingMode>[] = [
    { label: "adaptive", value: "adaptive" },
    { label: "pixelated", value: 'pixelated' },
    { label: "crispEdges", value: 'crispEdges' },
];

const [autoSave, setAutoSave] = createSignal(true);

const GlobalSettings: Component<{}> = (props) => {
    return (
        <div class={sectionRoot}>
            <p class={sectionCaption}>settings.</p>
            <div class={sectionContent} style={{ gap: "8px" }}>

                <ToggleSwitch checked={autoSave()} onChange={setAutoSave}>
                    <p style={{ "font-size": "0.5rem" }}>   autosave.</p>
                </ToggleSwitch>

                <p>canvas rendering.</p>

                <Dropdown
                    selected={globalStore
                        .canvasRenderingMode
                    }
                    value={globalStore
                        .canvasRenderingMode}
                    options={renderingOptions}
                    onChange={(v) => {
                        setGlobalStore("canvasRenderingMode", v)
                        saveGlobalSettings()
                    }}
                />

            </div>
        </div>
    );
};

export default GlobalSettings;
</file>

<file path="components/section/item/ColorPicker.tsx">
import iro from "@jaames/iro";
import { IroColorPicker } from "@jaames/iro/dist/ColorPicker";
import { Component, createEffect } from "solid-js";
import { setCurrentToolColor } from "~/models/types/Tool";
import { currentTool } from "~/stores/internal/toolsStore";

const ColorPicker: Component<{}> = (props) => {
  let colorPicker: IroColorPicker;

  createEffect(() => {
    colorPicker.setColors([currentTool().color]);
  });

  return (
    <div
      ref={(el) => {
        colorPicker = iro.ColorPicker(el, {
          width: 150,
          padding: 0,
          color: currentTool().color,
          handleRadius: 4,
          layoutDirection: "horizontal",
          layout: [
            {
              component: iro.ui.Box,
              options: {},
            },
            {
              component: iro.ui.Slider,
              options: {
                // can also be 'saturation', 'value', 'red', 'green', 'blue', 'alpha' or 'kelvin'
                sliderType: "hue",
              },
            },
          ],
        });
        colorPicker.on("color:change", function (color: any) {
          setCurrentToolColor(color.hexString);
        });
      }}
    ></div>
  );
};

export default ColorPicker;
</file>

<file path="components/section/item/LayerItem.tsx">
import { createSortable, useDragDropContext } from "@thisbeyond/solid-dnd";
import { Component } from "solid-js";
import Light from "~/components/common/Light";
import { getNextMagnification } from "~/models/factories/utils";
import { Layer, LayerType } from "~/models/types/Layer";
import { layerStore, setLayerStore } from "~/stores/project/layerStore";
import {
  activeLight,
  dotMagnifContainer,
  dotMagnifText,
  layerItem,
  layerItemDisabled,
  layerItemName,
  layerItemType,
} from "~/styles/section/layer.css";
import { w100 } from "~/styles/snippets.css";
import LayerPreview from "../../common/LayerPreview";

interface LayerItemProps {
  index: number;
  layer: Layer;
  draggingId?: string | null;
}

const LayerItem: Component<LayerItemProps> = (props) => {
  const { layer, draggingId } = props;

  const sortable = createSortable(layer.id);
  const context = useDragDropContext();
  const state = context?.[0];

  let detClass: "dot" | "image" | "automate" | undefined;
  switch (layer.type) {
    case LayerType.Dot:
      detClass = "dot";
      break;
    case LayerType.Image:
      detClass = "image";
      break;
    case LayerType.Automate:
      detClass = "automate";
      break;
  }

  const onDetClicked = () => {
    setLayerStore("activeLayerId", layer.id);
  };

  const onPreviewClicked = () => {
    if (props.index !== -1) {
      setLayerStore("layers", props.index, "enabled", (v: boolean) => !v);
    }
  };

  const onMagnifClicked = () => {
    const next = getNextMagnification(layer.dotMagnification);
    if (props.index !== -1) {
      setLayerStore("layers", props.index, "dotMagnification", next);
    }
  };

  const isActive = () => layerStore.activeLayerId === layer.id;

  return (
    <div
      class={w100}
      classList={{
        "opacity-50": sortable.isActiveDraggable,
        "transition-transform": state && !!state.active.draggable,
      }}
      style={{ opacity: draggingId === layer.id ? 0.4 : 1 }}
      ref={sortable}
    >
      <p class={layerItemType}>{layer.typeDescription}</p>
      <p>{props.index}.</p>
      <div style={{ display: "flex", "align-items": "center" }}>
        {/* <DSLButton /> */}
        <div
          class={[layerItem, !layer.enabled && layerItemDisabled]
            .filter(Boolean)
            .join(" ")}
          onClick={onDetClicked}
        >
          <LayerPreview layer={layer} onClick={onPreviewClicked} maxHeight={30} maxWidth={30} />
          <p class={layerItemName}> {layer.name}</p>
          <div
            class={dotMagnifContainer}
            onClick={(e) => {
              e.stopPropagation();
              onMagnifClicked();
            }}
            onMouseOver={(e) => e.stopPropagation()}
          >
            <p class={dotMagnifText}>x{layer.dotMagnification}</p>
          </div>
          <Light class={activeLight} on={isActive()} />
        </div>
      </div>
    </div>
  );
};

export default LayerItem;
</file>

<file path="components/section/item/PenItem.tsx">
import { Component } from "solid-js";
import ColorBox from "~/components/common/ColorBox";
import { sayRandomQuote } from "~/components/common/companion/QuotePool";
import Light from "~/components/common/Light";
import Slider from "~/components/common/Slider";
import { Tool } from "~/models/types/Tool";
import { toolStore, setToolStore } from "~/stores/internal/toolsStore";
import { penConfigRow, penConfigRowName } from "~/styles/section/pen.css";

interface Props {
  pen: Tool;
  isInUse: boolean;
}

const PenItem: Component<Props> = (props: Props) => {
  return (
    <div class={penConfigRow}>
      <Light on={props.isInUse} />

      <p
        class={penConfigRowName}
        style={{
          color: props.isInUse ? "red" : "unset",
        }}
        onClick={() => {
          setToolStore({ usingIndex: toolStore.tools.indexOf(props.pen) });
        }}
      >
        {props.pen.name}.
      </p>

      <ColorBox color={props.pen.color} sizePx={8} />

      <div style={{ "flex-grow": 1 }}>
        <Slider
          min={1}
          max={30}
          default={props.pen.size}
          onValueChanged={(newValue) => {
            sayRandomQuote("pen-resize");
            console.log("size set to " + newValue);
            const penIndex = toolStore.tools.findIndex(
              (p) => p.id === props.pen.id,
            );
            setToolStore("tools", penIndex, "size", newValue);
          }}
        />
      </div>

      <p style={{ width: "auto" }}>{props.pen.size}.</p>
    </div>
  );
};

export default PenItem;
</file>

<file path="components/section/LayerList.tsx">
import {
  closestCenter,
  DragDropProvider,
  DragDropSensors,
  SortableProvider,
} from "@thisbeyond/solid-dnd";
import { Component, createEffect, createSignal, For, onMount } from "solid-js";
import { addLayer } from "~/models/factories/addLayer";
import { removeLayer } from "~/models/factories/removeLayer";
import {
  activeLayer,
  allLayers,
  layerStore,
  setLayerStore,
} from "~/stores/project/layerStore";
import { layerList } from "~/styles/section/layer.css";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";
import { flexRow } from "~/styles/snippets.css";
import LayerItem from "./item/LayerItem";
// 並べ替え用ユーティリティ関数

const LayerList: Component<{}> = () => {
  const [items, setItems] = createSignal(allLayers());
  const [activeItem, setActiveItem] = createSignal(null);
  const ids = () => items().map((l) => l.id);

  onMount(() => {
    setItems(allLayers());
  });

  createEffect(() => {
    setItems(allLayers());
  });

  const onDragStart = ({ draggable }: { draggable: any }) =>
    setActiveItem(draggable.id);

  function moveLayer(draggedId: string, targetIndex: number) {
    const fromIndex = layerStore.layers.findIndex((l) => l.id === draggedId);
    if (fromIndex === -1 || fromIndex === targetIndex) return;

    const updated = [...layerStore.layers];
    const [moved] = updated.splice(fromIndex, 1);
    updated.splice(targetIndex, 0, moved);
    setLayerStore("layers", updated);
    setItems(allLayers());
  }

  const onDragEnd = ({
    draggable,
    droppable,
  }: {
    draggable: any;
    droppable: any;
  }) => {
    if (draggable && droppable) {
      const currentItems = ids();
      const fromIndex = currentItems.indexOf(draggable.id);
      const toIndex = currentItems.indexOf(droppable.id);
      if (fromIndex !== toIndex) {
        moveLayer(draggable.id, toIndex);
      }
    }
  };

  return (
    <DragDropProvider
      onDragStart={onDragStart}
      onDragEnd={(e) => {
        onDragEnd({ draggable: e.draggable, droppable: e.droppable });
      }}
      collisionDetector={closestCenter}
    >
      <DragDropSensors>
        <div class={sectionRoot}>
          <div class={flexRow} style={{ "margin-bottom": "6px" }}>
            <p class={sectionCaption} style={{ "flex-grow": 1 }}>
              layers.
            </p>

            <div class={flexRow} style={{ gap: "4px" }}>
              <button
                onClick={() => {
                  addLayer("dot1");
                  setItems(allLayers());
                }}
              >
                + add.
              </button>

              <button
                onClick={() => {
                  removeLayer(activeLayer()?.id);
                  setItems(allLayers());
                }}
              >
                - remove.
              </button>
            </div>
          </div>
          <div class={sectionContent}>
            <div class={layerList}>
              <SortableProvider ids={ids()}>
                <For each={items()}>
                  {(layer, index) => (
                    <LayerItem layer={layer} index={index()} />
                  )}
                </For>
              </SortableProvider>
            </div>
            {/* <DragOverlay>
                                    <div class="sortable"><LayerItem layer={activeItemLayer()} /></div>
                                </DragOverlay> */}
          </div>
        </div>
      </DragDropSensors>
    </DragDropProvider>
  );
};

export default LayerList;
</file>

<file path="components/section/PenConfig.tsx">
import { Component, For } from "solid-js";
import { toolStore } from "~/stores/internal/toolsStore";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";
import PenItem from "./item/PenItem";

const PenConfig: Component<{}> = (props) => {
  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>pen config.</p>
      <div class={sectionContent}>
        <For each={toolStore.tools}>
          {(item, index) => (
            <PenItem pen={item} isInUse={index() === toolStore.usingIndex} />
          )}
        </For>
      </div>
    </div>
  );
};

export default PenConfig;
</file>

<file path="components/section/Project.tsx">
import { Component, createSignal } from "solid-js";
import { saveProject } from "~/io/project/project";

import { exportActiveLayerUpscaled } from "~/io/internal/export";
import { projectStore, setProjectStore } from "~/stores/project/projectStore";
import { projectNameInput } from "~/styles/section/project.css";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";
import { flexCol, flexRow } from "~/styles/snippets.css";

const Project: Component<{}> = (props) => {
  const [saveLog, setSaveLog] = createSignal<string | undefined>(undefined);

  const save = () => {
    if (projectStore.name && projectStore.path) {
      // 上書き保存
      saveProject(`${projectStore.path}`).then(() => {
        setSaveLog("saved!");
        setProjectStore("isProjectChangedAfterSave", false);
      });
    } else {
      saveProject().then(() => {
        setSaveLog("saved!");
        setProjectStore("isProjectChangedAfterSave", false);
      });
    }
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>project.</p>
      <div class={sectionContent}>
        <div class={flexCol}>
          <input
            class={projectNameInput}
            type="text"
            name="height"
            onChange={(e) => {
              setProjectStore("name", e.target.value);
            }}
            value={projectStore.name}
            placeholder="project name"
            autocomplete="off"
            required
          />

          {/* <p class={styles.project_file_path}>{projectStore.path}</p> */}
        </div>
        {/* <button class={styles.loadsave_button} onClick={() => importProjectJsonFromFileSelection()}>
                        load.
                    </button> */}

        <div
          class={flexRow}
          style={{ "align-items": "center", "margin-top": "12px" }}
        >
          <button onClick={() => exportActiveLayerUpscaled()}>export.</button>
          {/*   {!projectStore.isProjectChangedAfterSave && <p class={styles.save_log}>{saveLog()}</p>} */}
        </div>
      </div>
    </div>
  );
};

export default Project;
</file>

<file path="components/SideSections.tsx">
import { Component } from "solid-js";
import CanvasSettings from "./section/CanvasSettings";
import Color from "./section/Color";
import LayerList from "./section/LayerList";
import PenConfig from "./section/PenConfig";
import Project from "./section/Project";

import { sideAreaContent } from "~/styles/global.css";
import GlobalSettings from "./section/GlobalSettings";

const SideSections: Component<{}> = (props) => {
  return (
    <div class={sideAreaContent}>
      <a onClick={() => (window.location.href = "/")}>&lt; back</a>
      <Project />
      <Color />
      <PenConfig />
      <LayerList />
      <CanvasSettings />
      <GlobalSettings />
    </div>
  );
};

export default SideSections;
</file>

<file path="components/TitleBar.tsx">
import { Window } from "@tauri-apps/api/window";
import { createSignal } from "solid-js";
import {
  titleBarControlButtonImg,
  titleBarControlCloseButton,
  titleBarControlMaximizeButton,
  titleBarControlMinimizeButton,
  titleBarControls,
  titleBarRoot,
  titleBarTitle,
} from "~/styles/components/title_bar.css";

export default function TitleBar() {
  const appWindow = new Window("main");

  const [isMaximized, setMaximized] = createSignal(false);

  appWindow.onResized(async (handler) => {
    console.log("resize");
    setMaximized(await appWindow.isMaximized());
  });

  return (
    <header style={{ "pointer-events": "all" }}>
      <nav class={titleBarRoot} data-tauri-drag-region="p, button">
        <p class={titleBarTitle}>sledge.</p>
        <div class={titleBarControls}>
          <button
            class={titleBarControlMinimizeButton}
            onClick={() => appWindow.minimize()}
          >
            <img class={titleBarControlButtonImg} src={"/minimize.png"} />
          </button>

          <button
            class={titleBarControlMaximizeButton}
            onClick={() => appWindow.toggleMaximize()}
          >
            <img
              class={titleBarControlButtonImg}
              src={isMaximized() ? "/leave_maximize.png" : "/maximize.png"}
            />
          </button>

          <button
            class={titleBarControlCloseButton}
            onClick={() => appWindow.close()}
          >
            <img class={titleBarControlButtonImg} src={"/close.png"} />
          </button>
        </div>
      </nav>
    </header>
  );
}
</file>

<file path="components/ToastContainer.tsx">
import styles from "@styles/components/toast.module.css";
import { For } from "solid-js";
import { setToasts, toasts } from "~/stores/internal/toastStore";

export default function ToastContainer() {
  return (
    <div class={styles.toastContainer}>
      <For each={toasts}>
        {(toast) => (
          <div class={styles.toast_root}>
            <div class={`${styles.toast} ${styles[toast.type]}`}>
              {toast.message}
            </div>
            {toast.isPersistent && (
              <a
                class={styles.close_persistent_button}
                onClick={() => {
                  setToasts((prev) => prev.filter((t) => t.id !== toast.id));
                }}
              >
                x
              </a>
            )}
          </div>
        )}
      </For>
    </div>
  );
}
</file>

<file path="io/global/globalIO.ts">
import {
  BaseDirectory,
  mkdir,
  readTextFile,
  writeTextFile,
} from '@tauri-apps/plugin-fs'
import { globalStore, setGlobalStore } from '~/stores/global/globalStore'

const FILE_NAME = 'global.sledgeconfig'

export async function saveGlobalSettings() {
  try {
    const json = JSON.stringify(globalStore)
    await mkdir('', { baseDir: BaseDirectory.AppConfig, recursive: true })
    await writeTextFile(FILE_NAME, json, { baseDir: BaseDirectory.AppConfig })
    console.log('[globalIO] 設定保存完了')
  } catch (e) {
    console.error('[globalIO] 設定保存失敗', e)
  }
}

export async function loadGlobalSettings() {
  try {
    const json = await readTextFile(FILE_NAME, {
      baseDir: BaseDirectory.AppConfig,
    })
    const data = JSON.parse(json)

    console.log(data)

    if (data.recentOpenedFiles) {
      setGlobalStore('recentOpenedFiles', data.recentOpenedFiles)
    }
    if (data.canvasRenderingMode) {
      setGlobalStore('canvasRenderingMode', data.canvasRenderingMode)
    }

    console.log('[globalIO] 設定読み込み完了')
  } catch (e) {
    console.warn('[globalIO] 設定ファイルが存在しないか、読み込み失敗:', e)
  }
}
</file>

<file path="io/internal/export.ts">
import { layerStore } from "~/stores/project/layerStore";

export function exportActiveLayerUpscaled(scale = 10) {
  const layerId = layerStore.activeLayerId;
  if (!layerId) return;

  const originalCanvas = document.getElementById(
    `canvas-${layerId}`,
  ) as HTMLCanvasElement;
  if (!originalCanvas) {
    alert("対象のレイヤーが見つかりません。");
    return;
  }

  const w = originalCanvas.width;
  const h = originalCanvas.height;

  // オフスクリーンキャンバスを作る
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = w * scale;
  exportCanvas.height = h * scale;

  const ctx = exportCanvas.getContext("2d");
  if (!ctx) {
    alert("Canvasコンテキスト取得に失敗しました。");
    return;
  }

  // ピクセル補間を無効化
  ctx.imageSmoothingEnabled = false;

  // 元のキャンバスをscale倍に引き伸ばして描画（補完なし）
  ctx.drawImage(originalCanvas, 0, 0, exportCanvas.width, exportCanvas.height);

  // エクスポート処理
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      alert("エクスポートに失敗しました。");
      return;
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${layerId}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, "image/png");
}

export function downloadImageData(
  imageData: ImageData,
  filename: string = "image",
  scale: number = 10,
) {
  // 一時的な canvas を作成
  const canvas = document.createElement("canvas");
  canvas.width = imageData.width;
  canvas.height = imageData.height;

  // ImageData を描画
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("2D context not available");
    return;
  }
  ctx.putImageData(imageData, 0, 0);

  const w = canvas.width;
  const h = canvas.height;

  // オフスクリーンキャンバスを作る
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = w * scale;
  exportCanvas.height = h * scale;

  const ctxEx = exportCanvas.getContext("2d");
  if (!ctxEx) {
    alert("Canvasコンテキスト取得に失敗しました。");
    return;
  }

  // ピクセル補間を無効化
  ctxEx.imageSmoothingEnabled = false;
  // 元のキャンバスをscale倍に引き伸ばして描画（補完なし）
  ctxEx.drawImage(canvas, 0, 0, exportCanvas.width, exportCanvas.height);

  // エクスポート処理
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      alert("エクスポートに失敗しました。");
      return;
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${filename}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, "image/png");
}
</file>

<file path="io/internal/import.ts">
import { registerNewHistory } from '~/models/layer/layerImage'
import { layerImageStore } from '~/stores/project/layerImageStore'
import { layerStore } from '~/stores/project/layerStore'

// 画像ファイルをキャンバスに焼き込む（補完なし・左上合わせ・切り捨て）
export function importImageToActiveLayer(file: File) {
  const layerId = layerStore.activeLayerId
  if (!layerId) return

  const imageData = layerImageStore[layerId]?.current
  if (!imageData) {
    alert('現在のレイヤーに描画できません。')
    return
  }

  const img = new Image()
  const reader = new FileReader()

  reader.onload = (e) => {
    img.onload = () => {
      const w = imageData.width
      const h = imageData.height

      // オフスクリーンCanvasで描画 → ImageData取得
      const canvas = document.createElement('canvas')
      canvas.width = w
      canvas.height = h
      const ctx = canvas.getContext('2d')
      if (!ctx) return

      ctx.imageSmoothingEnabled = false
      ctx.clearRect(0, 0, w, h)
      ctx.drawImage(img, 0, 0, w, h) // 左上にそのまま描く（拡大/縮小なし）

      const importedData = ctx.getImageData(0, 0, w, h)
      registerNewHistory(layerId, importedData)
    }
    img.src = e.target?.result as string
  }

  reader.readAsDataURL(file)
}
</file>

<file path="io/project/project.ts">
// src/io/project.ts
import { path } from '@tauri-apps/api'
import { open as dialogOpen, save } from '@tauri-apps/plugin-dialog'
import {
  BaseDirectory,
  mkdir,
  readTextFile,
  writeTextFile,
} from '@tauri-apps/plugin-fs'
import { initLayerImage } from '~/models/layer/layerImage'
import { Layer } from '~/models/types/Layer'
import { addRecent } from '~/stores/global/globalStore'
import {
  adjustZoomToFit,
  canvasStore,
  centeringCanvas,
  setCanvasStore,
} from '~/stores/project/canvasStore'
import {
  layerImageStore,
  setLayerImageStore,
} from '~/stores/project/layerImageStore'
import {
  findLayerById,
  layerStore,
  setLayerStore,
} from '~/stores/project/layerStore'
import { projectStore, setProjectStore } from '~/stores/project/projectStore'
import { decodeImageData, encodeImageData } from '~/utils/ImageUtils'
import { getFileNameAndPath } from '~/utils/pathUtils'

export async function importProjectJsonFromFileSelection(): Promise<
  string | undefined
> {
  const home = await path.homeDir()
  const file = await dialogOpen({
    multiple: false,
    directory: false,
    defaultPath: await path.join(home, 'sledge'),
    filters: [
      {
        name: 'sledge files',
        extensions: ['sledge'],
      },
    ],
  })
  if (!file) {
    console.log('ファイルが選択されていません')
    return undefined
  }
  console.log(file)
  const jsonText = await readTextFile(file)
  const projectJson = JSON.parse(jsonText)

  await importProjectJson(projectJson)

  return file
}

export async function importProjectJsonFromPath(filePath: string) {
  if (!filePath) {
    console.log('ファイルが選択されていません')
    return
  }
  const jsonText = await readTextFile(filePath)
  const projectJson = JSON.parse(jsonText)

  importProjectJson(projectJson)
}

export async function importProjectJson(projectJson: any) {
  if (projectJson.project) {
    console.log(projectJson.project)
    setProjectStore('name', projectJson.project.name)
    setProjectStore('path', projectJson.project.path)
  }

  if (projectJson.canvas) {
    const { width, height } = projectJson.canvas
    setCanvasStore('canvas', 'width', width)
    setCanvasStore('canvas', 'height', height)
  }

  if (projectJson.images) {
    setLayerImageStore({})
    Object.keys(projectJson.images).forEach((id) => {
      console.log(`read ${id}`)
      const imageData = projectJson.images[id]
      console.log(imageData)
      initLayerImage(id, Number(imageData.dotMagnification || 1))
      setLayerImageStore(
        id,
        'current',
        decodeImageData(
          imageData.current,
          Number(imageData.width),
          Number(imageData.height)
        )
      )
    })
  }

  if (
    projectJson.layer &&
    projectJson.layer.layers &&
    Array.isArray(projectJson.layer.layers)
  ) {
    const layers: Layer[] = []
    projectJson.layer.layers.map((l: any) => {
      layers.push({
        ...l,
        dsl: undefined,
      } as Layer)
    })

    setLayerStore('layers', layers)
    setLayerStore('activeLayerId', projectJson.layer.activeLayerId)
  }

  adjustZoomToFit()
  centeringCanvas()
}

export const parseCurrentProject = (): string => {
  return JSON.stringify({
    project: projectStore,
    canvas: canvasStore.canvas,
    images: Object.fromEntries(
      Object.entries(layerImageStore).map(([id, state]) => [
        id,
        {
          current: encodeImageData(state.current),
          width: state.current.width,
          height: state.current.height,
          dotMagnification: findLayerById(id)?.dotMagnification,
        },
      ])
    ),
    layer: {
      layers: layerStore.layers.map((layer) => ({
        ...layer,
        dsl: undefined, // TODO: save dsl
      })),
      activeLayerId: layerStore.activeLayerId,
    },
  })
}

export async function saveProject(existingPath?: string) {
  let selectedPath: String | null
  if (existingPath) {
    selectedPath = existingPath
  } else {
    try {
      await mkdir('sledge', {
        baseDir: BaseDirectory.Home,
        recursive: true,
      })
    } catch (e) {
      console.warn('ディレクトリ作成スキップまたは失敗:', e)
    }

    const home = await path.homeDir()
    selectedPath = await save({
      title: 'Sledge プロジェクトを保存',
      defaultPath: await path.join(home, `sledge/${projectStore.name}.sledge`),
      filters: [{ name: 'Sledge Project', extensions: ['sledge'] }],
    })
  }

  if (typeof selectedPath === 'string') {
    setProjectStore('path', selectedPath)
    const data = parseCurrentProject()
    await writeTextFile(selectedPath, data)
    console.log('プロジェクト保存:', selectedPath)

    const fileLoc = getFileNameAndPath(selectedPath)
    if (fileLoc !== undefined) addRecent(fileLoc)
  } else {
    console.log('保存キャンセルされました')
  }
}
</file>

<file path="main.tsx">
import { render } from "solid-js/web";
import App from "./app";
import "./styles/global.css";
import "./styles/reset.css";

render(() => <App />, document.getElementById("root")!);
</file>

<file path="models/dsl/DSL.ts">
import { SledgeNode } from "~/models/dsl/nodes/DSLNodes";
import { findLayerById } from "~/stores/project/layerStore";
import { LayerIn } from "./nodes/pass/LayerIn";
import { LayerOut } from "./nodes/pass/LayerOut";

export class DSL {
  layerIn: LayerIn;
  readonly nodes: SledgeNode[];
  layerOut: LayerOut;

  constructor(inLayerId: string, outLayerId: string) {
    this.layerIn = new LayerIn(inLayerId);
    this.nodes = [];
    this.layerOut = new LayerOut(outLayerId);
  }

  public addNode(node: SledgeNode) {
    this?.nodes.push(node);
  }

  public build(exceptIn: boolean = false): string | undefined {
    const nodes = exceptIn
      ? [...this.nodes, this.layerOut]
      : [this.layerIn, ...this.nodes, this.layerOut];

    let nodeStrings: string[] = [];
    let isAllNodeParseSuccessful = true;
    nodes.forEach((node, i) => {
      const nodeStr = node.getNodeString();
      if (nodeStr !== undefined) nodeStrings.push(nodeStr);
      else {
        isAllNodeParseSuccessful = false;
        throw `DSL parse failed in: ${node.name} [${i}]`;
      }
    });

    if (isAllNodeParseSuccessful) {
      // if all nodes parsed successfully
      return nodeStrings.join(" > "); // in(inLayerId) > out(outLayerId) by default
    } else {
      // if some nodes failed to parse
      return undefined;
    }
  }

  public toString(): string {
    let str = this.build();
    if (str === undefined) throw "DSL parse failed.";
    else {
      // 読みやすくする
      const inId = this.layerIn.layerId;
      const outId = this.layerOut.layerId;
      if (inId !== undefined)
        str = str.replaceAll(inId, `${findLayerById(inId)?.name || "N/A"} ID`);
      if (outId !== undefined)
        str = str.replaceAll(
          outId,
          `${findLayerById(outId)?.name || "N/A"} ID`,
        );
      str = str.replaceAll(" > ", "\n> ");
      return str;
    }
  }
}
</file>

<file path="models/dsl/DSLRunner.ts">
import { decodeImageData, encodeImageData } from '~/utils/ImageUtils'
import { safeInvoke } from '~/utils/tauriUtils'
import { DSL } from './DSL'

export async function runDSL(
  dsl: DSL,
  image: ImageData
): Promise<ImageData | undefined> {
  const encoded = encodeImageData(image)

  const dslStr = dsl.build(true)
  if (dslStr === undefined) return

  const result = await safeInvoke<string>('run_pipeline', {
    dsl: dslStr,
    encoded,
    width: image.width,
    height: image.height,
  })

  if (!result) return
  return decodeImageData(result, image.width, image.height)
}
</file>

<file path="models/dsl/nodes/AvailableNodes.ts">
import { SledgeNode } from "./DSLNodes";
import { Brightness } from "./effect/Brightness";
import { GrayScale } from "./effect/GrayScale";
import { Invert } from "./effect/Invert";
import { Sepia } from "./effect/Sepia";
import { JpegGlitch } from "./fracture/JpegGlitch";

export const ALL_NODES: SledgeNode[] = [
  // effect
  new Brightness(),
  new GrayScale(),
  new Invert(),
  new Sepia(),
  // pass
  // new LayerIn(""),
  // new LayerOut(""),
  // fracture
  new JpegGlitch(),
];
</file>

<file path="models/dsl/nodes/DSLNodes.ts">
// 旧
// export enum ImageCommands {
//   INVERT = "invert",
//   GRAYSCALE = "grayscale",
//   GLITCH = "glitch",
//   SEPIA = "sepia",
//   BRIGHTNESS = "brightness",
// }
// export type ImageCommandParams =
//   | {
//       command:
//         | ImageCommands.INVERT
//         | ImageCommands.GRAYSCALE
//         | ImageCommands.SEPIA;
//     }
//   | { command: ImageCommands.BRIGHTNESS; delta: number };

export type NodeType = "effect" | "pass" | "fracture";

export interface NodeArg {
  name: string;
  default: number | string | undefined;
}

export abstract class SledgeNode {
  abstract name: string;
  abstract type: NodeType;
  abstract description: string;

  constructor() {}

  // error occured = undefined
  abstract getNodeString(): string | undefined;
}
</file>

<file path="models/dsl/nodes/effect/Brightness.ts">
import { EffectNode } from "./EffectNode";

export class Brightness extends EffectNode {
  name: string = "brightness";
  description: string = "brightness";

  constructor(private delta: number = 30) {
    super();
  }

  getNodeString(): string {
    return `${this.name}(${this.delta})`;
  }
}
</file>

<file path="models/dsl/nodes/effect/EffectNode.ts">
import { NodeType, SledgeNode } from "../DSLNodes";

export abstract class EffectNode extends SledgeNode {
  type: NodeType = "effect";
}
</file>

<file path="models/dsl/nodes/effect/GrayScale.ts">
import { EffectNode } from "./EffectNode";

export class GrayScale extends EffectNode {
  name: string = "grayscale";
  description: string = "grayscale";

  getNodeString(): string {
    return `${this.name}()`;
  }
}
</file>

<file path="models/dsl/nodes/effect/Invert.ts">
import { EffectNode } from "./EffectNode";

export class Invert extends EffectNode {
  name: string = "invert";
  description: string = "invert";

  getNodeString(): string {
    return `${this.name}()`;
  }
}
</file>

<file path="models/dsl/nodes/effect/Sepia.ts">
import { EffectNode } from "./EffectNode";

export class Sepia extends EffectNode {
  name: string = "sepia";
  description: string = "sepia";

  getNodeString(): string {
    return `${this.name}()`;
  }
}
</file>

<file path="models/dsl/nodes/fracture/FractureNode.ts">
import { NodeType, SledgeNode } from "../DSLNodes";

export abstract class FractureNode extends SledgeNode {
  type: NodeType = "fracture";
}
</file>

<file path="models/dsl/nodes/fracture/JpegGlitch.ts">
import { FractureNode } from "./FractureNode";

export class JpegGlitch extends FractureNode {
  name = "jpeg_glitch";
  description = "JPEG glitch effect using random byte corruption";

  private seed = Math.floor(Math.random() * 100);
  private quality = 90;
  private amount = 0.001; // 2%の破壊

  getNodeString(): string {
    return `${this.name}(${this.seed}, ${this.quality}, ${this.amount})`;
  }
}
</file>

<file path="models/dsl/nodes/pass/LayerIn.ts">
import { PassNode } from "./PassNode";

export class LayerIn extends PassNode {
  name: string = "in";
  description: string = "layer_in";

  constructor(public layerId?: string) {
    super();
  }

  getNodeString(): string | undefined {
    if (!this.layerId) return undefined;
    return `${this.name}(${this.layerId})`;
  }
}
</file>

<file path="models/dsl/nodes/pass/LayerOut.ts">
import { PassNode } from "./PassNode";

export class LayerOut extends PassNode {
  name: string = "out";
  description: string = "out";

  constructor(public layerId?: string) {
    super();
  }

  getNodeString(): string | undefined {
    if (!this.layerId) return undefined;
    return `${this.name}(${this.layerId})`;
  }
}
</file>

<file path="models/dsl/nodes/pass/PassNode.ts">
import { NodeType, SledgeNode } from "../DSLNodes";

export abstract class PassNode extends SledgeNode {
  type: NodeType = "pass";
}
</file>

<file path="models/factories/addLayer.ts">
import { allLayers, setLayerStore } from "~/stores/project/layerStore";
import { DSL } from "../dsl/DSL";
import { LayerType } from "../types/Layer";
import { createLayer } from "./createLayer";

export const addLayer = (
  name: string,
  type: LayerType = LayerType.Dot,
  enabled = true,
  dotMagnification = 1,
  dsl?: DSL,
) => {
  const newLayer = createLayer(name, type, enabled, dotMagnification, dsl);

  const layers = [...allLayers()];
  layers.push(newLayer);

  setLayerStore("layers", layers);

  return layers;
};
</file>

<file path="models/factories/canvasPreview.ts">
export function createPreviewCanvas(
  imageData: ImageData,
  targetHeight: number,
): HTMLCanvasElement {
  const aspectRatio = imageData.width / imageData.height;
  const targetWidth = Math.round(targetHeight * aspectRatio);

  const canvas = document.createElement("canvas");
  canvas.width = targetWidth;
  canvas.height = targetHeight;

  const ctx = canvas.getContext("2d")!;
  ctx.imageSmoothingEnabled = false;

  const tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = imageData.width;
  tmpCanvas.height = imageData.height;
  tmpCanvas.getContext("2d")!.putImageData(imageData, 0, 0);

  ctx.drawImage(
    tmpCanvas,
    0,
    0,
    imageData.width,
    imageData.height,
    0,
    0,
    targetWidth,
    targetHeight,
  );

  return canvas;
}
</file>

<file path="models/factories/createLayer.ts">
import { v4 as uuidv4 } from 'uuid'
import { showToast } from '~/stores/internal/toastStore'
import { layerStore } from '~/stores/project/layerStore'
import { DSL } from '../dsl/DSL'
import { initLayerImage } from '../layer/layerImage'
import { Layer, LayerType } from '../types/Layer'

export const createLayer = (
  name: string,
  type: LayerType,
  enabled = true,
  dotMagnification = 1,
  dsl?: DSL
): Layer => {
  // check if name already exists
  const endNums = name.match(/^(.*)(\d+)$/)
  if (endNums && endNums.length >= 3) {
    const nameWithoutNum = endNums[1]
    const endNum = Number(endNums[2])
    showToast(nameWithoutNum, 'info', 1000)
    showToast(endNum, 'info', 1000)

    const foundSameNameNums: number[] = []
    layerStore.layers.forEach((layer) => {
      const layerEndNums = layer.name.match(/^(.*)(\d+)$/)
      if (layerEndNums && layerEndNums.length >= 3) {
        const layerNameWithoutNum = layerEndNums[1]
        const layerEndNum = Number(layerEndNums[2])
        if (nameWithoutNum === layerNameWithoutNum) {
          foundSameNameNums.push(layerEndNum)
        }
      }
    })

    showToast(foundSameNameNums.join(','), 'info', 1000)

    let num = endNum
    while (foundSameNameNums.find((foundNum) => foundNum === num)) {
      num++
    }

    showToast(`num ok!! ${num}`, 'success', 1000)
    name = nameWithoutNum + num
  }

  const id = uuidv4()
  initLayerImage(id, dotMagnification)
  return {
    id,
    name,
    type,
    typeDescription: getTypeString(type),
    enabled,
    dotMagnification,
    dsl: dsl || new DSL(id, id),
  }
}

function getTypeString(type: LayerType): string {
  switch (type) {
    case LayerType.Dot:
      return 'dot layer.'
    case LayerType.Image:
      return 'image layer.'
    case LayerType.Automate:
      return 'automate layer.'
    default:
      return 'N/A.'
  }
}
</file>

<file path="models/factories/createPen.ts">
import { v4 as uuidv4 } from "uuid";
import { Tool, ToolType } from "../types/Tool";

export const createTool = (
  type: ToolType,
  name: string,
  size: number,
  color: string,
): Tool => ({
  id: uuidv4(),
  type,
  name,
  size,
  color,
});
</file>

<file path="models/factories/removeLayer.ts">
import {
  layerImageStore,
  setLayerImageStore,
} from '~/stores/project/layerImageStore'
import { allLayers, setLayerStore } from '~/stores/project/layerStore'

export const removeLayer = (layerId?: string) => {
  if (layerId === undefined) return
  const layers = [...allLayers()]
  const index = layers.findIndex((l) => l.id === layerId)
  let newActiveIndex = 0
  if (index !== 0) newActiveIndex = index - 1

  layers.splice(index, 1)
  const images = Object.assign({}, layerImageStore)
  delete images[layerId]

  setLayerStore('layers', layers)
  setLayerStore('activeLayerId', layers[newActiveIndex].id)
  setLayerImageStore(images)
}
</file>

<file path="models/factories/utils.ts">
const magnificationList: number[] = [1, 2, 4]
export const getNextMagnification = (dotMagnification: number) => {
  let index = magnificationList.findIndex((m) => m === dotMagnification)
  if (index != -1) {
    // 循環
    let nextIndex = index !== magnificationList.length - 1 ? index + 1 : 0
    return magnificationList[nextIndex]
  } else return 1
}
</file>

<file path="models/layer_canvas/DrawState.ts">
export enum DrawState {
  start,
  move,
  end,
}
</file>

<file path="models/layer_canvas/LayerCanvasOperator.ts">
import { LayerCanvasRef } from '~/components/canvas/stacks/LayerCanvas'
import { Vec2 } from '~/models/types/Vector'
import { currentTool } from '~/stores/internal/toolsStore'
import { hexToRGBA } from '~/utils/colorUtils'
import { Tool } from '../types/Tool'
import { setBottomInfo } from '~/components/BottomInfo'
import { DrawState } from './DrawState'
import { getToolInstance } from '../tools/ToolBase'
import LayerImageAgent from '../layer_image/LayerImageAgent'
import TileLayerImageAgent from '../layer_image/agents/TileLayerImageAgent'
import { setLayerImageStore } from '~/stores/project/layerImageStore'
import { reconcile } from 'solid-js/store'

export default class LayerCanvasOperator {
  constructor(private readonly getActiveLayerCanvas: () => LayerCanvasRef) {}

  public handleDraw(state: DrawState, position: Vec2, last?: Vec2) {
    const layerCanvasRef = this.getActiveLayerCanvas()
    const layer = layerCanvasRef.getLayer()
    const agent = layerCanvasRef.getAgent()
    const image = agent.getImage()
    if (!image) return

    position = this.getMagnificatedPosition(position, layer.dotMagnification)
    if (last) last = this.getMagnificatedPosition(last, layer.dotMagnification)

    const result = this.useTool(
      agent,
      state,
      image,
      currentTool(),
      position,
      last
    )

    if (result) {
      agent.setDrawingBuffer(result)
      if (state === DrawState.end) {
        agent.registerDiffAction()
        agent.setImage(result)
        setLayerImageStore(layer.id, 'current', reconcile(result))

        if (agent instanceof TileLayerImageAgent) {
          ;(agent as TileLayerImageAgent).resetAllDirtyStates()
        }
      }
    }
  }

  private useTool(
    agent: LayerImageAgent,
    state: DrawState,
    image: ImageData,
    tool: Tool,
    position: Vec2,
    last?: Vec2
  ) {
    const toolInstance = getToolInstance(tool.type)
    const toolArgs = {
      image,
      position,
      lastPosition: last,
      size: tool.size,
      color: hexToRGBA(tool.color),
    }
    const startTime = Date.now()
    let isDrawnAction
    switch (state) {
      case DrawState.start:
        isDrawnAction = toolInstance.onStart(agent, toolArgs)
        break
      case DrawState.move:
        isDrawnAction = toolInstance.onMove(agent, toolArgs)
        break
      case DrawState.end:
        isDrawnAction = toolInstance.onEnd(agent, toolArgs)
        break
    }
    const endTime = Date.now()
    if (isDrawnAction) {
      if (agent instanceof TileLayerImageAgent) {
        setBottomInfo(
          `${tool.type} finished. ${endTime - startTime} ms. (updated ${(agent as TileLayerImageAgent).getDirtyTiles().length} dirty tiles)`
        )
      } else {
        setBottomInfo(`${tool.type} finished. ${endTime - startTime} ms.`)
      }
    }
    return image
  }

  private getMagnificatedPosition(position: Vec2, dotMagnification: number) {
    return {
      x: Math.floor(position.x / dotMagnification),
      y: Math.floor(position.y / dotMagnification),
    }
  }
}
</file>

<file path="models/layer_image/agents/RawLayerImageAgent.ts">
import { Vec2 } from '~/models/types/Vector'
import LayerImageAgent from '../LayerImageAgent'
import { PixelDiff } from '../HistoryManager'
import { RGBAColor } from '~/utils/colorUtils'

export default class RawLayerImageAgent extends LayerImageAgent {
  putImageInto(ctx: CanvasRenderingContext2D) {
    ctx.putImageData(this.image, 0, 0)
  }

  putDrawingBufferInto(ctx: CanvasRenderingContext2D) {
    if (this.drawingBuffer) ctx.putImageData(this.drawingBuffer, 0, 0)
  }

  public setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.setPixelInPosition(
      position,
      color,
      excludePositionMatch,
      excludeColorMatch
    )
  }

  public deletePixel(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.deletePixelInPosition(
      position,
      excludePositionMatch,
      excludeColorMatch
    )
  }

  public getPixel(position: Vec2): RGBAColor {
    const i = (position.y * this.image.width + position.x) * 4
    const d = this.image.data
    return [d[i], d[i + 1], d[i + 2], d[i + 3]]
  }
}
</file>

<file path="models/layer_image/agents/TileLayerImageAgent.ts">
import { HistoryManager, TileDiff } from './../HistoryManager'
import { Vec2 } from '~/models/types/Vector'
import LayerImageAgent from '../LayerImageAgent'
import Tile, { TileIndex } from '../Tile'
import { PixelDiff } from '../HistoryManager'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'

export default class TileLayerImageAgent extends LayerImageAgent {
  readonly TILE_SIZE = 16

  private tiles: Tile[][] = []

  getTile(index: TileIndex) {
    // console.log(`tile access to ${index.row}. ${index.column}`)
    return this.tiles[index.row][index.column]
  }

  getTiles() {
    return this.tiles
  }

  constructor(imageData: ImageData, historyManager: HistoryManager) {
    super(imageData, historyManager)
  }

  initTile() {
    const tileRowCount = Math.ceil(this.getHeight() / this.TILE_SIZE)
    const tileColumnCount = Math.ceil(this.getWidth() / this.TILE_SIZE)
    for (let row = 0; row < tileRowCount; row++) {
      this.tiles[row] = []
      for (let column = 0; column < tileColumnCount; column++) {
        this.tiles[row][column] = new Tile(row, column, this.TILE_SIZE)
      }
    }
    this.scanAllTilesUniformity()
  }

  scanAllTilesUniformity() {
    const { TILE_SIZE } = this
    const w = this.getWidth()
    const h = this.getHeight()

    for (const row of this.tiles) {
      for (const tile of row) {
        const { x: ox, y: oy } = tile.getOffset()

        // ①タイルの左上ピクセルを基準色に
        const base = this.getPixel({ x: ox, y: oy })

        let uniform = true
        // ②タイル内を走査（画像端は超えないよう clamp）
        for (let dy = 0; dy < TILE_SIZE && uniform; dy++) {
          const py = oy + dy
          if (py >= h) break
          for (let dx = 0; dx < TILE_SIZE; dx++) {
            const px = ox + dx
            if (px >= w) break
            if (!colorMatch(this.getPixel({ x: px, y: py }), base)) {
              uniform = false
              break
            }
          }
        }
        // ③結果を保存
        tile.isUniform = uniform
        tile.uniformColor = uniform ? base : undefined
      }
    }
  }

  setImage(image: ImageData): void {
    super.setImage(image)
    this.initTile()
  }

  putImageInto(ctx: CanvasRenderingContext2D) {
    if (this.getDirtyTiles().length > 0) {
      this.putOnlyForDirtyTiles(ctx, this.image)
    }
  }

  putDrawingBufferInto(ctx: CanvasRenderingContext2D) {
    if (this.getDirtyTiles().length > 0) {
      if (this.drawingBuffer) this.putOnlyForDirtyTiles(ctx, this.drawingBuffer)
    }
  }

  private putOnlyForDirtyTiles(
    ctx: CanvasRenderingContext2D,
    image: ImageData
  ) {
    const dirtyTiles = this.getDirtyTiles()

    dirtyTiles.forEach((dirtyTile) => {
      const offset = dirtyTile.getOffset()
      ctx.putImageData(
        image,
        0,
        0,
        offset.x,
        offset.y,
        this.TILE_SIZE,
        this.TILE_SIZE
      )
    })

    this.resetDirtyStates()
  }

  public getTileIndex(layerPosition: Vec2): TileIndex {
    const row = Math.floor(layerPosition.y / this.TILE_SIZE)
    const column = Math.floor(layerPosition.x / this.TILE_SIZE)
    return { row, column }
  }

  public resetDirtyStates() {
    this.tiles = this.tiles.map((tR) => {
      tR = tR.map((t) => {
        t.isDirty = false
        return t
      })
      return tR
    })
  }

  public resetAllDirtyStates() {
    this.tiles = this.tiles.map((tR) => {
      tR = tR.map((t) => {
        t.isDirty = false
        t.isDirtyThroughAction = false
        return t
      })
      return tR
    })
  }

  public getDirtyTiles(): Tile[] {
    return this.tiles.flatMap((tR) => tR.filter((t) => t.isDirty))
  }
  public getDirtyTilesInAction(): Tile[] {
    return this.tiles.flatMap((tR) => tR.filter((t) => t.isDirtyThroughAction))
  }

  protected undoTileDiff(tileDiff: TileDiff): void {
    console.log(`tilediff. fill ${tileDiff.beforeColor}`)
    if (tileDiff.beforeColor)
      this.fillWholeTile(tileDiff.index, tileDiff.beforeColor, false)
  }

  protected redoTileDiff(tileDiff: TileDiff): void {
    console.log(`tilediff. fill ${tileDiff.afterColor}`)
    this.fillWholeTile(tileDiff.index, tileDiff.afterColor, false)
  }

  public setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    const result = this.setPixelInPosition(
      position,
      color,
      excludePositionMatch,
      excludeColorMatch
    )
    if (result !== undefined) {
      const tileIndex = this.getTileIndex(position)
      this.tiles[tileIndex.row][tileIndex.column].isDirty = true
      this.tiles[tileIndex.row][tileIndex.column].isDirtyThroughAction = true

      const tile = this.getTile(tileIndex)
      if (
        tile.isUniform &&
        tile.uniformColor !== undefined &&
        colorMatch(tile.uniformColor, color)
      ) {
        this.tiles[tileIndex.row][tileIndex.column].isUniform = false
        this.tiles[tileIndex.row][tileIndex.column].uniformColor = undefined
      }
    }
    return result
  }

  fillWholeTile(index: TileIndex, color: RGBAColor, collectDiff = true) {
    const tile = this.getTile(index)
    if (
      tile.isUniform &&
      tile.uniformColor &&
      colorMatch(tile.uniformColor, color)
    )
      return

    const [r, g, b, a] = color
    const { x: ox, y: oy } = tile.getOffset()
    const { TILE_SIZE } = this
    const { width, data } = this.image

    for (let dy = 0; dy < TILE_SIZE; dy++) {
      const y = oy + dy
      if (y >= this.getHeight()) break
      let i = (y * width + ox) * 4 // 行頭インデックス
      for (let dx = 0; dx < TILE_SIZE; dx++) {
        const x = ox + dx
        if (x >= this.getWidth()) break

        data[i] = r
        data[i + 1] = g
        data[i + 2] = b
        data[i + 3] = a
        i += 4
      }
    }

    if (collectDiff)
      this.addDiffs([
        {
          kind: 'tile',
          index,
          beforeColor: tile.uniformColor,
          afterColor: [r, g, b, a],
        },
      ])

    // 状態更新
    tile.isDirty = tile.isDirty = true
    tile.isDirty = tile.isDirtyThroughAction = true
    tile.isUniform = true
    tile.uniformColor = color
  }

  public deletePixel(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    const result = this.deletePixelInPosition(
      position,
      excludePositionMatch,
      excludeColorMatch
    )
    if (result !== undefined) {
      const tileIndex = this.getTileIndex(position)
      this.tiles[tileIndex.row][tileIndex.column].isDirty = true
      this.tiles[tileIndex.row][tileIndex.column].isDirtyThroughAction = true
    }
    return result
  }

  public getPixel(position: Vec2): RGBAColor {
    const i = (position.y * this.image.width + position.x) * 4
    const d = this.image.data

    return [d[i], d[i + 1], d[i + 2], d[i + 3]]
  }

  public getTileRowCount() {
    return this.tiles.length
  }

  public getTileColumnCount() {
    return this.tiles[0].length
  }

  public isTileInBounds(index: TileIndex) {
    return (
      index.row >= 0 &&
      index.row < this.getTileRowCount() &&
      index.column >= 0 &&
      index.column < this.getTileColumnCount()
    )
  }
}
</file>

<file path="models/layer_image/HistoryManager.ts">
import {
  layerImageStore,
  setLayerImageStore,
} from '~/stores/project/layerImageStore'
import { Vec2 } from '../types/Vector'
import { reconcile } from 'solid-js/store'
import { RGBAColor } from '~/utils/colorUtils'
import { TileIndex } from './Tile'

export type PixelDiff = {
  kind: 'pixel'
  position: Vec2
  before: RGBAColor
  after: RGBAColor
}

export type TileDiff = {
  kind: 'tile'
  index: TileIndex
  beforeColor: RGBAColor | undefined
  afterColor: RGBAColor
}

export type Diff = PixelDiff | TileDiff

export const getDiffHash = (diff: Diff) => {
  switch (diff.kind) {
    case 'pixel':
      return `px:${diff.position.x},${diff.position.y}`
    case 'tile':
      return `tile:${diff.index.row},${diff.index.column}`
  }
}

export type DiffAction = {
  diffs: Map<string, Diff>
}

export class HistoryManager {
  protected undoActionsStack: DiffAction[]
  protected redoActionsStack: DiffAction[]

  constructor(public layerId: string) {
    this.undoActionsStack = []
    this.redoActionsStack = []
  }

  public getUndoStack() {
    return this.undoActionsStack
  }

  public getRedoStack() {
    return this.undoActionsStack
  }

  public canUndo() {
    return this.undoActionsStack.length > 0
  }

  public canRedo() {
    return this.redoActionsStack.length > 0
  }

  public addAction(action: DiffAction) {
    this.undoActionsStack.push(action)
    this.redoActionsStack = []
    setLayerImageStore(
      this.layerId,
      'undoStack',
      reconcile(this.undoActionsStack)
    )
    setLayerImageStore(
      this.layerId,
      'redoStack',
      reconcile(this.redoActionsStack)
    )
  }

  public undo(): DiffAction | undefined {
    const undoedAction = this.undoActionsStack.pop()
    if (undoedAction === undefined) return undefined
    this.redoActionsStack = [undoedAction, ...this.redoActionsStack]
    setLayerImageStore(
      this.layerId,
      'undoStack',
      reconcile(this.undoActionsStack)
    )
    setLayerImageStore(
      this.layerId,
      'redoStack',
      reconcile(this.redoActionsStack)
    )
    return undoedAction
  }

  public redo(): DiffAction | undefined {
    const redoedAction = this.redoActionsStack.shift()
    if (redoedAction === undefined) return undefined
    this.undoActionsStack = [...this.undoActionsStack, redoedAction]
    setLayerImageStore(
      this.layerId,
      'undoStack',
      reconcile(this.undoActionsStack)
    )
    setLayerImageStore(
      this.layerId,
      'redoStack',
      reconcile(this.redoActionsStack)
    )
    return redoedAction
  }
}
</file>

<file path="models/layer_image/LayerImageAgent.ts">
import { Vec2 } from '~/models/types/Vector'
import {
  Diff,
  DiffAction,
  getDiffHash,
  HistoryManager,
  PixelDiff,
  TileDiff,
} from './HistoryManager'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'
import { setBottomInfo } from '~/components/BottomInfo'

interface DrawingBufferChangeEvent {}
interface ImageChangeEvent {}

// それぞれのLayerCanvasの描画、表示までの処理過程を記述するクラス
export default abstract class LayerImageAgent {
  protected image: ImageData
  protected drawingBuffer: ImageData | undefined
  protected historyManager

  protected onImageChangedListeners: {
    [key: string]: (e: ImageChangeEvent) => void
  } = {}
  protected onDrawingBufferChangedListeners: {
    [key: string]: (e: DrawingBufferChangeEvent) => void
  } = {}

  constructor(imageData: ImageData, historyManager?: HistoryManager) {
    this.image = imageData
    this.drawingBuffer = imageData
    this.historyManager = historyManager
  }

  getHistoryManager() {
    return this.historyManager
  }

  getImage() {
    return this.image
  }

  setImage(image: ImageData, silentlySet?: boolean) {
    this.image = image
    if (silentlySet) this.callOnImageChangeListeners()
    this.resetDrawingBuffer()
  }

  getDrawingBuffer() {
    return this.drawingBuffer
  }

  setDrawingBuffer(imageData?: ImageData) {
    this.drawingBuffer = imageData
    this.callOnDrawingBufferChangeListeners()
  }

  resetDrawingBuffer() {
    this.setDrawingBuffer(this.image)
  }

  abstract putImageInto(ctx: CanvasRenderingContext2D): void
  abstract putDrawingBufferInto(ctx: CanvasRenderingContext2D): void

  putImageIntoForce(ctx: CanvasRenderingContext2D) {
    ctx.putImageData(this.image, 0, 0)
  }
  putDrawingBufferIntoForce(ctx: CanvasRenderingContext2D) {
    if (this.drawingBuffer) ctx.putImageData(this.drawingBuffer, 0, 0)
  }

  setOnImageChangeListener(
    key: string,
    listener: (e: ImageChangeEvent) => void
  ) {
    this.onImageChangedListeners[key] = listener
  }

  setOnDrawingBufferChangeListener(
    key: string,
    listener: (e: DrawingBufferChangeEvent) => void
  ) {
    this.onDrawingBufferChangedListeners[key] = listener
  }

  callOnImageChangeListeners() {
    Object.values(this.onImageChangedListeners).forEach((listener) =>
      listener({})
    )
  }

  callOnDrawingBufferChangeListeners() {
    Object.values(this.onDrawingBufferChangedListeners).forEach((listener) =>
      listener({})
    )
  }

  getWidth = (): number => this.image.width
  getHeight = (): number => this.image.height

  public currentDiffAction: DiffAction = { diffs: new Map() }

  addDiffs(diffs: Diff[]) {
    diffs.forEach((d) => this.currentDiffAction.diffs.set(getDiffHash(d), d))
  }

  public registerDiffAction() {
    this.historyManager?.addAction(this.currentDiffAction)
    this.currentDiffAction = { diffs: new Map() }
  }

  public canUndo = () => this.historyManager?.canUndo()
  public canRedo = () => this.historyManager?.canRedo()

  public undo() {
    const undoStart = Date.now()
    const undoedAction = this.historyManager?.undo()
    if (undoedAction === undefined) return
    setBottomInfo(`undo.`)
    undoedAction.diffs.forEach((diff) => {
      switch (diff.kind) {
        case 'pixel':
          this.setPixelInPosition(diff.position, diff.before, false, false)
          break
        case 'tile':
          this.undoTileDiff(diff)
          break
      }
    })
    const undoEnd = Date.now()
    setBottomInfo(
      `undo done. (${undoedAction.diffs.size} px updated, ${undoEnd - undoStart}ms)`
    )

    this.callOnImageChangeListeners()
  }

  protected undoTileDiff(tileDiff: TileDiff) {}

  public redo() {
    const redoStart = Date.now()
    const redoedAction = this.historyManager?.redo()
    if (redoedAction === undefined) return
    setBottomInfo(`redo.`)
    redoedAction.diffs.forEach((diff) => {
      switch (diff.kind) {
        case 'pixel':
          this.setPixelInPosition(diff.position, diff.after, false, false)
          break
        case 'tile':
          this.redoTileDiff(diff)
          break
      }
    })
    const redoEnd = Date.now()
    setBottomInfo(
      `redo done. (${redoedAction.diffs.size} px updated, ${redoEnd - redoStart}ms)`
    )

    this.callOnImageChangeListeners()
  }

  protected redoTileDiff(tileDiff: TileDiff) {}

  public abstract setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean,
    excludeColorMatch: boolean
  ): PixelDiff | undefined

  protected setPixelInPosition(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    if (!this.isInBounds(position)) return undefined
    if (
      excludePositionMatch &&
      this.currentDiffAction.diffs.has(`${position.x},${position.y}`)
    )
      return undefined
    const i = (position.y * this.getWidth() + position.x) * 4
    const beforeColor: RGBAColor = [
      this.image.data[i + 0],
      this.image.data[i + 1],
      this.image.data[i + 2],
      this.image.data[i + 3],
    ]
    if (excludeColorMatch && colorMatch(beforeColor, color)) return undefined

    if (!this.drawingBuffer) return

    this.drawingBuffer.data[i + 0] = color[0]
    this.drawingBuffer.data[i + 1] = color[1]
    this.drawingBuffer.data[i + 2] = color[2]
    this.drawingBuffer.data[i + 3] = color[3]

    return {
      kind: 'pixel',
      position,
      before: beforeColor,
      after: color,
    }
  }

  public abstract deletePixel(
    position: Vec2,
    excludePositionMatch: boolean,
    excludeColorMatch: boolean
  ): PixelDiff | undefined

  protected deletePixelInPosition(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.setPixelInPosition(
      position,
      [0, 0, 0, 0],
      excludePositionMatch,
      excludeColorMatch
    )
  }

  public abstract getPixel(position: Vec2): RGBAColor

  public isInBounds(position: Vec2) {
    return (
      position.x >= 0 &&
      position.y >= 0 &&
      position.x < this.getWidth() &&
      position.y < this.getHeight()
    )
  }
}
</file>

<file path="models/layer_image/LayerImageManager.ts">
import { HistoryManager } from './HistoryManager'
import LayerImageAgent from './LayerImageAgent'
import TileLayerImageAgent from './agents/TileLayerImageAgent'

export class LayerImageManager {
  private agents: Map<string, LayerImageAgent> = new Map()

  public getAgent(layerId: string): LayerImageAgent | undefined {
    return this.agents.get(layerId)
  }

  public registerAgent(layerId: string, image: ImageData): LayerImageAgent {
    const agent = new TileLayerImageAgent(image, new HistoryManager(layerId))
    this.agents.set(layerId, agent)
    return agent
  }
}
</file>

<file path="models/layer_image/Tile.ts">
import { RGBAColor } from '~/utils/colorUtils'
import { Vec2 } from '../types/Vector'

export interface TileIndex {
  row: number
  column: number
}

export default class Tile {
  // 一連の動作全体で変更があったか（累計表示、UI表示用）
  public isDirtyThroughAction: boolean
  // 前回の描画更新から変更があったか（canvas更新用）
  public isDirty: boolean

  // このタイルが単色（すべて同一RGBA）なら true
  public isUniform = false
  // 単色時のカラーキャッシュ
  public uniformColor: RGBAColor | undefined = undefined

  constructor(
    public readonly row: number,
    public readonly column: number,
    public readonly globalTileSize: number
  ) {
    this.isDirtyThroughAction = false
    this.isDirty = false
  }

  toString(): string {
    return `Tile[${this.row},${this.column}]`
  }

  public getOffset(): Vec2 {
    return {
      x: this.column * this.globalTileSize,
      y: this.row * this.globalTileSize,
    }
  }

  public isInBounds(positionInTile: Vec2) {
    return (
      positionInTile.x >= 0 &&
      positionInTile.x < this.globalTileSize &&
      positionInTile.y >= 0 &&
      positionInTile.y < this.globalTileSize
    )
  }

  updateState() {}
}
</file>

<file path="models/layer/layerImage.ts">
import { canvasStore } from '~/stores/project/canvasStore'
import { setLayerImageStore } from '~/stores/project/layerImageStore'

export function initLayerImage(layerId: string, dotMagnification: number) {
  const blank = new ImageData(
    Math.round(canvasStore.canvas.width / dotMagnification),
    Math.round(canvasStore.canvas.height / dotMagnification)
  )
  setLayerImageStore(layerId, {
    current: blank,
    undoStack: [],
    redoStack: [],
  })
}
</file>

<file path="models/tools/DrawUtils.ts">
import { Vec2 } from '../types/Vector'

export function drawSquarePixel(
  p: Vec2,
  size: number,
  drawFn: (x: number, y: number) => void
) {
  const half = Math.floor(size / 2)
  for (let dy = -half; dy <= half; dy++) {
    for (let dx = -half; dx <= half; dx++) {
      drawFn(p.x + dx, p.y + dy)
    }
  }
}

export function drawCompletionLine(
  p0: Vec2,
  p1: Vec2,
  draw: (x: number, y: number) => void
) {
  const dx = Math.abs(p1.x - p0.x)
  const dy = Math.abs(p1.y - p0.y)
  const sx = p0.x < p1.x ? 1 : -1
  const sy = p0.y < p1.y ? 1 : -1
  let err = dx - dy

  while (true) {
    draw(p0.x, p0.y)
    if (p0.x === p1.x && p0.y === p1.y) break
    const e2 = 2 * err
    if (e2 > -dy) {
      err -= dy
      p0.x += sx
    }
    if (e2 < dx) {
      err += dx
      p0.y += sy
    }
  }
}
</file>

<file path="models/tools/eraser/EraserTool.ts">
import { Tool, ToolArgs } from '../ToolBase'
import { drawCompletionLine, drawSquarePixel } from '../DrawUtils'
import LayerImageAgent from '~/models/layer_image/LayerImageAgent'

export class EraserTool implements Tool {
  onStart(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }

  onMove(agent: LayerImageAgent, { position, lastPosition, size }: ToolArgs) {
    if (!size) return false

    drawSquarePixel(position, size, (px, py) => {
      const diff = agent.deletePixel({ x: px, y: py }, true, true)
      if (diff !== undefined) {
        agent.addDiffs([diff])
      }
    })

    if (lastPosition !== undefined) {
      drawCompletionLine(position, lastPosition, (x, y) => {
        drawSquarePixel({ x, y }, size, (px, py) => {
          const diff = agent.deletePixel({ x: px, y: py }, true, true)
          if (diff !== undefined) {
            agent.addDiffs([diff])
          }
        })
      })
    }

    return true
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }
}
</file>

<file path="models/tools/fill/FillTool.ts">
import { Tool, ToolArgs } from '../ToolBase'
import LayerImageAgent from '~/models/layer_image/LayerImageAgent'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'
import { Vec2 } from '~/models/types/Vector'
import { TileFloodFill } from './TileFloodFill'

export interface FillProps {
  agent: LayerImageAgent
  color: RGBAColor
  position: Vec2
}
export interface Fill {
  fill: (props: FillProps) => void
}

export class FillTool implements Tool {
  onStart(agent: LayerImageAgent, { position, lastPosition, color }: ToolArgs) {
    const fill = new TileFloodFill()

    fill.fill({ agent, color, position })

    return true
  }

  onMove(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }
}
</file>

<file path="models/tools/fill/LegacyFills.ts">
import { safeInvoke } from '~/utils/tauriUtils'
import { ToolArgs } from '../ToolBase'
import { colorMatch, getPixel, isInBounds } from './FillTool'
import { decodeImageData, encodeImageData, setPixel } from '~/utils/ImageUtils'

function legacyFloodFillJS({ image, position, lastPosition, color }: ToolArgs) {
  const targetColor = getPixel(image, position.x, position.y)
  const matches = (p: [number, number]) =>
    colorMatch(getPixel(image, p[0], p[1]), targetColor)

  const startTimeLegacy = Date.now()
  const queueLegacy: [number, number][] = [[position.x, position.y]]
  const filledLegacy: [number, number][] = []
  const visitedLegacy = new Set<string>()

  while (queueLegacy.length > 0) {
    const [cx, cy] = queueLegacy.pop()!
    const key = `${cx},${cy}`
    if (visitedLegacy.has(key) || !isInBounds(image, cx, cy)) continue
    visitedLegacy.add(key)
    if (matches([cx, cy])) {
      filledLegacy.push([cx, cy])
      queueLegacy.push([cx + 1, cy])
      queueLegacy.push([cx - 1, cy])
      queueLegacy.push([cx, cy + 1])
      queueLegacy.push([cx, cy - 1])
    }
  }
  const endTimeLegacy = Date.now()
  console.log('legacy: ' + (endTimeLegacy - startTimeLegacy))

  // バッファに一括反映
  for (const [px, py] of filledLegacy) {
    setPixel(image, px, py, color[0], color[1], color[2], color[3])
  }
}

function legacyBase64Rust({ image, position, lastPosition, color }: ToolArgs) {
  const targetColor = getPixel(image, position.x, position.y)
  const matches = (p: [number, number]) =>
    colorMatch(getPixel(image, p[0], p[1]), targetColor)
  ;(async () => {
    const startTime = Date.now()
    const result = await safeInvoke('flood_fill', {
      encoded: encodeImageData(image),
      width: image.width,
      height: image.height,
      x: position.x,
      y: position.y,
      newColor: color,
    })

    // 結果を ImageData に復元
    const resultImage = decodeImageData(
      result as string,
      image.width,
      image.height
    )
    // image = resultImage
    const endTime = Date.now()
    console.log('rust(old, base64): ' + (endTime - startTime))
  })()
}

function legacyByteBufRust({ image, position, lastPosition, color }: ToolArgs) {
  const targetColor = getPixel(image, position.x, position.y)
  const matches = (p: [number, number]) =>
    colorMatch(getPixel(image, p[0], p[1]), targetColor)
  ;(async () => {
    const startTime = Date.now()
    const result = await safeInvoke('flood_fill_raw', {
      image: Array.from(image.data),
      width: image.width,
      height: image.height,
      x: position.x,
      y: position.y,
      newColor: color,
    })

    // 結果（Uint8Array）を ImageData に復元
    const resultImage = new ImageData(
      new Uint8ClampedArray(result as number[]),
      image.width,
      image.height
    )
    // image = resultImage
    const endTime = Date.now()
    console.log('rust(raw, ByteBuf): ' + (endTime - startTime))
  })()
}
</file>

<file path="models/tools/fill/PixelFloodFill.ts">
import { PixelDiff } from '~/models/layer_image/HistoryManager'
import { Vec2 } from '~/models/types/Vector'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'
import { Fill, FillProps } from './FillTool'

export class PixelFloodFill implements Fill {
  fill({ agent, color, position }: FillProps) {
    const targetColor = agent.getPixel(position)
    const matches = (p: Vec2) => colorMatch(agent.getPixel(p), targetColor)

    console.log(color)
    console.log(targetColor)

    if (colorMatch(targetColor, color)) return false

    // console.log(`---${image.width}x${image.height} flood fill---`)

    if (colorMatch(targetColor, color)) return false
    console.log('fill started.')

    const scanStart = Date.now()
    const queue: Vec2[] = [position]
    const filled: Vec2[] = []
    const visited = new Uint8Array(agent.getWidth() * agent.getHeight()) // 0:未訪問, 1:訪問済
    const index = (p: Vec2) => p.y * agent.getWidth() + p.x
    let queueCount = 0
    let visitCount = 0
    while (queue.length > 0) {
      queueCount++
      const c = queue.pop()!
      if (!agent.isInBounds(c)) continue

      const i = index(c)
      if (visited[i]) continue
      visited[i] = 1
      visitCount++

      if (matches(c)) {
        filled.push(c)
        queue.push({ x: c.x + 1, y: c.y })
        queue.push({ x: c.x - 1, y: c.y })
        queue.push({ x: c.x, y: c.y + 1 })
        queue.push({ x: c.x, y: c.y - 1 })
      }
    }

    const scanEnd = Date.now()
    console.log('scan finished. ' + (scanEnd - scanStart) + 'ms.')

    const writeStart = Date.now()

    const pxDiffs: PixelDiff[] = []
    // バッファに一括反映
    for (const p of filled) {
      const diff = agent.setPixel(p, color, false, false)
      if (diff !== undefined) pxDiffs.push(diff)
    }
    const writeEnd = Date.now()
    console.log('write finished. ' + (writeEnd - writeStart) + 'ms.')

    agent.addDiffs(pxDiffs)
  }
}
</file>

<file path="models/tools/fill/TileFloodFill.ts">
import { PixelDiff } from '~/models/layer_image/HistoryManager'
import { Vec2 } from '~/models/types/Vector'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'
import { Fill, FillProps } from './FillTool'
import TileLayerImageAgent from '~/models/layer_image/agents/TileLayerImageAgent'
import Tile, { TileIndex } from '~/models/layer_image/Tile'

interface FillPassProps {
  index: TileIndex
}

export class TileFloodFill implements Fill {
  fill({ agent, color, position }: FillProps) {
    if (!(agent instanceof TileLayerImageAgent))
      throw 'Agent is not a TileLayerImageAgent'
    const tileAgent = agent as TileLayerImageAgent

    const targetColor = tileAgent.getPixel(position)
    if (colorMatch(targetColor, color)) return false

    const tileRowCount = tileAgent.getTileRowCount()
    const tileColumnCount = tileAgent.getTileColumnCount()
    const flatten = (ti: TileIndex) => ti.row * tileColumnCount + ti.column
    const tileUniformMatches = (ti: TileIndex) => {
      const tile = tileAgent.getTile(ti)
      return (
        tile.isUniform &&
        tile.uniformColor &&
        colorMatch(tile.uniformColor, targetColor)
      )
    }

    const visitedTiles = new Uint8Array(tileRowCount * tileColumnCount)
    const tilesFilled: TileIndex[] = []
    const tileQueue: TileIndex[] = [tileAgent.getTileIndex(position)]

    const pxDiffs: PixelDiff[] = []
    const visitedPx = new Uint8Array(agent.getWidth() * agent.getHeight())

    // First tile flood pass
    let tileFillCount = 0
    while (tileQueue.length > 0) {
      const ti = tileQueue.pop()!
      if (!tileAgent.isTileInBounds(ti)) continue
      const i = flatten(ti)
      if (visitedTiles[i]) continue
      visitedTiles[i] = 1
      if (!tileUniformMatches(ti)) continue

      tilesFilled.push(ti)
      tileFillCount++
      tileQueue.push({ row: ti.row - 1, column: ti.column })
      tileQueue.push({ row: ti.row + 1, column: ti.column })
      tileQueue.push({ row: ti.row, column: ti.column - 1 })
      tileQueue.push({ row: ti.row, column: ti.column + 1 })
    }
    for (const ti of tilesFilled) {
      const offset = tileAgent.getTile(ti).getOffset()
      for (let dy = 0; dy < tileAgent.TILE_SIZE; dy++) {
        for (let dx = 0; dx < tileAgent.TILE_SIZE; dx++) {
          const x = offset.x + dx
          const y = offset.y + dy
          const i = y * agent.getWidth() + x
          visitedPx[i] = 1
        }
      }
    }
    console.log(`initial tile fill finished: ${tileFillCount} tiles`)

    const edgePixels =
      tilesFilled.length > 0 ?
        this.collectEdgePixels(tileAgent, tilesFilled)
      : [position]

    const pixelQueue: Vec2[] = edgePixels
    const pixelsFilled: Vec2[] = []
    const pxIndex = (p: Vec2) => p.y * agent.getWidth() + p.x

    let pixelFillCount = 0
    while (pixelQueue.length > 0) {
      const p = pixelQueue.pop()!
      if (!agent.isInBounds(p)) continue
      const idx = pxIndex(p)
      if (visitedPx[idx]) continue
      visitedPx[idx] = 1

      const tileIndex = tileAgent.getTileIndex(p)
      const tileIdxFlat = flatten(tileIndex)
      const tilesFilledInReEntry: TileIndex[] = []
      if (!visitedTiles[tileIdxFlat] && tileUniformMatches(tileIndex)) {
        const reentryQueue: TileIndex[] = [tileIndex]
        let reentryCount = 0
        while (reentryQueue.length > 0) {
          const ti = reentryQueue.pop()!
          if (!tileAgent.isTileInBounds(ti)) continue
          const i = flatten(ti)
          if (visitedTiles[i]) continue
          visitedTiles[i] = 1
          if (!tileUniformMatches(ti)) continue
          tilesFilled.push(ti)
          tilesFilledInReEntry.push(ti)
          reentryCount++
          reentryQueue.push({ row: ti.row - 1, column: ti.column })
          reentryQueue.push({ row: ti.row + 1, column: ti.column })
          reentryQueue.push({ row: ti.row, column: ti.column - 1 })
          reentryQueue.push({ row: ti.row, column: ti.column + 1 })
        }
        // ↓ 前はこれがなかった ↓
        const newEdges = this.collectEdgePixels(tileAgent, tilesFilledInReEntry)
        for (const edge of newEdges) {
          pixelQueue.push(edge)
        }
        for (const ti of tilesFilled) {
          const offset = tileAgent.getTile(ti).getOffset()
          for (let dy = 0; dy < tileAgent.TILE_SIZE; dy++) {
            for (let dx = 0; dx < tileAgent.TILE_SIZE; dx++) {
              const x = offset.x + dx
              const y = offset.y + dy
              const i = y * agent.getWidth() + x
              visitedPx[i] = 1
            }
          }
        }
        console.log(`tile reentry fill: ${reentryCount} tiles`)
        continue
      }

      if (!colorMatch(tileAgent.getPixel(p), targetColor)) continue
      pixelsFilled.push(p)
      pixelFillCount++
      pixelQueue.push({ x: p.x + 1, y: p.y })
      pixelQueue.push({ x: p.x - 1, y: p.y })
      pixelQueue.push({ x: p.x, y: p.y + 1 })
      pixelQueue.push({ x: p.x, y: p.y - 1 })
    }
    console.log(`pixel fill finished: ${pixelFillCount} pixels`)

    for (const ti of tilesFilled) tileAgent.fillWholeTile(ti, color, true)
    for (const p of pixelsFilled) {
      const diff = tileAgent.setPixel(p, color, false, false)
      if (diff) pxDiffs.push(diff)
    }

    if (pxDiffs.length > 0) tileAgent.addDiffs(pxDiffs)
  }

  collectEdgePixels(agent: TileLayerImageAgent, filled: TileIndex[]): Vec2[] {
    const edge: Vec2[] = []
    const TILE_SIZE = agent.TILE_SIZE
    const filledSet = new Set(filled.map((t) => `${t.row},${t.column}`))

    for (const ti of filled) {
      const offset = agent.getTile(ti).getOffset()
      const neighbors = [
        { dr: -1, dc: 0, dx: 0, dy: -1, axis: 'x' },
        { dr: 1, dc: 0, dx: 0, dy: TILE_SIZE, axis: 'x' },
        { dr: 0, dc: -1, dx: -1, dy: 0, axis: 'y' },
        { dr: 0, dc: 1, dx: TILE_SIZE, dy: 0, axis: 'y' },
      ]

      for (const { dr, dc, dx, dy, axis } of neighbors) {
        const ni = `${ti.row + dr},${ti.column + dc}`
        if (filledSet.has(ni)) continue
        for (let i = 0; i < TILE_SIZE; i++) {
          const x = axis === 'x' ? offset.x + i : offset.x + dx
          const y = axis === 'y' ? offset.y + i : offset.y + dy
          edge.push({ x, y })
        }
      }
    }
    return edge
  }
}
</file>

<file path="models/tools/pen/PenTool.ts">
import { Tool, ToolArgs } from '../ToolBase'
import { drawCompletionLine, drawSquarePixel } from '../DrawUtils'
import LayerImageAgent from '~/models/layer_image/LayerImageAgent'
import { PixelDiff } from '~/models/layer_image/HistoryManager'
import { Vec2 } from '~/models/types/Vector'

export class PenTool implements Tool {
  onStart(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }

  onMove(
    agent: LayerImageAgent,
    { position, lastPosition, color, size }: ToolArgs
  ) {
    if (!size) return false

    drawSquarePixel(position, size, (px, py) => {
      const diff = agent.setPixel({ x: px, y: py }, color, true, true)
      if (diff !== undefined) {
        agent.addDiffs([diff])
      }
    })

    if (lastPosition !== undefined) {
      drawCompletionLine(position, lastPosition, (x, y) => {
        drawSquarePixel({ x, y }, size, (px, py) => {
          const diff = agent.setPixel({ x: px, y: py }, color, true, true)
          if (diff !== undefined) {
            agent.addDiffs([diff])
          }
        })
      })
    }

    return true
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }
}
</file>

<file path="models/tools/ToolBase.ts">
import { RGBAColor } from '~/utils/colorUtils'
import LayerImageAgent from '../layer_image/LayerImageAgent'
import { ToolType } from '../types/Tool'
import { Vec2 } from '../types/Vector'
import { EraserTool } from './eraser/EraserTool'
import { FillTool } from './fill/FillTool'
import { PenTool } from './pen/PenTool'

export interface Tool {
  onStart: (agent: LayerImageAgent, args: ToolArgs) => boolean

  onMove: (agent: LayerImageAgent, args: ToolArgs) => boolean

  onEnd: (agent: LayerImageAgent, args: ToolArgs) => boolean
}

export interface ToolArgs {
  position: Vec2
  lastPosition?: Vec2
  color: RGBAColor // RGBA
  size?: number
  // TODO: pressure, tilt, ...
}

export const getToolInstance = (toolType: ToolType) => {
  switch (toolType) {
    case ToolType.Pen:
      return new PenTool()
    case ToolType.Eraser:
      return new EraserTool()
    case ToolType.Fill:
      return new FillTool()

    default:
      return new PenTool()
  }
}
</file>

<file path="models/types/Canvas.ts">
export type Canvas = {
  width: number;
  height: number;
};

export const createCanvas = (width = 800, height = 1200): Canvas => {
  return {
    width,
    height,
  };
};
</file>

<file path="models/types/Layer.ts">
import { DSL } from "~/models/dsl/DSL";

export enum LayerType {
  Dot,
  Image,
  Automate,
}

export type Layer = {
  id: string;
  name: string;
  type: LayerType;
  typeDescription: string; // 各タイプの説明
  enabled: boolean;
  dotMagnification: number;
  dsl: DSL;
};
</file>

<file path="models/types/LayerImage.ts">
import { DiffAction } from '../layer_image/HistoryManager'

export type LayerImage = {
  current: ImageData
  undoStack: DiffAction[]
  redoStack: DiffAction[]
}
</file>

<file path="models/types/Tool.ts">
import {
  toolStore,
  setToolStore as setToolStore,
} from '~/stores/internal/toolsStore'

export enum ToolType {
  Pen = 'pen',
  Eraser = 'eraser',
  Fill = 'fill',
}

export type Tool = {
  type: ToolType
  id: string
  name: string
  size: number
  color: string
}

export const setCurrentToolColor = (colorHexString: string) => {
  return setToolStore('tools', toolStore.usingIndex, 'color', colorHexString)
}
</file>

<file path="models/types/Vector.ts">
export interface Vec2 {
  x: number
  y: number
}
</file>

<file path="routes/[...404].tsx">
import { Title } from "@solidjs/meta";

export default function NotFound() {
  return (
    <main>
      <Title>Not Found</Title>
      <h1>Page Not Found</h1>
      <p>
        Visit{" "}
        <a href="https://start.solidjs.com" target="_blank">
          start.solidjs.com
        </a>{" "}
        to learn how to build SolidStart apps.
      </p>
    </main>
  );
}
</file>

<file path="routes/editor/index.tsx">
import { useLocation } from "@solidjs/router";
import { createSignal, onMount } from "solid-js";
import BottomInfo from "~/components/BottomInfo";
import CanvasArea from "~/components/canvas/CanvasArea";
import EdgeInfo from "~/components/EdgeInfo";
import SideSections from "~/components/SideSections";
import { importProjectJsonFromPath } from "~/io/project/project";
import { adjustZoomToFit, centeringCanvas } from "~/stores/project/canvasStore";
import { flexCol, flexRow } from "~/styles/snippets.css";
import { welcomeRoot } from "../start.css";
import { loadGlobalSettings } from "~/io/global/globalIO";

export default function Editor() {
  const location = useLocation();

  const [isImporting, setIsImporting] = createSignal(false);

  if (location.search) {
    setIsImporting(true);
    const sp = new URLSearchParams(location.search);
    const fileName = sp.get("name");
    const filePath = sp.get("path");
    const path = `${filePath}\\${fileName}`;
    console.log(path);
    importProjectJsonFromPath(path).then(() => {
      setIsImporting(false);
    });
  }

  onMount(() => {
    adjustZoomToFit();
    centeringCanvas();
    loadGlobalSettings();
  });

  return (
    <>
      {isImporting() && (
        <div id="root">
          <div class={welcomeRoot}>
            <p style={{ "font-size": "3rem" }}>please wait.</p>
          </div>
        </div>
      )}

      {!isImporting() && (
        <div id="root">
          <div class={flexRow}>
            <EdgeInfo />
            <SideSections />
          </div>

          <div class={flexCol} style={{ "flex-grow": 1 }}>
            <CanvasArea />
            <BottomInfo />
          </div>
          {/* <Companion /> */}
        </div>
      )}
    </>
  );
}
</file>

<file path="routes/index.tsx">
import { useNavigate } from "@solidjs/router";
import { For, onMount } from "solid-js";
import EdgeInfo from "~/components/EdgeInfo";
import { importProjectJsonFromFileSelection } from "~/io/project/project";
import { createLayer } from "~/models/factories/createLayer";
import { LayerType } from "~/models/types/Layer";
import {
  FileLocation,
  addRecent,
  globalStore,
  setGlobalStore,
} from "~/stores/global/globalStore";
import { setLayerStore } from "~/stores/project/layerStore";
import { sideArea } from "~/styles/global.css";
import { sectionRoot } from "~/styles/section_global.css";
import { flexCol, flexRow, w100 } from "~/styles/snippets.css";
import { getFileNameAndPath } from "~/utils/pathUtils";
import {
  clear,
  recentFilesCaption,
  recentFilesContainer,
  recentFilesItem,
  recentFilesName,
  recentFilesPath,
  sideSection,
  sideSectionItem,
  welcomeHeadline,
  welcomeRoot,
} from "./start.css";
import { loadGlobalSettings } from "~/io/global/globalIO";

export default function Home() {
  const navigate = useNavigate();

  onMount(() => {
    loadGlobalSettings();
  });

  const moveToEditor = async (recentFile: FileLocation) => {
    const params = new URLSearchParams();
    params.append("name", recentFile.name);
    params.append("path", recentFile.path);
    navigate(`/editor?${params.toString()}`, { replace: false });
  };

  const createNew = () => {
    const DEFAULT_LAYERS = [createLayer("dot1", LayerType.Dot, true, 1)];
    setLayerStore("layers", DEFAULT_LAYERS);
    setLayerStore("activeLayerId", DEFAULT_LAYERS[0].id);
    navigate(`/editor`, { replace: false });
  };

  const openProject = () => {
    importProjectJsonFromFileSelection().then((file: string | undefined) => {
      if (file !== undefined) {
        const loc = getFileNameAndPath(file);
        if (loc !== undefined) addRecent(loc);
        navigate(`/editor`, { replace: false });
      }
    });
  };

  const clearRecentFiles = () => {
    setGlobalStore("recentOpenedFiles", []);
  };

  return (
    <div id="root">
      <div class={sideArea}>
        <EdgeInfo />
      </div>

      <div class={welcomeRoot}>
        <div class={flexCol}>
          <p class={welcomeHeadline}>hello.</p>
          <div class={sideSection}>
            <a class={sideSectionItem} onClick={() => createNew()}>
              + new.
            </a>
            <a
              class={sideSectionItem}
              style={{ "margin-left": "2px" }}
              onClick={(e) => openProject()}
            >
              &gt; open.
            </a>
          </div>

          <div class={sectionRoot}>
            <div class={[flexRow, w100].join(" ")}>
              <p class={recentFilesCaption}>recent files.</p>
              <p class={clear} onClick={() => clearRecentFiles()}>
                clear
              </p>
            </div>
            <div class={recentFilesContainer}>
              <For each={globalStore.recentOpenedFiles}>
                {(item, i) => {
                  console.log(item);
                  return (
                    <div class={recentFilesItem}>
                      <p>■</p>
                      <a
                        class={recentFilesName}
                        onClick={(e) => moveToEditor(item)}
                      >
                        {item.name}
                      </a>
                      <p class={recentFilesPath}>{item.path}</p>
                    </div>
                  );
                }}
              </For>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="routes/start.css.ts">
import { style } from "@vanilla-extract/css";
import { ZFB03B, ZFB09 } from "~/styles/global.css";
import { flexCol, flexRow, w100, wh100 } from "~/styles/snippets.css";

export const welcomeRoot = style([
  flexCol,
  wh100,
  {
    alignItems: "center",
    justifyContent: "center",
  },
]);

export const welcomeHeadline = style({
  fontFamily: ZFB09,
  fontSize: "5rem",
  letterSpacing: "8px",
  marginBottom: "12px",
});

export const recentFilesCaption = style({
  fontFamily: ZFB03B,
  color: "#333",
  flexGrow: 1,
  marginBottom: "12px",
});

export const clear = style({
  color: "#777",
  fontFamily: ZFB03B,
});

export const recentFilesContainer = style([
  flexCol,
  w100,
  {
    gap: "8px",
    marginTop: "4px",
  },
]);

export const recentFilesItem = style([
  flexRow,
  w100,
  {
    alignItems: "center",
    gap: "8px",
  },
]);

export const recentFilesName = style({
  fontFamily: ZFB09,
  fontSize: "0.5rem",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
});

export const recentFilesPath = style({
  fontFamily: ZFB03B,
  fontSize: "0.5rem",
  color: "#00000030",
});

export const sideSection = style([
  flexCol,
  {
    gap: "1rem",
    paddingBottom: "24px",
    paddingTop: "12px",
  },
]);

export const sideSectionItem = style([
  flexCol,
  {
    cursor: "pointer",
    fontSize: "1rem",
    width: "fit-content",
    ":hover": {
      color: "red",
    },
  },
]);
</file>

<file path="stores/global/globalStore.ts">
import { createStore } from 'solid-js/store'
import { saveGlobalSettings } from '~/io/global/globalIO'
import { canvasStore } from '../project/canvasStore'
import { createEffect } from 'solid-js'

// global
export type FileLocation = {
  path: string
  name: string
}
export type ImageRenderingAttribute = 'auto' | 'pixelated' | 'crispEdges'
export type CanvasRenderingMode = 'adaptive' | 'pixelated' | 'crispEdges'

export const getCanvasImageRenderingAttribute = (mode: CanvasRenderingMode) => {
  switch (mode) {
    case 'pixelated':
    case 'crispEdges':
      return mode
    case 'adaptive':
      return canvasStore.zoom > 1.0 ? 'pixelated' : 'crispEdges'
  }
}

export const [globalStore, setGlobalStore] = createStore({
  recentOpenedFiles: [
    {
      path: 'C:\\Users\\innsb\\Documents',
      name: 'project.sledge',
    },
  ],

  canvasRenderingMode: 'adaptive' as CanvasRenderingMode,
})

export const addRecent = (loc: FileLocation) => {
  const path = loc.path
  const name = loc.name

  // add to recent
  setGlobalStore((store) => {
    console.log('path: ' + path)
    console.log('name: ' + name)
    if (name && path && store.recentOpenedFiles) {
      // 履歴にあっても一旦削除
      let oldRecentFiles = store.recentOpenedFiles.filter((f) => {
        return f.name !== name || f.path !== path?.toString()
      })
      // その後、一番上に追加
      const newRecentFiles: FileLocation[] = [
        {
          name: name,
          path: path,
        },
        ...oldRecentFiles,
      ]
      setGlobalStore('recentOpenedFiles', newRecentFiles)
      saveGlobalSettings()
    }
    return store
  })
}
</file>

<file path="stores/internal/colorStore.ts">
import { createStore } from "solid-js/store";

// color

export const [colorStore, setColorStore] = createStore({
  swatches: [
    "#000000",
    "#FFFFFF",
    "#ffff00",
    "#00ffff",
    "#00ff00",
    "#ff00ff",
    "#ff0000",
    "#0000ff",
    "#000080",
    "#400080",
  ],
});
</file>

<file path="stores/internal/toastStore.ts">
import { createStore } from "solid-js/store";

export type ToastType = "info" | "success" | "warn" | "error";

export interface Toast {
  id: number;
  message: string;
  type: ToastType;
  timeout: number;
  isPersistent: boolean;
}

let toastId = 0;
const MAX_COUNT = 10;
export const [toasts, setToasts] = createStore<Toast[]>([]);

export function showToast(
  message: string | number,
  type: ToastType = "info",
  timeout = 10000,
) {
  if (typeof message === "number") message = message.toString();
  const id = toastId++;
  const isPersistent = timeout < 0;
  if (toasts.length >= MAX_COUNT) {
    const reducedToasts = [...toasts];
    reducedToasts.shift();
    setToasts(reducedToasts);
  }
  setToasts([...toasts, { id, message, type, timeout, isPersistent }]);

  if (!isPersistent) {
    setTimeout(() => {
      setToasts((prev) => prev.filter((t) => t.id !== id));
    }, timeout);
  }
}
</file>

<file path="stores/internal/toolsStore.ts">
import { createStore } from 'solid-js/store'
import { createTool } from '~/models/factories/createPen'
import { ToolType } from '~/models/types/Tool'

export const [toolStore, setToolStore] = createStore({
  usingIndex: 0,
  tools: [
    createTool(ToolType.Pen, 'pen', 1, '#000000'),
    createTool(ToolType.Eraser, 'eraser', 4, 'none'),
    createTool(ToolType.Fill, 'fill', 4, '#FF0000'),
  ],
})
export const currentTool = () => toolStore.tools[toolStore.usingIndex]
</file>

<file path="stores/project/canvasStore.ts">
import { createStore } from 'solid-js/store'
import { createCanvas } from '~/models/types/Canvas'

// canvas
const REFERENCE_LENGTH = 600

export const getReferencedZoom = (length?: number) => {
  if (length === undefined) {
    const width = canvasStore.canvas.width
    const height = canvasStore.canvas.height
    length = width > height ? width : height
  }

  return REFERENCE_LENGTH / length
}

export const adjustZoomToFit = (width?: number, height?: number) => {
  if (width === undefined) width = canvasStore.canvas.width
  if (height === undefined) height = canvasStore.canvas.height

  let isWide = width > height
  let longerLength = isWide ? width : height

  console.log(
    `this is ${isWide ? 'wide' : 'tall'}.
    ${REFERENCE_LENGTH} / ${longerLength} = ${REFERENCE_LENGTH / longerLength}. set zoom.`
  )
  setCanvasStore('zoom', getReferencedZoom(longerLength))
  centeringCanvas()
}

export const centeringCanvas = () => {
  const canvasSize = canvasStore.canvas
  const canvasArea = canvasStore.canvasAreaSize
  const zoom = canvasStore.zoom

  console.log(
    `area size is ${canvasArea.width} x ${canvasArea.height}.
    canvas size is ${canvasSize.width} x ${canvasSize.height}.
    current offset origin is ${canvasStore.offsetOrigin.x}, ${canvasStore.offsetOrigin.y}.
    new offset origin is ${canvasStore.canvasAreaSize.width / 2 - canvasStore.canvas.width / 2}, ${canvasStore.canvasAreaSize.height / 2 - canvasStore.canvas.height / 2}`
  )

  setCanvasStore('offsetOrigin', {
    x: canvasArea.width / 2 - (canvasSize.width * zoom) / 2,
    y: canvasArea.height / 2 - (canvasSize.height * zoom) / 2,
  })
  setCanvasStore('offset', {
    x: 0,
    y: 0,
  })
}

export const [canvasStore, setCanvasStore] = createStore({
  canvas: createCanvas(400, 400),
  canvasAreaSize: { width: 0, height: 0 },
  canvasElementSize: { width: 0, height: 0 },
  lastMouseWindow: { x: 0, y: 0 },
  lastMouseOnCanvas: { x: 0, y: 0 },
  lastMouseOnZoomedCanvas: { x: 0, y: 0 },
  isInStroke: false,
  zoom: 1,
  zoomMin: 0.1,
  zoomMax: 8,
  touchZoomSensitivity: 0.5,
  wheelZoomStep: 0.1,
  // オフセットの初期値
  offsetOrigin: { x: 0, y: 0 },
  offset: { x: 0, y: 0 },

  isCtrlPressed: false,
  isDragging: false,
})
</file>

<file path="stores/project/layerImageStore.ts">
import { createStore } from 'solid-js/store'
import { runDSL } from '~/models/dsl/DSLRunner'
import { findLayerById, layerStore } from './layerStore'
import { LayerImage } from '~/models/types/LayerImage'

// image

export const [layerImageStore, setLayerImageStore] = createStore<
  Record<string, LayerImage>
>({})

export const activeLayerImage = (): LayerImage =>
  layerImageStore[layerStore.activeLayerId]

export const canUndo = (): boolean =>
  layerImageStore[layerStore.activeLayerId]?.undoStack.length > 0
export const canRedo = (): boolean =>
  layerImageStore[layerStore.activeLayerId]?.redoStack.length > 0
</file>

<file path="stores/project/layerStore.ts">
import { createStore } from 'solid-js/store'
import { Layer } from '~/models/types/Layer'

// layer

export const [layerStore, setLayerStore] = createStore({
  layers: new Array<Layer>(),
  activeLayerId: '',
})

export const allLayers = () => layerStore.layers
export const findLayerById = (id: string) =>
  allLayers().find((layer) => layer.id === id)
export const activeLayer = () =>
  findLayerById(layerStore.activeLayerId) || allLayers()[0] || undefined
export const activeIndex = () =>
  allLayers().findIndex((layer) => layer.id === layerStore.activeLayerId)
</file>

<file path="stores/project/projectStore.ts">
import { trackStore } from '@solid-primitives/deep'
import { createEffect } from 'solid-js'
import { createStore } from 'solid-js/store'
import { canvasStore } from './canvasStore'
import { layerImageStore } from './layerImageStore'
import { layerStore } from './layerStore'

// project
export const [projectStore, setProjectStore] = createStore({
  name: '',
  path: '',
  isProjectChangedAfterSave: false,
})

createEffect(() => {
  trackStore(canvasStore.canvas)
  trackStore(layerImageStore)
  trackStore(layerStore)
  setProjectStore('isProjectChangedAfterSave', true)
})
</file>

<file path="styles/components/bottom_info.css.ts">
import { style } from "@vanilla-extract/css";
import { vars } from "../global.css";
import { flexRow, w100 } from "../snippets.css";

export const bottomInfoRoot = style([
  flexRow,
  w100,
  {
    borderTop: "1px solid #aaa",
    height: "20px",
    alignItems: "center",
    padding: `0 ${vars.spacing.md}`,
    gap: vars.spacing.md,
  },
]);

export const bottomInfoText = style({});
</file>

<file path="styles/components/canvas/canvas_area.css.ts">
import { style } from "@vanilla-extract/css";
import { flexCol } from "../../snippets.css";

export const canvasArea = style([
  flexCol,
  {
    backgroundColor: "#fcfcfc",
    display: "flex",
    flex: 1,
    flexDirection: "column",
    height: "100vh",
    overflow: "hidden",
    position: "relative",
    width: "100%",
  },
]);
</file>

<file path="styles/components/canvas/canvas_stack.module.css">
.canvas_stack {
  align-items: center;
  display: flex;
  justify-content: center;
  position: relative;
}

.image-container:focus-within {
  border: 2px black solid;
}

.resize-image {
  height: 100%;
  object-fit: fill;
  width: 100%;
}
</file>

<file path="styles/components/canvas/controls.module.css">
* {
  z-index: 1000;
}

.cursor {
  background-color: black;
  height: 4px;
  left: 220px;
  position: absolute;
  top: 170px;
  width: 4px;
}

.top-right-button-container {
  display: flex;
  flex-direction: row;
  gap: 10px;
  position: absolute;
  right: 30px;
  top: 20px;
}

.top-right-nav {
  display: flex;
  flex-direction: row;
  gap: 25px;
  position: absolute;
  right: 30px;
  top: 30px;
}

.bottom-history {
  bottom: 50px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  position: absolute;
}

.history-row {
  display: flex;
  gap: 20px;
  opacity: 0.2;
  width: 60%;
}

.history-text {
  white-space: nowrap;
}

.undo_redo {
  cursor: pointer;
  height: 24px;
  image-rendering: pixelated;
  padding: 8px;
  pointer-events: all;
  width: 24px;
}
</file>

<file path="styles/components/canvas/image_pool.module.css">
.resize-drag-container {
  /* This makes things *much* easier */
  box-sizing: border-box;
  font-family: sans-serif;
  left: 0;
  padding: 0;
  position: absolute;
  top: 0;
  touch-action: none;
  width: 120px;
  z-index: 100;
}

.image-container {
  height: 100%;
  width: 100%;
}
</file>

<file path="styles/components/canvas/layer_canvas.css.ts">
import { recipe } from '@vanilla-extract/recipes'

export const layerCanvas = recipe({
  base: {
    pointerEvents: 'none',
    position: 'absolute',
  },

  variants: {
    rendering: {
      auto: {
        imageRendering: 'auto',
      },
      pixelated: {
        imageRendering: 'pixelated',
      },
      crispEdges: {
        imageRendering: 'crisp-edges',
      },
    },
    hidden: {
      true: {
        opacity: 0,
        pointerEvents: 'auto',
      },
    },
  },

  defaultVariants: {
    rendering: 'auto',
    hidden: false,
  },
})
</file>

<file path="styles/components/companion.module.css">
.root {
  bottom: 0;
  left: 500px;
  pointer-events: none;
  position: absolute;
  z-index: 999;
}

.wrapper {
  animation: fluffy 2s ease-in-out infinite;
  height: 300px;
  transform-origin: center center;
  width: 300px;
}

.companion {
  anchor-name: --companion;
  display: flex;
  flex-direction: column;
  height: 50px;
  image-rendering: pixelated;
  margin: 80px auto;
  margin-left: 0;
  width: 50px;
}

.giggle {
  animation: giggle 0.5s;
  animation-iteration-count: 10;
}

.quote_box_container {
  background-color: #ddd;
  bottom: calc(anchor(top) + 17px);
  justify-self: anchor-center;
  position: absolute;
  position-anchor: --companion;
  width: fit-content;
}

.quote_box {
  anchor-name: --box;
  background: #fff;
  border: solid 1px #555;
  border-radius: 3px;
  max-width: 200px;
  overflow-wrap: break-word;
  padding: 12px;
  width: fit-content;
}

.quote_box::before {
  border: 7px solid transparent;
  border-top: 7px solid #fff;
  content: "";
  padding-left: 1px;
  position: absolute;
  position-anchor: --companion;
  top: calc(anchor(--box bottom) - 2px);
  z-index: 2;
}

.quote_box::after {
  border: 8px solid transparent;
  border-top: 8px solid #555;
  content: "";
  position: absolute;
  position-anchor: --companion;
  top: calc(anchor(--box bottom) - 1px);
}

.quote {
  image-rendering: pixelated;
}

@keyframes fluffy {
  0%,
  100% {
    transform: translateY(0);
  }

  50% {
    transform: translateY(-5px);
  }
}

@keyframes giggle {
  0% {
    transform: rotate(0deg);
  }

  25% {
    transform: rotate(2deg);
  }

  50% {
    transform: rotate(0deg);
  }

  75% {
    transform: rotate(-2deg);
  }

  100% {
    transform: rotate(0deg);
  }
}
</file>

<file path="styles/components/dropdown.css.ts">
import { style } from '@vanilla-extract/css'
import { vars } from '~/styles/global.css'

export const dropdownRoot = style({
  fontFamily: vars.font.body,
  fontSize: vars.text.sm,
  backgroundColor: vars.color.secondary,
  border: '0px solid black',
  borderRadius: '0px',
  padding: '2px 6px',
  height: '20px',
  cursor: 'pointer',
  lineHeight: '12px',
  selectors: {
    '&:hover': { backgroundColor: vars.color.button_hover },
    '&:active': {
      backgroundColor: vars.color.button_pressed,
    },
    /* Windows の ▼ 矢印が滲むのを抑止 */
    '&::-ms-expand': { display: 'none' },
  },
})
</file>

<file path="styles/components/dsl_button.module.css">
.root {
  cursor: pointer;
  height: 20px;
  image-rendering: pixelated;
  margin: 4px;
  opacity: 0.7;
  pointer-events: all;
  width: 20px;
}

.root:hover {
  opacity: 0.3;
  transform: translate(0, 1px);
}
</file>

<file path="styles/components/edge_info.module.css">
.root {
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 10px 0 20px 12px;
  justify-items: start;
}

.text {
  font-size: 0.5rem;
  letter-spacing: 2px;
  margin: 0;
  transform: rotate(180deg) scaleX(0.8);
  white-space: nowrap;
  writing-mode: vertical-rl;
}
</file>

<file path="styles/components/layer_preview.module.css">
.canvas {
  height: 100%;
  border: 1px solid black;
  width: 100%;
}
</file>

<file path="styles/components/light.module.css">
.light-inner {
  filter: drop-shadow(0 0 0 red);
  opacity: 0;
  transition: none;
}

.light-inner.on {
  filter: drop-shadow(0 0 1px red);
  opacity: 1;
  transition: opacity 01s ease;
}
</file>

<file path="styles/components/slider.module.css">
.root {
  width: 100%;
}

.slider {
  align-items: center;
  display: flex;
  height: auto;
  overflow: visible;
  position: relative;
  width: 100%;
}

.line-hitbox {
  align-items: center;
  background-color: transparent;
  cursor: pointer;
  display: flex;
  height: 16px;
  position: absolute;
  width: 100%;
}

.line {
  background-color: black;
  display: flex;
  height: 1px;
  pointer-events: none; /* イベントは親に任せる */
  width: 100%;
}

.handle-hitbox {
  align-items: center;

  /* ユーザーには見えないけどクリックできる */
  background-color: transparent;
  cursor: pointer;
  display: flex;
  height: 24px;
  position: absolute;
  transform: translateX(-50%);
  width: 20px;
}

.handle {
  background-color: black;
  height: 8px;
  left: 50%;
  pointer-events: none; /* イベントは親に任せる */
  position: absolute;
  transform: translateX(-50%);
  width: 2px;
}
</file>

<file path="styles/components/title_bar.css.ts">
import { style } from "@vanilla-extract/css";
import { vars, ZFB08 } from "../global.css";
import { flexCol, flexRow, h100, w100 } from "../snippets.css";

export const titleBarRoot = style([
  flexRow,
  w100,
  {
    background: "#fff",
    pointerEvents: "all",
    height: "28px",
    borderBottom: "1px solid #aaa",
    alignItems: "center",
    zIndex: 9999,
  },
]);

export const titleBarTitle = style([
  flexRow,
  w100,
  {
    fontFamily: ZFB08,
    fontSize: vars.text.sm,
    marginRight: "auto",
    paddingLeft: vars.spacing.lg,
    pointerEvents: "none",
  },
]);

export const titleBarControls = style([
  flexRow,
  h100,
  {
    gap: vars.spacing.sm,
    marginRight: vars.spacing.sm,
  },
]);

export const titleBarControlButton = style([
  flexCol,
  h100,
  {
    background: "none",
    backgroundColor: "transparent",
    border: "none",
    alignItems: "center",
    justifyContent: "center",
    minWidth: "24px",
    ":hover": {
      backgroundColor: "transparent",
    },
  },
]);

export const titleBarControlMinimizeButton = style([
  titleBarControlButton,
  {
    ":hover": {
      filter:
        "invert(9%) sepia(100%) saturate(6812%) hue-rotate(247deg) brightness(96%) contrast(146%);", // 青っぽく
    },
  },
]);

export const titleBarControlMaximizeButton = style([
  titleBarControlButton,
  {
    ":hover": {
      filter:
        "invert(92%) sepia(20%) saturate(3846%) hue-rotate(112deg) brightness(105%) contrast(102%);", // 緑っぽく
    },
  },
]);

export const titleBarControlCloseButton = style([
  titleBarControlButton,
  {
    ":hover": {
      filter:
        "invert(11%) sepia(92%) saturate(7351%) hue-rotate(0deg) brightness(99%) contrast(109%);", // 赤っぽく
    },
  },
]);

export const titleBarControlButtonImg = style({
  width: "10px",
  height: "10px",
  imageRendering: "pixelated",
});
</file>

<file path="styles/components/toast.module.css">
.toastContainer {
  bottom: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  padding-bottom: 20px;
  position: fixed;
  right: 1rem;
  z-index: 9999;
}

.toast_root {
  align-items: center;
  background-color: #fff;
  border: 1px solid black;
  border-radius: 6px;
  display: flex;
  flex-direction: row;
  gap: 1rem;
  padding: 0.5rem;
}

.close_persistent_button {
  height: 12px;
  width: 12px;

  &:hover {
    color: red;
  }
}

.toast {
  color: #222;
  flex-grow: 1;
  font-family: "04B09";
  font-size: 0.5rem;
  margin-top: 2px;
}

.toast.success {
  color: #4caf50;
}

.toast.error {
  color: #f44336;
}

.toast.warn {
  color: #ff9800;
}

.toast.info {
  /* background-color: #2196f3; */
}

@keyframes fade-in-out-top {
  0% {
    opacity: 0;
    transform: translateY(-10px);
  }

  10%,
  90% {
    opacity: 1;
    transform: translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateY(-10px);
  }
}

@keyframes fade-in-out-bottom {
  0% {
    opacity: 0;
    transform: translateY(10px);
  }

  10%,
  90% {
    opacity: 1;
    transform: translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateY(10px);
  }
}
</file>

<file path="styles/components/toggle_switch.css.ts">
import { style, globalStyle } from '@vanilla-extract/css'
import { vars } from '~/styles/global.css'

const globalWidth = 16
const thumbWidth = 10
const thumbPadding = 2
const globalHeight = 10

/* ラベル全体 */
export const toggleWrapper = style({
  display: 'inline-flex',
  alignItems: 'center',
  gap: vars.spacing.sm,
  cursor: 'pointer',
  userSelect: 'none',
})

/* 入力本体 (隠す) */
export const toggleInput = style({
  opacity: 0,
  width: 0,
  height: 0,
  position: 'absolute',
})

/* バックグラウンドとなるトラック */
export const toggleTrack = style({
  width: `${globalWidth}px`,
  height: `${globalHeight}px`,
  backgroundColor: vars.color.muted,
  border: '1px solid black',
  borderRadius: '0px',
  position: 'relative',
  transition: 'background-color 0.05s',
})

/* つまみ */
export const toggleThumb = style({
  position: 'absolute',
  top: '-1px',
  left: '0px',
  width: `${thumbWidth - thumbPadding}px`,
  height: `${globalHeight}px`,
  backgroundColor: vars.color.button,
  border: '1px solid black',
  borderRadius: '0px',
  transition: 'transform 0.05s',
})

/* ───────── 状態連動スタイル ───────── */

/* input が :checked のとき隣接する track を赤系へ */
globalStyle(`${toggleInput}:checked + ${toggleTrack}`, {
  backgroundColor: vars.color.danger,
})

/* さらに thumb を右へスライド */
globalStyle(`${toggleInput}:checked + ${toggleTrack} ${toggleThumb}`, {
  transform: `translateX(${globalWidth - thumbWidth}px)`,
})
</file>

<file path="styles/global.css.ts">
import {
  createGlobalTheme,
  fontFace,
  globalStyle,
  keyframes,
  style,
} from '@vanilla-extract/css'
import { flexCol, flexRow, h100 } from './snippets.css'

export const ZFB03 = fontFace({
  src: 'url("/fonts/04B_03__.ttf")',
})
export const ZFB03B = fontFace({
  src: 'url("/fonts/04B_03B_.ttf")',
})
export const ZFB08 = fontFace({
  src: 'url("/fonts/04B_08__.ttf")',
})
export const ZFB09 = fontFace({
  src: 'url("/fonts/04B_09__.ttf")',
})
export const ZFB11 = fontFace({
  src: 'url("/fonts/04B_11__.ttf")',
})
export const ZFB31 = fontFace({
  src: 'url("/fonts/04B_31__.ttf")',
})
export const Terminus = fontFace({
  src: 'url("/fonts/terminus/TerminusTTF-4.49.3.ttf")',
})
export const k8x12 = fontFace({
  src: 'url("/fonts/k8x12/k8x12.ttf")',
})
export const k8x12L = fontFace({
  src: 'url("/fonts/k8x12/k8x12L.ttf")',
})
export const k8x12S = fontFace({
  src: 'url("/fonts/k8x12/k8x12S.ttf")',
})
export const k12x8 = fontFace({
  src: 'url("/fonts/k12x8/k12x8.ttf")',
})

export const vars = createGlobalTheme(':root', {
  color: {
    primary: '#ffffff',
    secondary: '#f0f0f0',
    text: '#111111',
    danger: '#ff0000',
    muted: '#00000030',
    bg: '#ffffff',
    surface: '#f0f0f0',

    button: '#ffffff',
    button_hover: '#f0f0f0',
    button_pressed: '#f0f0f0',
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '12px',
    lg: '16px',
    xl: '24px',
  },
  text: {
    xs: '6px',
    sm: '8px',
    md: '10px',
    lg: '12px',
    xl: '16px',
  },
  font: {
    body: `${ZFB08}, ${k8x12}`,
  },
})

globalStyle('button, p, a, input', {
  fontFamily: ZFB08,
  color: vars.color.text,
})

globalStyle('a:hover', {
  color: 'red',
})

globalStyle('button', {
  background: vars.color.button,
  border: '1px black solid',
  borderRadius: '2px',
  cursor: 'pointer',
  fontSize: '0.5rem',
  height: 'fit-content',
  padding: '2px 6px',
  pointerEvents: 'all',
})

globalStyle('button:hover', {
  background: vars.color.button_hover,
})

globalStyle('button:active', {
  background: vars.color.button_pressed,
  transform: 'translateY(1px)',
})

globalStyle('#root', {
  display: 'flex',
  flexDirection: 'row',
  height: '100%',
  userSelect: 'none',
})

export const sideArea = style([flexRow, h100])

export const sideAreaEdge = style([
  flexCol,
  h100,
  {
    gap: '20px',
    width: '20px',
    margin: '10px 0 20px 2px',
    paddingBottom: '20px',
    justifyContent: 'flex-end',
  },
])

export const sideAreaEdgeText = style({
  fontSize: '0.5rem',
  letterSpacing: '2px',
  transform: 'rotate(180deg) scaleX(0.8)',
  whiteSpace: 'nowrap',
  writingMode: 'vertical-rl',
})

export const sideAreaContent = style([
  flexCol,
  {
    borderRight: '1px solid #aaa',
    gap: '1rem',
    padding: '20px 40px 90px 20px',
    width: '230px',
    overflowY: 'scroll',
    '::-webkit-scrollbar': {
      width: '4px',
    },
    '::-webkit-scrollbar-thumb': {
      backgroundColor: 'transparent',
    },
    selectors: {
      '&:hover::-webkit-scrollbar-thumb': {
        backgroundColor: '#ddd',
      },
    },
  },
])

export const sledgeLogo = style({
  bottom: '2px',
  position: 'absolute',
  right: '2px',
})
</file>

<file path="styles/reset.css.ts">
import { globalStyle } from "@vanilla-extract/css";

globalStyle("html, body", {
  height: "100vh",
  width: "100vw",
  margin: 0,
  overflow: "hidden",
  padding: 0,
  touchAction: "none",
});

globalStyle("body", {
  height: "100vh",
  width: "100vw",
});

globalStyle("main", {
  height: "100vh",
  width: "100vw",
  userSelect: "none",
});

globalStyle("p, a", {
  fontSize: "0.5rem",
  letterSpacing: "1px",
  margin: 0,
});

globalStyle("ul", {
  listStyle: "none",
  paddingLeft: 0,
});

globalStyle("a", {
  cursor: "pointer",
});

globalStyle("input", {
  border: "none",
  outline: "none",
  borderBottom: "1px solid black",
});

globalStyle(
  "input::-webkit-outer-spin-button, input::-webkit-inner-spin-button",
  {
    appearance: "none",
    margin: 0,
  },
);

globalStyle("input[type='number']", {
  appearance: "textfield",
});
</file>

<file path="styles/section_global.css.ts">
import { style } from '@vanilla-extract/css'
import { vars, ZFB11 } from './global.css'
import { flexCol, w100 } from './snippets.css'

export const sectionRoot = style([
  flexCol,
  {
    // border: '1px solid black',
  },
])

export const sectionCaption = style({
  fontFamily: ZFB11,
  fontSize: vars.text.sm,
  marginBottom: vars.spacing.md,
})

export const sectionContent = style([flexCol, w100])
</file>

<file path="styles/section/canvas.css.ts">
import { style } from "@vanilla-extract/css";
import { vars } from "../global.css";
import { flexRow } from "../snippets.css";

export const canvasSizeForm = style([
  flexRow,
  {
    alignItems: "flex-end",
    marginBottom: "6px",
  },
]);

export const canvasSizeLabel = style({
  fontSize: vars.text.sm,
});

export const canvasSizeInput = style({
  fontSize: vars.text.md,
  margin: `${vars.spacing.xs}`,
  width: "50px",
});

export const canvasSizeButton = style({
  margin: vars.spacing.sm,
});
</file>

<file path="styles/section/color.css.ts">
import { style } from "@vanilla-extract/css";
import { vars, ZFB03 } from "../global.css";
import { flexCol } from "../snippets.css";

export const swatchContainer = style([
  flexCol,
  {
    position: "relative",
    gap: vars.spacing.xs,
    marginRight: vars.spacing.md,
  },
]);

export const descriptionContainer = style([
  flexCol,
  {
    justifyContent: "end",
    marginBottom: vars.spacing.sm,
  },
]);

export const colorElemDescription = style({
  color: vars.color.muted,
  fontFamily: ZFB03,
  fontSize: vars.text.sm,
  transform: "rotate(180deg)",
  whiteSpace: "nowrap",
  writingMode: "vertical-rl",
});

export const colorContent = style([
  flexCol,
  {
    marginLeft: vars.spacing.sm,
  },
]);
</file>

<file path="styles/section/layer.css.ts">
import { style } from "@vanilla-extract/css";
import { vars, ZFB03B } from "../global.css";
import { flexCol, flexRow, w100 } from "../snippets.css";

export const layerList = style([
  flexCol,
  w100,
  {
    flexGrow: 1,
    gap: vars.spacing.xs,
    position: "relative",
  },
]);

export const layerItem = style([
  flexRow,
  w100,
  {
    height: "24px",
    padding: vars.spacing.sm,
    flexGrow: 1,
    cursor: "pointer",
    backgroundColor: vars.color.surface,
    borderLeft: "1px solid black",
    ":hover": {
      filter: "brightness(0.94)",
      transform: "translate(0, 1px)",
    },
  },
]);

export const layerItemDisabled = style({
  color: vars.color.muted,
});

export const layerItemType = style([
  w100,
  {
    fontSize: vars.text.sm,
    opacity: 0.4,
    position: "absolute",
    right: 0,
    textAlign: "end",
  },
]);

export const layerItemName = style([
  {
    fontSize: vars.text.xl,
    fontFamily: ZFB03B,
    margin: `${vars.spacing.sm} 0 0 ${vars.spacing.lg}`,
  },
]);

export const dotMagnifContainer = style([
  {
    alignSelf: "center",
    border: "1px black solid",
    borderRadius: vars.spacing.xs,
    cursor: "pointer",
    marginLeft: "auto",
    marginRight: 0,
    padding: `2px ${vars.spacing.xs}`,
    pointerEvents: "all",

    ":hover": {
      color: vars.color.muted,
    },
  },
]);

export const dotMagnifText = style([
  {
    fontFamily: ZFB03B,
    fontSize: vars.text.md,
  },
]);

export const activeLight = style([
  {
    alignSelf: "center",
    margin: `${vars.spacing.sm}px 0`,
    marginLeft: vars.spacing.sm,
  },
]);

export const dropPlaceholder = style([
  {
    border: "2px dashed #aaa",
    borderRadius: vars.spacing.md,
    height: "32px",
    margin: `${vars.spacing.xs}px 0`,
  },
]);
</file>

<file path="styles/section/pen.css.ts">
import { style } from "@vanilla-extract/css";
import { vars } from "../global.css";
import { flexRow, w100 } from "../snippets.css";

export const penConfigRow = style([
  flexRow,
  w100,
  {
    gap: vars.spacing.md,
    alignItems: "center",
  },
]);

export const penConfigRowName = style({
  cursor: "pointer",
  fontSize: vars.text.sm,
  padding: `${vars.spacing.md} 0`,
  pointerEvents: "all",
  width: "20%",
});
</file>

<file path="styles/section/project.css.ts">
import { style } from "@vanilla-extract/css";
import { vars } from "../global.css";

export const projectNameInput = style({
  border: "none",
  fontSize: vars.text.xl,
  marginBottom: vars.spacing.sm,
  marginLeft: "-2px",
  outline: "none",

  "::placeholder": {
    opacity: 0.5,
  },
});

export const saveLog = style({
  color: "limegreen",
  marginLeft: vars.spacing.sm,
});
</file>

<file path="styles/snippets.css.ts">
import { style } from "@vanilla-extract/css";

export const flexCol = style({
  display: "flex",
  flexDirection: "column",
});

export const flexRow = style({
  display: "flex",
  flexDirection: "row",
});

export const w100 = style({
  width: "100%",
});

export const h100 = style({
  height: "100%",
});

export const wh100 = style([w100, h100]);
</file>

<file path="utils/colorUtils.ts">
export type RGBColor = [number, number, number]
export type RGBAColor = [number, number, number, number]

// "#rrggbb" -> r/g/b
export function hexToRGB(hex: string): RGBColor {
  const r = parseInt(hex.slice(1, 3), 16)
  const g = parseInt(hex.slice(3, 5), 16)
  const b = parseInt(hex.slice(5, 7), 16)
  return [r, g, b]
}

// "#rrggbbaa" -> r/g/b/a
export function hexToRGBA(hex: string): RGBAColor {
  const r = parseInt(hex.slice(1, 3), 16)
  const g = parseInt(hex.slice(3, 5), 16)
  const b = parseInt(hex.slice(5, 7), 16)
  let a = parseInt(hex.slice(7, 9), 16)
  if (!a) a = 255 // ここがなかったので a=NaN となり、塗る際にエラー？
  return [r, g, b, a]
}

export function colorMatch(a: RGBAColor, b: RGBAColor): boolean {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]
}
</file>

<file path="utils/DSLUtils.ts">
import { runDSL } from '~/models/dsl/DSLRunner'
import { layerImageStore } from '~/stores/project/layerImageStore'
import { findLayerById } from '~/stores/project/layerStore'
import { downloadImageData } from '../io/internal/export'

export const testDSLTime = (layerId: string) => {
  const layer = findLayerById(layerId)
  if (layer === undefined) {
    throw 'layer not found.'
    return
  }
  const imageData = layerImageStore[layerId].current

  const start = new Date().getTime()
  console.log(`DSL run started.\n${layer.dsl.build()}`)
  runDSL(layer.dsl, imageData).then((im) => {
    const end = new Date().getTime()
    console.log(`DSL run end.`)
    console.log(
      `result: ${im ? 'success' : 'failed'}. TOTAL TIME IS ${end - start}ms.`
    )

    if (im) downloadImageData(im, 'test-' + end + '.png')
  })
}
</file>

<file path="utils/ImageUtils.ts">
export function setPixel(
  image: ImageData,
  x: number,
  y: number,
  r: number,
  g: number,
  b: number,
  a: number,
) {
  if (x < 0 || x >= image.width || y < 0 || y >= image.height) return;
  const i = (y * image.width + x) * 4;
  image.data[i + 0] = r;
  image.data[i + 1] = g;
  image.data[i + 2] = b;
  image.data[i + 3] = a;
}

export function encodeImageData(imageData: ImageData): string {
  const bytes = new Uint8Array(imageData.data.buffer);
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary); // Base64 encode
}

export function decodeImageData(
  encoded: string,
  width: number,
  height: number,
): ImageData {
  const binary = atob(encoded);
  const buffer = new Uint8ClampedArray(binary.length);
  for (let i = 0; i < binary.length; i++) {
    buffer[i] = binary.charCodeAt(i);
  }
  return new ImageData(buffer, width, height);
}
</file>

<file path="utils/pathUtils.ts">
import { FileLocation } from "~/stores/global/globalStore";

export const getFileNameAndPath = (
  fullPath: string,
): FileLocation | undefined => {
  var filePath = fullPath.substring(0, fullPath.lastIndexOf("\\"));
  var fileName = fullPath.split("\\").pop()?.split("/").pop();

  if (filePath === undefined || fileName === undefined) return undefined;
  else {
    return {
      path: filePath,
      name: fileName,
    };
  }
};
</file>

<file path="utils/tauriUtils.ts">
import { getTauriVersion } from "@tauri-apps/api/app";
import { invoke as tauriInvoke } from "@tauri-apps/api/core";

let _isTauri: boolean | null = null;

export async function isTauri(): Promise<boolean> {
  if (_isTauri !== null) return _isTauri;
  try {
    await getTauriVersion();
    _isTauri = true;
  } catch {
    _isTauri = false;
  }
  return _isTauri;
}

export async function safeInvoke<T>(
  cmd: string,
  args?: Record<string, unknown>,
): Promise<T | undefined> {
  if (!(await isTauri())) {
    console.warn(`[safeInvoke] '${cmd}' skipped (not in Tauri environment)`);
    return undefined;
  }

  try {
    const result = await tauriInvoke<T>(cmd, args);
    return result;
  } catch (e) {
    console.error(`[safeInvoke] '${cmd}' failed:`, e);
    return undefined;
  }
}
</file>

</files>
