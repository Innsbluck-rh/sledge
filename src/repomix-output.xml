This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app.tsx
components/canvas/CanvasArea.tsx
components/canvas/CanvasAreaInteract.tsx
components/canvas/CanvasDebugOverlay.tsx
components/canvas/Controls.tsx
components/canvas/stacks/CanvasOverlaySVG.tsx
components/canvas/stacks/CanvasStack.tsx
components/canvas/stacks/LayerCanvas.tsx
components/canvas/stacks/TouchableCanvas.tsx
components/common/Checkbox.tsx
components/common/ColorBox.tsx
components/common/companion/Companion.tsx
components/common/companion/QuotePool.ts
components/common/Dropdown.tsx
components/common/DSLButton.tsx
components/common/LayerPreview.tsx
components/common/Light.tsx
components/common/PixelLineChart.tsx
components/common/RadioButton.tsx
components/common/Slider.tsx
components/common/ToggleSwitch.tsx
components/global/BottomInfo.tsx
components/global/EdgeInfo.tsx
components/global/SideSections.tsx
components/global/TitleBar.tsx
components/section/CanvasSettings.tsx
components/section/Color.tsx
components/section/item/ColorPicker.tsx
components/section/item/LayerItem.tsx
components/section/item/Palette.tsx
components/section/item/ToolItem.tsx
components/section/LayerList.tsx
components/section/Project.tsx
components/section/settings/EditorSettings.tsx
components/section/settings/PerformanceSettings.tsx
components/section/ToolConfig.tsx
controllers/canvas/CanvasController.ts
controllers/canvas/LayerCanvasOperator.ts
controllers/canvas/PreviewCanvasFactory.ts
controllers/color/ColorController.ts
controllers/config/GlobalConfigController.ts
controllers/layer_list/LayerListController.ts
controllers/layer/LayerController.ts
controllers/layer/LayerFactory.ts
controllers/log/LogController.tsx
controllers/tool/ToolController.ts
io/global_config/globalSettings.ts
io/image_io/save.ts
io/project/project.ts
main.tsx
models/dsl/DSL.ts
models/dsl/DSLRunner.ts
models/dsl/nodes/AvailableNodes.ts
models/dsl/nodes/DSLNodes.ts
models/dsl/nodes/effect/Brightness.ts
models/dsl/nodes/effect/EffectNode.ts
models/dsl/nodes/effect/GrayScale.ts
models/dsl/nodes/effect/Invert.ts
models/dsl/nodes/effect/Sepia.ts
models/dsl/nodes/fracture/FractureNode.ts
models/dsl/nodes/fracture/JpegGlitch.ts
models/dsl/nodes/pass/LayerIn.ts
models/dsl/nodes/pass/LayerOut.ts
models/dsl/nodes/pass/PassNode.ts
models/layer_image/agents/RawLayerImageAgent.ts
models/layer_image/agents/TileLayerImageAgent.ts
models/layer_image/HistoryManager.ts
models/layer_image/LayerImageAgent.ts
models/layer_image/LayerImageManager.ts
models/tool/eraser/EraserTool.ts
models/tool/fill/FillTool.ts
models/tool/fill/PixelFloodFill.ts
models/tool/fill/TileFloodFill.ts
models/tool/pen/PenTool.ts
models/tool/ToolBase.ts
models/tool/ToolFactory.ts
routes/[...404].tsx
routes/about/about.css.ts
routes/about/index.tsx
routes/editor/index.tsx
routes/index.tsx
routes/settings/index.tsx
routes/settings/settings.css.ts
routes/start.css.ts
stores/EditorStores.ts
stores/GlobalStores.ts
stores/ProjectStores.ts
styles/components/bottom_info.css.ts
styles/components/canvas/canvas_area.css.ts
styles/components/canvas/canvas_debug_overlay.css.ts
styles/components/canvas/canvas_stack.css.ts
styles/components/canvas/canvas_stack.module.css
styles/components/canvas/controls.module.css
styles/components/canvas/image_pool.module.css
styles/components/canvas/layer_canvas.css.ts
styles/components/checkbox.css.ts
styles/components/companion.module.css
styles/components/dropdown.css.ts
styles/components/dsl_button.module.css
styles/components/edge_info.css.ts
styles/components/layer_preview.module.css
styles/components/light.module.css
styles/components/palette.css.ts
styles/components/radio_button.css.ts
styles/components/side_sections.css.ts
styles/components/slider.module.css
styles/components/title_bar.css.ts
styles/components/toggle_switch.css.ts
styles/global.css.ts
styles/reset.css.ts
styles/section_global.css.ts
styles/section/canvas.css.ts
styles/section/color.css.ts
styles/section/layer.css.ts
styles/section/pen.css.ts
styles/section/project.css.ts
styles/snippets.css.ts
types/Canvas.ts
types/DrawState.ts
types/FileLocation.ts
types/Layer.ts
types/LayerHistory.ts
types/PaletteType.ts
types/Size.ts
types/Tile.ts
types/Tool.ts
types/Vector.ts
utils/ColorUtils.ts
utils/consts.ts
utils/DrawUtils.ts
utils/ImageUtils.ts
utils/PathUtils.ts
utils/TauriUtils.ts
utils/windowUtils.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app.tsx">
// @refresh reload
import { MetaProvider } from '@solidjs/meta';
import { Route, Router } from '@solidjs/router';
import { Suspense } from 'solid-js';
import TitleBar from './components/global/TitleBar';
import Home from './routes';
import About from './routes/about';
import Editor from './routes/editor';

import Settings from './routes/settings';
import { flexCol, h100 } from './styles/snippets.css';

export default function App() {
  return (
    <Router
      root={(props) => (
        <MetaProvider>
          <title>Sledge</title>
          <Suspense>
            <div class={[flexCol, h100].join(' ')}>
              <TitleBar />

              <main>{props.children}</main>

              {/* <p class={sledgeLogo}>sledge.</p> */}
            </div>
          </Suspense>
        </MetaProvider>
      )}
    >
      <Route path='/' component={Home} />
      <Route path='/editor' component={Editor} />
      <Route path='/settings' component={Settings} />
      <Route path='/about' component={About} />;
    </Router>
  );
}
</file>

<file path="components/canvas/CanvasArea.tsx">
import { createMemo, onCleanup, onMount } from 'solid-js';
import CanvasAreaInteract from './CanvasAreaInteract';
import Controls from './Controls';
import CanvasStack from './stacks/CanvasStack';

import { adjustZoomToFit, centeringCanvas } from '~/controllers/canvas/CanvasController';
import { interactStore, setInteractStore } from '~/stores/EditorStores';
import { canvasArea } from '~/styles/components/canvas/canvas_area.css';
import BottomInfo from '../global/BottomInfo';
import CanvasDebugOverlay from './CanvasDebugOverlay';

export default () => {
  let wrapper: HTMLDivElement;
  let canvasStack: HTMLDivElement;

  const interact: CanvasAreaInteract = new CanvasAreaInteract();

  onMount(() => {
    // set Canvas to center
    setInteractStore('canvasAreaSize', {
      width: wrapper.clientWidth,
      height: wrapper.clientHeight,
    });
    adjustZoomToFit();
    centeringCanvas();

    interact.setInteractListeners(wrapper, canvasStack);
  });

  onCleanup(() => {
    if (interact !== undefined) {
      interact.removeInteractListeners(wrapper, canvasStack);
    }
  });

  const offsetX = () => interactStore.offsetOrigin.x + interactStore.offset.x;
  const offsetY = () => interactStore.offsetOrigin.y + interactStore.offset.y;

  const transform = createMemo(() => {
    return `translate(${offsetX()}px, ${offsetY()}px) scale(${interactStore.zoom})`;
  });

  return (
    <div class={canvasArea}>
      <div
        id='zoompan-wrapper'
        ref={(el) => {
          wrapper = el;
        }}
        style={{
          display: 'flex',
          position: 'absolute',
          top: 0,
          left: 0,
          padding: 0,
          margin: 0,
          width: '100%',
          height: '100%',
          overflow: 'hidden',
          'touch-action': 'none',
        }}
      >
        <div
          ref={(el) => (canvasStack = el)}
          style={{
            width: 'fit-content',
            height: 'fit-content',
            padding: 0,
            margin: 0,
            'transform-origin': '0 0',
            transform: transform(),
          }}
        >
          <CanvasStack />
        </div>
      </div>

      <CanvasDebugOverlay />
      <Controls />
      <BottomInfo />
    </div>
  );
};
</file>

<file path="components/canvas/CanvasAreaInteract.tsx">
import { getReferencedZoom } from '~/controllers/canvas/CanvasController';
import { interactStore, setInteractStore } from '~/stores/EditorStores';
import { Vec2 } from '~/types/Vector';

class CanvasAreaInteract {
  private dragPosition: Vec2 = { x: 0, y: 0 };

  private lastX: number[] = [0, 0];
  private lastY: number[] = [0, 0];
  private lastDist: number = 0;

  private getMutualMove = (move0: number, move1: number) => {
    // 逆方向なら0
    if (Math.sign(move0) !== Math.sign(move1)) return 0;
    return Math.min(move1, move0);
  };

  private handleTouchMove(e: TouchEvent, canvasStack: HTMLDivElement) {
    if (interactStore.isInStroke) return;

    if (e.touches.length === 1) {
      const xMove0 = e.touches[0].clientX - this.lastX[0];
      if (xMove0 !== 0 && this.lastX[0] !== 0) {
        setInteractStore('offset', {
          x: interactStore.offset.x + xMove0,
          y: interactStore.offset.y,
        });
      }
      const yMove0 = e.touches[0].clientY - this.lastY[0];
      if (yMove0 !== 0 && this.lastY[0] !== 0) {
        setInteractStore('offset', {
          x: interactStore.offset.x,
          y: interactStore.offset.y + yMove0,
        });
      }
      this.lastX[0] = e.touches[0].clientX;
      this.lastY[0] = e.touches[0].clientY;
    }
    if (e.touches.length >= 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.sqrt(dx * dx + dy * dy) * interactStore.touchZoomSensitivity;
      if (this.lastDist !== 0) {
        const scaleFactor = dist / this.lastDist;
        const zoomOld = interactStore.zoom;
        const zoomNew = zoomOld * scaleFactor;
        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const rect = canvasStack.getBoundingClientRect();
        const canvasX = (midX - rect.left) / zoomOld;
        const canvasY = (midY - rect.top) / zoomOld;
        setInteractStore('zoom', zoomNew);
        setInteractStore('offset', {
          x: interactStore.offset.x + canvasX * (zoomOld - zoomNew),
          y: interactStore.offset.y + canvasY * (zoomOld - zoomNew),
        });
      }
      const xMove0 = e.touches[0].clientX - this.lastX[0];
      const xMove1 = e.touches[1].clientX - this.lastX[1];
      const mutualMoveX = this.getMutualMove(xMove0, xMove1);
      if (mutualMoveX !== 0 && this.lastX[0] !== 0 && this.lastX[1] !== 0) {
        setInteractStore('offset', {
          x: interactStore.offset.x + mutualMoveX,
          y: interactStore.offset.y,
        });
      }
      const yMove0 = e.touches[0].clientY - this.lastY[0];
      const yMove1 = e.touches[1].clientY - this.lastY[1];
      const mutualMoveY = this.getMutualMove(yMove0, yMove1);
      if (mutualMoveY !== 0 && this.lastY[0] !== 0 && this.lastY[1] !== 0) {
        setInteractStore('offset', {
          x: interactStore.offset.x,
          y: interactStore.offset.y + mutualMoveY,
        });
      }
      this.lastX[0] = e.touches[0].clientX;
      this.lastX[1] = e.touches[1].clientX;
      this.lastY[0] = e.touches[0].clientY;
      this.lastY[1] = e.touches[1].clientY;
      this.lastDist = dist;
    }
  }

  private handleTouchEnd(e: TouchEvent) {
    this.lastX = [0, 0];
    this.lastY = [0, 0];
    this.lastDist = 0;
  }

  private handleWheel(e: WheelEvent, canvasStack: HTMLDivElement) {
    const referencedZoom = getReferencedZoom();
    if (!referencedZoom) return;
    const delta = e.deltaY > 0 ? -interactStore.wheelZoomStep : interactStore.wheelZoomStep;

    const zoomOld = interactStore.zoom;
    const zoomNew = Math.round((interactStore.zoom + interactStore.zoom * delta) * 1000) / 1000;

    if (zoomNew < interactStore.zoomMin * referencedZoom || interactStore.zoomMax * referencedZoom < zoomNew) return;

    const rect = canvasStack.getBoundingClientRect();
    const canvasX = (e.clientX - rect.left) / zoomOld;
    const canvasY = (e.clientY - rect.top) / zoomOld;
    setInteractStore('zoom', zoomNew);
    setInteractStore('offset', {
      x: interactStore.offset.x + canvasX * (zoomOld - zoomNew),
      y: interactStore.offset.y + canvasY * (zoomOld - zoomNew),
    });
  }

  private handleMouseDown(e: MouseEvent) {
    if (e.buttons === 4 || (e.buttons === 1 && interactStore.isCtrlPressed)) {
      e.preventDefault();
      e.stopPropagation();
      setInteractStore('isDragging', true);
      this.dragPosition = { x: e.clientX, y: e.clientY };
    }
  }

  private handleMouseMove(e: MouseEvent) {
    if (e.buttons === 4 || (e.buttons === 1 && interactStore.isCtrlPressed)) {
      e.preventDefault();
      e.stopPropagation();
      if (interactStore.isDragging) {
        const dx = e.clientX - this.dragPosition.x;
        const dy = e.clientY - this.dragPosition.y;
        setInteractStore('offset', {
          x: interactStore.offset.x + dx,
          y: interactStore.offset.y + dy,
        });
        this.dragPosition = { x: e.clientX, y: e.clientY };
      }
    }
  }

  private handleMouseOff(e: MouseEvent) {
    setInteractStore('isDragging', false);
  }

  private handleKeyDown(e: KeyboardEvent) {
    if (e.ctrlKey) setInteractStore('isCtrlPressed', true);
  }

  private handleKeyUp(e: KeyboardEvent) {
    if (e.key === 'Control') setInteractStore('isCtrlPressed', false);
  }

  public setInteractListeners(wrapper: HTMLDivElement, canvasStack: HTMLDivElement) {
    wrapper.addEventListener('touchmove', (e) => this.handleTouchMove.bind(this)(e, canvasStack), { passive: true });
    wrapper.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });

    wrapper.addEventListener('wheel', (e) => this.handleWheel.bind(this)(e, canvasStack), { passive: true });

    wrapper.addEventListener('mousedown', this.handleMouseDown.bind(this));
    wrapper.addEventListener('mousemove', this.handleMouseMove.bind(this));
    wrapper.addEventListener('mouseup', this.handleMouseOff.bind(this));
    wrapper.addEventListener('mouseleave', this.handleMouseOff.bind(this));
    wrapper.addEventListener('mouseout', this.handleMouseOff.bind(this));

    window.addEventListener('keydown', this.handleKeyDown.bind(this));
    window.addEventListener('keyup', this.handleKeyUp.bind(this));
  }

  public removeInteractListeners(wrapper: HTMLDivElement, canvasStack: HTMLDivElement) {
    wrapper.removeEventListener('touchmove', (e) => this.handleTouchMove.bind(this)(e, canvasStack));
    wrapper.removeEventListener('touchend', this.handleTouchEnd.bind(this));

    wrapper.removeEventListener('wheel', (e) => this.handleWheel.bind(this)(e, canvasStack));

    wrapper.removeEventListener('mousedown', this.handleMouseDown.bind(this));
    wrapper.removeEventListener('mousemove', this.handleMouseMove.bind(this));
    wrapper.removeEventListener('mouseup', this.handleMouseOff.bind(this));
    wrapper.removeEventListener('mouseleave', this.handleMouseOff.bind(this));
    wrapper.removeEventListener('mouseout', this.handleMouseOff.bind(this));

    window.removeEventListener('keydown', this.handleKeyDown.bind(this));
    window.removeEventListener('keyup', this.handleKeyUp.bind(this));
  }
}

export default CanvasAreaInteract;
</file>

<file path="components/canvas/CanvasDebugOverlay.tsx">
import { makeTimer } from '@solid-primitives/timer';
import { Component, createSignal, Show } from 'solid-js';
import { interactStore } from '~/stores/EditorStores';
import { globalStore } from '~/stores/GlobalStores';
import {
  canvasDebugOverlayBottomLeft,
  canvasDebugOverlayTopLeft,
} from '~/styles/components/canvas/canvas_debug_overlay.css';
import { flexCol } from '~/styles/snippets.css';
import { safeInvoke } from '~/utils/TauriUtils';
import { PixelLineChart } from '../common/PixelLineChart';

interface TauriMemInfo {
  total_bytes: number;
  main_bytes: number;
  children_bytes: number;
}

const CanvasDebugOverlay: Component = (props) => {
  const toMiB = (bytes?: number): string => {
    if (bytes !== undefined) return (bytes / 1024 / 1024).toFixed(1) + ' MiB';
    else return '- MiB';
  };

  // const zoom = () => canvasStore.zoom;
  const lastMouseWindow = () => interactStore.lastMouseWindow;
  const lastMouseOnCanvas = () => interactStore.lastMouseOnCanvas;
  const [jsMemInfo, setJsMemInfo] = createSignal<any>({});
  const [processMemInfo, setProcessMemInfo] = createSignal<TauriMemInfo>();
  const callback = async () => {
    setJsMemInfo((performance as any).memory);

    const processInfo = await safeInvoke<TauriMemInfo>('get_process_memory');
    if (processInfo) {
      setProcessMemInfo(processInfo);
      // console.log(processInfo);
    }
    // console.log(`MAIN: ${toMiB(processMemInfo()?.main_bytes)}
    // CHILDREN: ${toMiB(processMemInfo()?.children_bytes)}
    // TOTAL: ${toMiB(processMemInfo()?.total_bytes)}
    // JS Heap: ${toMiB(jsMemInfo().usedJSHeapSize)} / ${toMiB(jsMemInfo().totalJSHeapSize)}`);
  };

  const disposeInterval = makeTimer(callback, 1000, setInterval);

  return (
    <>
      <div class={canvasDebugOverlayTopLeft}>
        <div class={flexCol}>
          <p>canvas.</p>
          <p>
            ON WINDOW. ({lastMouseWindow().x}, {lastMouseWindow().y})
          </p>
          <p>
            ON CANVAS. ({Math.round(lastMouseOnCanvas().x)}, {Math.round(lastMouseOnCanvas().y)})
          </p>
          <p>
            offset:({Math.round(interactStore.offset.x)}, {Math.round(interactStore.offset.y)})
          </p>
        </div>
      </div>

      <Show when={globalStore.showPerfMonitor}>
        <div class={canvasDebugOverlayBottomLeft}>
          <div class={flexCol}>
            <p>MAIN: {toMiB(processMemInfo()?.main_bytes)}</p>
            <p>CHILDREN: {toMiB(processMemInfo()?.children_bytes)}</p>
            <p>TOTAL: {toMiB(processMemInfo()?.total_bytes)}</p>
            <PixelLineChart
              width={160}
              height={60}
              color='#00ca00'
              suffix='MiB'
              fetchSample={async () => {
                const processInfo = await safeInvoke<TauriMemInfo>('get_process_memory');
                return processInfo ? processInfo.total_bytes / 1024 / 1024 : undefined;
              }}
              interval={500}
            />
          </div>
          <div class={flexCol}>
            <p>
              JS Heap: {toMiB(jsMemInfo().usedJSHeapSize)} / {toMiB(jsMemInfo().totalJSHeapSize)}
            </p>

            <PixelLineChart
              width={160}
              height={60}
              color='#f44336'
              suffix='MiB'
              fetchSample={async () => (performance as any).memory.usedJSHeapSize / 1024 / 1024}
              interval={500}
            />
          </div>
        </div>
      </Show>
    </>
  );
};

export default CanvasDebugOverlay;
</file>

<file path="components/canvas/Controls.tsx">
import styles from '@styles/components/canvas/controls.module.css';
import { Component } from 'solid-js';
import { canRedo, canUndo } from '~/controllers/layer/LayerController';
import { layerImageManager } from '~/routes/editor';
import { layerListStore } from '~/stores/ProjectStores';

const Controls: Component = () => {
  return (
    <>
      <div class={styles['top-right-nav']}>
        <img
          class={styles.undo_redo}
          src='/undo.png'
          style={{
            opacity: canUndo() ? '1.0' : '0.3',
            cursor: canUndo() ? 'pointer' : 'unset',
          }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            layerImageManager.getAgent(layerListStore.activeLayerId)?.undo();
          }}
        />
        <img
          class={styles.undo_redo}
          src='/redo.png'
          style={{
            opacity: canRedo() ? '1.0' : '0.3',
            cursor: canRedo() ? 'pointer' : 'unset',
          }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            layerImageManager.getAgent(layerListStore.activeLayerId)?.redo();
          }}
        />

        {/* <DSLEditor /> */}
      </div>
    </>
  );
};

export default Controls;
</file>

<file path="components/canvas/stacks/CanvasOverlaySVG.tsx">
import { Component, For } from 'solid-js';
import { activeLayer } from '~/controllers/layer_list/LayerListController';
import { currentTool as getCurrentTool } from '~/controllers/tool/ToolController';
import { interactStore } from '~/stores/EditorStores';
import { globalStore } from '~/stores/GlobalStores';
import { canvasStore } from '~/stores/ProjectStores';
import Tile from '~/types/Tile';

const CanvasOverlaySVG: Component<{ dirtyRects?: Tile[] }> = (props) => {
  const borderWidth = () => canvasStore.canvas.width * interactStore.zoom;
  const borderHeight = () => canvasStore.canvas.height * interactStore.zoom;

  const zoomedPenSize = () => getCurrentTool().size * interactStore.zoom;

  const dirtyRects = () => (globalStore.showDirtyRects ? props.dirtyRects : []);

  return (
    <svg
      viewBox={`0 0 ${borderWidth()} ${borderHeight()}`}
      xmlns='http://www.w3.org/2000/svg'
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        'pointer-events': 'none',
        'image-rendering': 'pixelated',
        'z-index': 1000,
      }}
    >
      {/* border rect */}
      <rect
        width={borderWidth()}
        height={borderHeight()}
        fill='none'
        stroke='black'
        stroke-width={1}
        pointer-events='none'
      />

      {/* pen hover preview */}
      <rect
        width={zoomedPenSize()}
        height={zoomedPenSize()}
        x={Math.round(interactStore.lastMouseOnCanvas.x * interactStore.zoom) - zoomedPenSize() / 2}
        y={Math.round(interactStore.lastMouseOnCanvas.y * interactStore.zoom) - zoomedPenSize() / 2}
        fill='none'
        stroke='black'
        stroke-width={1}
        pointer-events='none'
      />

      <For each={dirtyRects()}>
        {(dirtyRect) => {
          return (
            <rect
              width={dirtyRect.globalTileSize * activeLayer()?.dotMagnification * interactStore.zoom}
              height={dirtyRect.globalTileSize * activeLayer()?.dotMagnification * interactStore.zoom}
              x={dirtyRect.getOffset().x * activeLayer()?.dotMagnification * interactStore.zoom}
              y={dirtyRect.getOffset().y * activeLayer()?.dotMagnification * interactStore.zoom}
              fill={dirtyRect.isDirty ? '#ff000060' : '#00ffff60'}
              stroke='none'
              pointer-events='none'
            />
          );
        }}
      </For>
    </svg>
  );
};

export default CanvasOverlaySVG;
</file>

<file path="components/canvas/stacks/CanvasStack.tsx">
import { Component, createEffect, createSignal, For, onMount } from 'solid-js';
import LayerCanvasOperator from '~/controllers/canvas/LayerCanvasOperator';
import TileLayerImageAgent from '~/models/layer_image/agents/TileLayerImageAgent';
import CanvasOverlaySVG from './CanvasOverlaySVG';
import { LayerCanvas, LayerCanvasRef } from './LayerCanvas';
import { TouchableCanvas } from './TouchableCanvas';

import { activeLayer, allLayers } from '~/controllers/layer_list/LayerListController';
import { layerImageManager } from '~/routes/editor';
import { canvasStack } from '~/styles/components/canvas/canvas_stack.css';
import Tile from '~/types/Tile';
import { canvasStore } from '~/stores/ProjectStores';

const CanvasStack: Component = () => {
  const layerCanvasRefs: {
    [id: string]: LayerCanvasRef;
  } = {};

  const [dirtyRects, setDirtyRects] = createSignal<Tile[]>();

  const activeCanvasRef = () => {
    const active = activeLayer();

    if (active) return layerCanvasRefs[active.id];
    else return undefined;
  };

  onMount(() => {
    window.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'z') {
        const active = activeLayer();
        if (active) {
          const agent = layerImageManager.getAgent(active.id);
          agent?.undo();
        }
      } else if (e.ctrlKey && e.key === 'y') {
        const active = activeLayer();
        if (active) {
          const agent = layerImageManager.getAgent(active.id);
          agent?.redo();
        }
      }
    });
  });

  createEffect(() => {
    const active = activeLayer();
    if (active) {
      const agent = layerImageManager.getAgent(active.id);
      if (!agent) return;
      agent.setOnDrawingBufferChangeListener('stack_dirty_rect', () => {
        setDirtyRects([...getDirtyRects()]);
      });
      agent.setOnImageChangeListener('stack_dirty_rect', () => {
        setDirtyRects([...getDirtyRects()]);
      });
    }
  });

  const getDirtyRects = () => {
    const active = activeLayer();
    if (active) {
      const agent = layerImageManager.getAgent(active.id);
      if (agent instanceof TileLayerImageAgent) {
        return (agent as TileLayerImageAgent).getDirtyTilesInAction();
      }
    }
    return [];
  };

  return (
    <div
      style={{
        position: 'relative',
      }}
    >
      <div
        class={canvasStack}
        style={{
          width: `${canvasStore.canvas.width}px`,
          height: `${canvasStore.canvas.height}px`,
        }}
      >
        <TouchableCanvas operator={new LayerCanvasOperator(() => activeCanvasRef()!)} />

        <For each={allLayers()}>
          {(layer, index) => (
            <LayerCanvas ref={layerCanvasRefs[layer.id]} layer={layer} zIndex={allLayers().length - index()} />
          )}
        </For>
      </div>

      <CanvasOverlaySVG dirtyRects={dirtyRects()} />
    </div>
  );
};

export default CanvasStack;
</file>

<file path="components/canvas/stacks/LayerCanvas.tsx">
import { Component, createRenderEffect, onMount, Ref } from 'solid-js';
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';

import { LayerImageManager } from '~/models/layer_image/LayerImageManager';
import { layerImageManager } from '~/routes/editor';
import { canvasStore } from '~/stores/ProjectStores';
import { layerCanvas } from '~/styles/components/canvas/layer_canvas.css';
import { Layer } from '~/types/Layer';

type Props = {
  ref?: LayerCanvasRef;
  layer: Layer;
  zIndex: number;
};

export type LayerCanvasRef = {
  getLayer: () => Layer;
  getManager: () => LayerImageManager;
  getAgent: () => LayerImageAgent;
};

export const LayerCanvas: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;

  const agent = () => layerImageManager.getAgent(props.layer.id);

  createRefContent(
    () => props.ref,
    () => ({
      getLayer() {
        return props.layer;
      },
      getAgent() {
        return agent();
      },
    })
  );

  const styleWidth = () => canvasStore.canvas.width;
  const styleHeight = () => canvasStore.canvas.height;
  const internalWidth = () => canvasStore.canvas.width / props.layer.dotMagnification;
  const internalHeight = () => canvasStore.canvas.height / props.layer.dotMagnification;

  onMount(() => {
    let agent = layerImageManager.getAgent(props.layer.id);
    const ctx = canvasRef?.getContext('2d');

    if (ctx) agent?.putImageIntoForce(ctx);

    agent?.setOnImageChangeListener('layercanvas_refresh_' + props.layer.id, () => {
      if (ctx) agent.putImageIntoForce(ctx);
    });
    agent?.setOnDrawingBufferChangeListener('layercanvas_refresh_' + props.layer.id, () => {
      if (ctx) agent.putDrawingBufferIntoForce(ctx);
    });
  });

  return (
    <canvas
      ref={(el) => {
        canvasRef = el;
      }}
      id={`canvas-${props.layer.id}`}
      data-layer-id={props.layer.name}
      class={layerCanvas}
      width={internalWidth()}
      height={internalHeight()}
      style={{
        position: 'absolute',
        width: `${styleWidth()}px`,
        height: `${styleHeight()}px`,
        'image-rendering': 'pixelated',
        'z-index': props.zIndex,
        opacity: props.layer.enabled ? 1 : 0,
      }}
    />
  );
};

function createRefContent<T extends Exclude<unknown, Function>>(getRef: () => Ref<T>, createRef: () => T) {
  createRenderEffect(() => {
    const refProp = getRef();
    if (typeof refProp !== 'function') {
      throw new Error('Should never happen, as solid always passes refs as functions');
    }

    const refFunc = refProp as (value: T) => void;

    refFunc(createRef());
  });
}
</file>

<file path="components/canvas/stacks/TouchableCanvas.tsx">
import { Component, createEffect, createSignal, onCleanup, onMount } from 'solid-js';
import LayerCanvasOperator from '~/controllers/canvas/LayerCanvasOperator';
import { interactStore, setInteractStore } from '~/stores/EditorStores';
import { canvasStore } from '~/stores/ProjectStores';
import { DrawState } from '~/types/DrawState';
import { Vec2 } from '~/types/Vector';

interface Props {
  operator: LayerCanvasOperator;
}

// レイヤーごとのキャンバスの上でタッチイベントを受けるだけのキャンバス
export const TouchableCanvas: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;

  const styleWidth = () => canvasStore.canvas.width;
  const styleHeight = () => canvasStore.canvas.height;

  const [lastPos, setLastPos] = createSignal<Vec2 | undefined>(undefined);
  const [temporaryOut, setTemporaryOut] = createSignal(false);

  function getOffset() {
    const rect = canvasRef!.getBoundingClientRect();
    return { x: rect.left, y: rect.top };
  }

  function getWindowMousePosition(e: MouseEvent | PointerEvent | TouchEvent) {
    let x = 0;
    let y = 0;

    if ('clientX' in e && 'clientY' in e) {
      x = e.clientX;
      y = e.clientY;
    } else if ('touches' in e && e.touches.length > 0) {
      console.log('touch');
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }
    return { x, y };
  }

  function getCanvasMousePosition(e: MouseEvent | PointerEvent | TouchEvent) {
    const offset = getOffset();

    let x = 0;
    let y = 0;

    if ('clientX' in e && 'clientY' in e) {
      x = e.clientX;
      y = e.clientY;
    } else if ('touches' in e && e.touches.length > 0) {
      console.log('touch');
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }

    const zoom = interactStore.zoom;

    return {
      x: (x - offset.x) / zoom,
      y: (y - offset.y) / zoom,
    };
  }

  function isDrawableClick(e: PointerEvent): boolean {
    if (e.pointerType === 'touch' || interactStore.isCtrlPressed) return false;
    // right=1, left=2, middle=4
    // console.log(e.buttons)
    if (e.pointerType === 'mouse' && e.buttons !== 1) return false;

    return true;
  }

  function handlePointerDown(e: PointerEvent) {
    if (!isDrawableClick(e)) return;

    const position = getCanvasMousePosition(e);
    props.operator.handleDraw(DrawState.start, position, lastPos());
    setInteractStore('isInStroke', true);
    setLastPos(position);
  }

  function handlePointerCancel(e: PointerEvent) {
    console.warn('pointercancel', e);
    endStroke(getCanvasMousePosition(e));
  }

  function handlePointerMove(e: PointerEvent) {
    const windowPosition = getWindowMousePosition(e);
    const position = getCanvasMousePosition(e);
    setInteractStore('lastMouseWindow', windowPosition);
    setInteractStore('lastMouseOnCanvas', position);

    if (!isDrawableClick(e)) return;

    // 押したまま外に出てから戻ってきたときはそこから再開
    if (temporaryOut()) {
      setTemporaryOut(false);
      setInteractStore('isInStroke', true);
      setLastPos(position);
    }
    if (!interactStore.isInStroke || !lastPos()) return;

    props.operator.handleDraw(DrawState.move, position, lastPos());
    setLastPos(position);
  }

  function handlePointerUp(e: PointerEvent) {
    const position = getCanvasMousePosition(e);
    if (interactStore.isInStroke) endStroke(position);
  }

  function handlePointerOut(e: PointerEvent) {
    // 出た時点でストロークを切る場合
    // const position = getCanvasMousePosition(e);
    // if (interactStore.isInStroke) endStroke(position);

    // 出た時点でも押したままキャンバス内に戻ってきたらストロークを再開する場合
    if (interactStore.isDragging) {
      const position = getCanvasMousePosition(e);
      props.operator.handleDraw(DrawState.move, position, lastPos());
      setTemporaryOut(true);
    }
  }

  function handleWheel(e: WheelEvent) {
    const windowPosition = getWindowMousePosition(e);
    const position = getCanvasMousePosition(e);
    setInteractStore('lastMouseWindow', windowPosition);
    setInteractStore('lastMouseOnCanvas', position);
  }

  function endStroke(position: Vec2) {
    props.operator.handleDraw(DrawState.end, position, lastPos());
    setInteractStore('isInStroke', false);
    setLastPos(undefined);
    setTemporaryOut(false);
  }

  onMount(() => {
    window.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointercancel', handlePointerCancel);
    window.addEventListener('wheel', handleWheel);
  });

  onCleanup(() => {
    window.removeEventListener('pointerup', handlePointerUp);
    window.removeEventListener('pointermove', handlePointerMove);
    window.removeEventListener('pointercancel', handlePointerCancel);
    window.removeEventListener('wheel', handleWheel);
  });

  createEffect(() => {
    if (canvasRef)
      setInteractStore('canvasElementSize', {
        width: canvasRef.clientWidth,
        height: canvasRef.clientHeight,
      });
  });

  return (
    <canvas
      ref={(el) => {
        canvasRef = el;
      }}
      width={canvasStore.canvas.width}
      height={canvasStore.canvas.height}
      onPointerDown={handlePointerDown}
      onPointerOut={handlePointerOut}
      style={{
        'touch-action': 'none',
        width: `${styleWidth()}px`,
        height: `${styleHeight()}px`,
        'pointer-events': 'all',
        'z-index': '100', // どのレイヤーよりも上だが、image poolよりも下
      }}
    />
  );
};
</file>

<file path="components/common/Checkbox.tsx">
import { Component } from 'solid-js';
import { checkboxWrapper, customCheckbox, hiddenCheckbox } from '~/styles/components/checkbox.css';

const Checkbox: Component<{
  label?: string;
  checked?: boolean;
  onChange?: (checked: boolean) => void;
  inputRef?: (el: HTMLInputElement) => void;
}> = (props) => {
  return (
    <label class={checkboxWrapper}>
      <input
        class={hiddenCheckbox}
        type='checkbox'
        checked={props.checked}
        onChange={(e) => props.onChange?.(e.currentTarget.checked)}
        ref={props.inputRef}
      />
      <span class={customCheckbox}></span>
      {props.label}
    </label>
  );
};

export default Checkbox;
</file>

<file path="components/common/ColorBox.tsx">
import { Component } from 'solid-js';
import { currentColor } from '~/controllers/color/ColorController';
import { sayRandomQuote } from './companion/QuotePool';

interface ColorBoxProps {
  class?: string;
  enableUsingSelection?: boolean;
  sizePx?: number;
  color: string;
  onClick?: (color: string) => void;
}

const ColorBox: Component<ColorBoxProps> = (props: ColorBoxProps) => {
  const size = () => props.sizePx || 10;

  const isSelected = () => props.enableUsingSelection && currentColor() === props.color;
  const isWhiteOrNone = () => props.color === 'none' || props.color.toLowerCase() === '#ffffff';

  const onColorClicked = (color: string) => {
    sayRandomQuote('color-pick', { color: color });
    if (props.onClick) props.onClick(color);
  };

  return (
    <div class={props.class}>
      <div
        style={{
          position: 'relative',
          display: 'flex',
          width: `${size()}px`,
          height: `${size()}px`,
          'align-items': 'center',
          'justify-content': 'center',
          cursor: 'pointer',
          'background-color': props.color,
          border: isWhiteOrNone() || isSelected() ? '0.05rem solid black' : '0.05rem solid transparent',
        }}
        onClick={() => {
          onColorClicked(props.color);
        }}
      >
        {props.enableUsingSelection && isSelected() && (
          <div
            style={{
              width: `${Math.round(size() / 3)}px`,
              height: `${Math.round(size() / 3)}px`,
              margin: 0,
              padding: 0,
              'background-color': props.color !== '#000000' ? 'black' : 'white',
            }}
            onClick={() => {
              onColorClicked(props.color);
            }}
          />
        )}
      </div>
    </div>
  );
};

export default ColorBox;
</file>

<file path="components/common/companion/Companion.tsx">
// import { Component, createEffect, createSignal } from 'solid-js';
// import styles from '@styles/components/companion.module.css';

// const [sayRequest, setSayRequest] = createSignal<string | null>(null);

// export const CompanionEvents = {
//   sayRequest,
//   setSayRequest,
// };

// const Companion: Component = () => {
//   const [quote, setQuote] = createSignal('');

//   const say = (text: string) => {
//     window.speak?.(text, {
//       amplitude: 5,
//       pitch: 10,
//       speed: 200,
//       wordgap: 0,
//     });
//   };

//   createEffect(() => {
//     const message = CompanionEvents.sayRequest();
//     if (message) {
//       say(message);
//       setQuote(message);
//       const element = document.getElementById('companion');
//       setTimeout(() => {
//         setQuote('');
//         if (element) element.className = element.className.replace(` ${styles['giggle']}`, '');
//       }, 5000);
//       window.requestAnimationFrame(function (time) {
//         window.requestAnimationFrame(function (time) {
//           if (element) element.className += ` ${styles['giggle']}`;
//         });
//       });
//       CompanionEvents.setSayRequest(null); // 一度で消費
//     }
//   });

//   return (
//     <div class={styles.root}>
//       <div class={styles.wrapper}>
//         <div class={styles.companion} id='companion'>
//           <img src='/companion.png' alt='you challenge me?' />
//         </div>
//         {quote() && (
//           <div class={styles.quote_box_container}>
//             <div class={styles.quote_box}>
//               <p class={styles.quote}>{quote()}</p>
//             </div>
//           </div>
//         )}
//       </div>
//       <div id='audio' />
//     </div>
//   );
// };

// let lastSpoke = 0;
// export const smartSay = (text: string): boolean => {
//   const now = Date.now();
//   if (now - lastSpoke > 5000) {
//     CompanionEvents.setSayRequest(text);
//     lastSpoke = now;
//     return true;
//   }
//   return false;
// };

// export default Companion;
</file>

<file path="components/common/companion/QuotePool.ts">
// import { smartSay } from './Companion';

type QuoteCategory = 'color-pick' | 'pen-resize' | 'canvas-resize' | 'undo-spam' | 'random';

const lastSaidIndexes = {
  'color-pick': -1,
  'pen-resize': -1,
  'canvas-resize': -1,
  'undo-spam': -1,
  random: -1,
};
export const quotePool = {
  'color-pick': [
    'That color again? You really love it, huh.',
    'A fine choice, but not the finest.',
    "I see you're going with [color]. Bold.",
  ],
  'pen-resize': [
    'Hmm, Not quite my size.',
    "Go bigger, I'll crash 'em harder.",
    'Have you ever heard of the word "pixel perfect"?',
  ],
  'canvas-resize': ['Shrinking the canvas? Afraid of commitment?', 'Small canvas, big ideas. I like it.'],
  'undo-spam': ['UNDO UNDO UNDO—are you OK?', "That's the 5th undo. I’m getting dizzy."],
  random: ['Daisy, Daisy, give me your answer do do do'],
};

export const sayRandomQuote = (category: QuoteCategory, context?: any) => {
  const quotes = quotePool[category];
  let index = Math.floor(Math.random() * quotes.length);
  // 前になんか言った
  if (lastSaidIndexes[category] != -1) {
    console.log(`I previously said ${lastSaidIndexes[category]}. try saying something new.`);
    if (quotes.length == 1) {
      console.log(`argh. nothing to say.`);
      // もう言えることない
      return '';
    } else {
      // console.log(`how about this?. ${index}`);
      // あるなら抽選続ける
      while (index === lastSaidIndexes[category]) {
        index = Math.floor(Math.random() * quotes.length);
        // console.log(`NO. how about this?. ${index}`);
      }
      console.log(`yeah. ${index} is a brand new. let's say it.`);
    }
  }
  let quote = quotes[index];
  quote = context?.color ? quote.replace('[color]', context.color) : quote;
  // if (smartSay(quote)) {
  //   console.log(`◯ yay!`);
  //   lastSaidIndexes[category] = index;
  // } else {
  //   console.log(`✕ hmm maybe I'd keep silence now?`);
  // }
};
</file>

<file path="components/common/Dropdown.tsx">
import { JSX, For } from 'solid-js';
import { dropdownRoot } from '~/styles/components/dropdown.css';

export type DropdownOption<T extends string | number> = {
  label: string;
  value: T;
};

interface Props<T extends string | number = string> {
  value: T | (() => T);
  selected: T | (() => T);
  /** 選択候補 */
  options: DropdownOption<T>[];
  /** 値変更時に呼び出される */
  onChange?: (value: T) => void;
  /** aria-label など任意で渡す */
  props?: JSX.SelectHTMLAttributes<HTMLSelectElement>;
}

const Dropdown = <T extends string | number>(p: Props<T>) => {
  const getValue = () => (typeof p.value === 'function' ? (p.value as () => T)() : p.value);

  return (
    <select
      {...p.props}
      class={dropdownRoot}
      value={String(getValue())}
      onChange={(e) => p.onChange?.(e.currentTarget.value as unknown as T)}
    >
      <For each={p.options}>
        {(o) => (
          <option selected={p.selected === o.value} value={String(o.value)}>
            {o.label}
          </option>
        )}
      </For>
    </select>
  );
};

export default Dropdown;
</file>

<file path="components/common/DSLButton.tsx">
import { Component } from 'solid-js';
import styles from '@styles/components/dsl_button.module.css';

interface Props {
  onClick?: (e: MouseEvent) => {};
}

const DSLButton: Component<Props> = (props: Props) => {
  return (
    <div
      class={styles.root}
      onMouseOver={(e) => {
        e.preventDefault();
        e.stopPropagation();
      }}
      onClick={(e) => {
        if (props.onClick) props.onClick(e);
      }}
    >
      <img src='/DSL.png' />
    </div>
  );
};

export default DSLButton;
</file>

<file path="components/common/LayerPreview.tsx">
import styles from '@styles/components/layer_preview.module.css';
import { Component, onMount } from 'solid-js';
import { getImageOf, layerImageManager } from '~/routes/editor';
import { Layer } from '~/types/Layer';

interface Props {
  layer: Layer;
  maxWidth?: number;
  maxHeight?: number;
  onClick?: () => void;
}

const LayerPreview: Component<Props> = (props: Props) => {
  let wrapperRef: HTMLDivElement;
  let canvasRef: HTMLCanvasElement;

  const updatePreview = (originalImage: ImageData, targetHeight: number) => {
    const aspectRatio = originalImage.width / originalImage.height;
    const targetWidth = Math.round(targetHeight * aspectRatio);

    // 描画対象キャンバスの解像度とCSSサイズを一致させる
    canvasRef.width = targetWidth;
    canvasRef.height = targetHeight;

    const maxWidth = props.maxWidth;
    const maxHeight = props.maxHeight;
    let zoom = 1;
    if (maxWidth && targetWidth > maxWidth) zoom = maxWidth / targetWidth;
    if (maxHeight && targetHeight > maxHeight && zoom < maxHeight / targetHeight) zoom = maxHeight / targetHeight;

    canvasRef.style.width = `${targetWidth * zoom}px !important`;
    canvasRef.style.height = `${targetHeight * zoom}px !important`;

    wrapperRef.style.width = `${targetWidth * zoom}px !important`;
    wrapperRef.style.height = `${targetHeight * zoom}px !important`;

    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = originalImage.width;
    tmpCanvas.height = originalImage.height;
    tmpCanvas.getContext('2d')!.putImageData(originalImage, 0, 0);

    const ctx = canvasRef.getContext('2d')!;
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, targetWidth, targetHeight);

    ctx.drawImage(tmpCanvas, 0, 0, originalImage.width, originalImage.height, 0, 0, targetWidth, targetHeight);
  };

  onMount(() => {
    const height = wrapperRef.clientHeight;
    const currentImage = getImageOf(props.layer.id);

    let agent = layerImageManager.getAgent(props.layer.id);
    if (currentImage) {
      agent?.setImage(currentImage, true);
      updatePreview(currentImage, height);
    }
    agent?.setOnImageChangeListener('layer_prev_' + props.layer.id, () => {
      const img = getImageOf(props.layer.id);
      if (img) updatePreview(img, height);
    });
  });

  return (
    <div ref={(el) => (wrapperRef = el)}>
      <canvas
        class={styles.canvas}
        ref={(el) => (canvasRef = el)}
        onClick={(e) => {
          if (props.onClick) props.onClick();
        }}
      />
    </div>
  );
};

export default LayerPreview;
</file>

<file path="components/common/Light.tsx">
import { Component, Show } from 'solid-js';
import styles from '@styles/components/light.module.css';

interface LightProps {
  class?: string;
  on?: boolean;
}

const Light: Component<LightProps> = (props: LightProps) => {
  const width = 8;
  const height = 8;
  const radius = 2;

  return (
    <svg
      class={props.class}
      style={{
        width: `${width}px`,
        height: `${height}px`,
        overflow: 'visible',
      }}
      viewBox={`0 0 ${width} ${height}`}
      xmlns='http://www.w3.org/2000/svg'
    >
      <Show when={true}>
        <g class={`${styles['light-inner']} ${props.on && styles['on']}`}>
          <circle cx={width / 2} cy={height / 2} r={radius} fill='red' />
        </g>
      </Show>
    </svg>
  );
};

export default Light;
</file>

<file path="components/common/PixelLineChart.tsx">
import { Component, createSignal, onCleanup, onMount } from 'solid-js';

interface PixelLineChartProps {
  /** 横ピクセル数＝バッファ長 */
  width: number;
  /** 縦ピクセル数 */
  height: number;
  /** 新しいサンプルを返す非同期関数 */
  fetchSample: () => Promise<number | undefined>;
  /** ミリ秒 */
  interval?: number;
  /** 線の色 */
  color?: string;
  suffix?: string;
  initialMaxValue?: number;
}

export const PixelLineChart: Component<PixelLineChartProps> = (props) => {
  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  // width ピクセル分のバッファをゼロ埋め
  const buffer: number[] = Array(props.width).fill(0);
  const [lastBuffer, setLastBuffer] = createSignal<number | undefined>(-1);
  const [maxValue, setMaxValue] = createSignal(1);

  onMount(() => {
    ctx = canvas.getContext('2d')!;
    // ピクセルパーフェクトを狙うなら、実際の canvas.width/height と CSSサイズを同じに
    canvas.width = props.width;
    canvas.height = props.height;

    // 描画関数：バッファ全部を１ドットずつ打っていく
    const draw = () => {
      // クリア
      ctx.clearRect(0, 0, props.width, props.height);
      ctx.fillStyle = props.color || 'lime';

      for (let x = 0; x < buffer.length; x++) {
        // 0〜maxValue を 0〜(height-1) に丸め込む
        const q = Math.round((buffer[x] / maxValue()) * (props.height - 1));
        // 底辺を y=height-1 として上向きに描画
        const y = props.height - 1 - q;
        ctx.fillRect(x, y, 1, 1);
      }
    };

    // 定期取得＋描画ループ
    const iv = setInterval(async () => {
      try {
        const v = await props.fetchSample();
        buffer.shift();
        buffer.push(v ?? 0);
        setLastBuffer(v ? Math.round(v * 10) / 10 : undefined);
        // バッファ全体の現在最大値を取得し、1.5倍してスケール更新
        const bufMax = Math.max(...buffer);
        // 0除算防止 & 少なくとも initialMaxValue 以上にはする
        const newMax = Math.max(bufMax * 1.5, props.initialMaxValue ?? 0);
        setMaxValue(Math.round(newMax * 10) / 10);
        draw();
      } catch {
        // 無視
      }
    }, props.interval ?? 1000);

    // マウント解除時に止める
    onCleanup(() => clearInterval(iv));
  });

  return (
    <div
      style={{
        position: 'relative',
        width: `${props.width}px`,
        height: `${props.height}px`,
        background: '#00000017',
        border: '1px solid #aaa',
      }}
    >
      <canvas
        ref={(el) => (canvas = el)}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          // 拡大時にもドットがにじまないように
          'image-rendering': 'pixelated',
          // 必要なら表示を大きくする
          width: `${props.width}px`,
          height: `${props.height}px`,
        }}
      />
      <p style={{ position: 'absolute', top: '0px', left: '4px' }}>{maxValue()}</p>
      <p style={{ position: 'absolute', bottom: '0px', left: '4px' }}>{0}</p>
      <p style={{ position: 'absolute', top: '0px', right: '4px' }}>
        {lastBuffer()} {props.suffix}
      </p>
    </div>
  );
};
</file>

<file path="components/common/RadioButton.tsx">
import { Component } from 'solid-js';
import { customRadio, hiddenRadio, radioWrapper } from '~/styles/components/radio_button.css';

const RadioButton: Component<{ label?: string; name: string }> = (props) => {
  return (
    <label class={radioWrapper}>
      {props.label}
      <input class={hiddenRadio} type='radio' name={props.name} />
      <span class={customRadio}></span>
    </label>
  );
};

export default RadioButton;
</file>

<file path="components/common/Slider.tsx">
import { Component, createSignal } from 'solid-js';
import styles from '@styles/components/slider.module.css';

interface SliderProps {
  min: number;
  max: number;
  default: number;
  allowFloat?: boolean;

  onValueChanged?: (newValue: number) => void;
}

const Slider: Component<SliderProps> = (props) => {
  let sliderRef: HTMLDivElement | undefined;
  const [isDrag, setDrag] = createSignal(false);
  const [value, setValue] = createSignal(props.default);

  const percent = () => ((value() - props.min) / (props.max - props.min)) * 100;

  const handlePointerDown = (e: PointerEvent) => {
    setDrag(true);

    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);
  };

  const handlePointerMove = (e: PointerEvent) => {
    if (!sliderRef || !isDrag()) return;
    const rect = sliderRef.getBoundingClientRect();
    let pos = e.clientX - rect.left;
    pos = Math.max(0, Math.min(pos, rect.width)); // clamp

    const newValueRaw = props.min + (pos / rect.width) * (props.max - props.min);
    const newValue = props.allowFloat ? newValueRaw : Math.round(newValueRaw);
    setValue(newValue);
    if (props.onValueChanged) props.onValueChanged(newValue);
  };

  const handlePointerUp = (e: PointerEvent) => {
    setDrag(false);
    window.removeEventListener('pointermove', handlePointerMove);
    window.removeEventListener('pointerup', handlePointerUp);
  };

  const onLineClick = (e: MouseEvent) => {
    if (!sliderRef) return;
    const rect = sliderRef.getBoundingClientRect();
    let pos = e.clientX - rect.left;
    pos = Math.max(0, Math.min(pos, rect.width)); // clamp

    const newValueRaw = props.min + (pos / rect.width) * (props.max - props.min);
    const newValue = props.allowFloat ? newValueRaw : Math.round(newValueRaw);
    setValue(newValue);
    if (props.onValueChanged) props.onValueChanged(newValue);
  };

  return (
    <div class={styles.root}>
      <div class={styles.slider} ref={sliderRef}>
        <div class={styles['line-hitbox']} onPointerDown={handlePointerDown} onClick={onLineClick}>
          <div class={styles.line} />
        </div>
        <div style={{ left: `${percent()}%` }} class={styles.handle} />
      </div>
    </div>
  );
};

export default Slider;
</file>

<file path="components/common/ToggleSwitch.tsx">
import { Component } from 'solid-js';
import { toggleInput, toggleThumb, toggleTrack, toggleWrapper } from '~/styles/components/toggle_switch.css';

interface Props {
  checked: boolean;
  onChange?: (checked: boolean) => void;
  /** 任意でラベル等を配置する場合の slot */
  children?: any;
}

const ToggleSwitch: Component<Props> = (p) => (
  /* label 全体でクリック可能に */
  <label class={toggleWrapper}>
    {p.children}
    <input
      type='checkbox'
      checked={p.checked}
      onInput={(e) => p.onChange?.(e.currentTarget.checked)}
      class={toggleInput}
    />
    <span class={toggleTrack}>
      <span class={toggleThumb} />
    </span>
  </label>
);

export default ToggleSwitch;
</file>

<file path="components/global/BottomInfo.tsx">
import { Component } from 'solid-js';
import { AboutWindowOptions } from '~/routes/about';
import { interactStore, logStore } from '~/stores/EditorStores';

import { bottomInfoRoot, bottomInfoText as bottomInfoTextStyle } from '~/styles/components/bottom_info.css';
import { openSingletonWindow } from '~/utils/windowUtils';

const BottomInfo: Component = () => {
  return (
    <div class={bottomInfoRoot}>
      <a
        class={bottomInfoTextStyle}
        style={{ 'pointer-events': 'all', cursor: 'pointer' }}
        onClick={() => openSingletonWindow('about', AboutWindowOptions)}
      >
        sledge.
      </a>
      <p class={bottomInfoTextStyle}>x{interactStore.zoom}</p>
      <p class={bottomInfoTextStyle}>{logStore.bottomBarText}</p>
    </div>
  );
};

export default BottomInfo;
</file>

<file path="components/global/EdgeInfo.tsx">
import { Component } from 'solid-js';
import { loadGlobalSettings } from '~/io/global_config/globalSettings';
import { SettingsWindowOptions } from '~/routes/settings';

import { edgeInfoItem, edgeInfoRoot, edgeInfoText } from '~/styles/components/edge_info.css';
import { openSingletonWindow } from '~/utils/windowUtils';

const EdgeInfo: Component = () => {
  return (
    <div class={edgeInfoRoot}>
      <div class={edgeInfoItem}>
        <a
          class={edgeInfoText}
          onClick={async () => {
            let win = await openSingletonWindow('settings', SettingsWindowOptions);
            win.once('tauri://destroyed', (e) => {
              loadGlobalSettings();
            });
          }}
        >
          settings.
        </a>
      </div>
      {/* <p class={sideAreaEdgeText}>{projectStore.name || "name N/A"}</p> */}
    </div>
  );
};

export default EdgeInfo;
</file>

<file path="components/global/SideSections.tsx">
import { Component } from 'solid-js';
import CanvasSettings from '../section/CanvasSettings';
import Color from '../section/Color';
import LayerList from '../section/LayerList';
import Project from '../section/Project';
import ToolConfig from '../section/ToolConfig';

import { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';
import { sideAreaContent } from '~/styles/components/side_sections.css';

const SideSections: Component = () => {
  return (
    <div class={sideAreaContent}>
      <a onClick={() => getCurrentWebviewWindow().close()}>&lt; back</a>
      <Project />
      <Color />
      <ToolConfig />
      <LayerList />
      <CanvasSettings />
    </div>
  );
};

export default SideSections;
</file>

<file path="components/global/TitleBar.tsx">
import { getCurrentWindow } from '@tauri-apps/api/window';
import { createEffect, createSignal, onMount } from 'solid-js';
import { projectStore } from '~/stores/ProjectStores';
import {
  titleBarControlButtonImg,
  titleBarControlCloseButton,
  titleBarControlMaximizeButton,
  titleBarControlMinimizeButton,
  titleBarControls,
  titleBarRoot,
  titleBarTitle,
} from '~/styles/components/title_bar.css';

export default function TitleBar() {
  const window = getCurrentWindow();

  const [isMaximizable, setIsMaximizable] = createSignal(true);
  const [isMinimizable, setIsMinimizable] = createSignal(true);
  const [isClosable, setIsClosable] = createSignal(true);
  const [isEditor, setIsEditor] = createSignal(false);
  const [title, setTitle] = createSignal('');
  const [isMaximized, setMaximized] = createSignal(false);

  onMount(async () => {
    setIsMaximizable(await window.isMaximizable());
    setIsMinimizable(await window.isMinimizable());
    setIsClosable(await window.isClosable());
    setTitle(await window.title());
    setIsEditor(window.label.startsWith('editor'));
    // if (isEditor()) {
    //   setTitle(`${projectStore.name} - ${projectStore.path}`);
    // }
  });

  window.onResized(async (handler) => {
    setMaximized(await window.isMaximized());
  });

  createEffect(() => {
    if (isEditor()) {
      let pathText = '';
      let isSavedText = '';
      if (projectStore.path !== undefined && projectStore.path !== '') {
        pathText += projectStore.isProjectChangedAfterSave ? '(unsaved)' : '';
        pathText += ' - ' + projectStore.path;
      } else {
        pathText += '(not saved yet)';
      }

      setTitle(`${projectStore.name} ${pathText} `);
    }
  });

  const borderWindowLabels: string[] = ['editor'];
  const shouldShowBorder = () => borderWindowLabels.find((l) => l === window.label);

  return (
    <header
      style={{
        'pointer-events': 'all',
        'border-bottom': shouldShowBorder() ? '1px solid #aaa' : 'none',
      }}
    >
      <nav class={titleBarRoot} data-tauri-drag-region='p, button'>
        <p class={titleBarTitle}>{title()}.</p>
        <div class={titleBarControls}>
          {isMinimizable() && (
            <button class={titleBarControlMinimizeButton} onClick={() => window.minimize()}>
              <img class={titleBarControlButtonImg} src={'/minimize.png'} />
            </button>
          )}
          {isMaximizable() && (
            <button class={titleBarControlMaximizeButton} onClick={() => window.toggleMaximize()}>
              <img class={titleBarControlButtonImg} src={isMaximized() ? '/leave_maximize.png' : '/maximize.png'} />
            </button>
          )}
          {isClosable() && (
            <button class={titleBarControlCloseButton} onClick={() => window.close()}>
              <img class={titleBarControlButtonImg} src={'/close.png'} />
            </button>
          )}
        </div>
      </nav>
    </header>
  );
}
</file>

<file path="components/section/CanvasSettings.tsx">
import { Component, createSignal } from 'solid-js';
import { adjustZoomToFit } from '~/controllers/canvas/CanvasController';
import { resetLayerImage } from '~/controllers/layer/LayerController';
import { canvasStore, layerListStore, setCanvasStore } from '~/stores/ProjectStores';

import { canvasSizeButton, canvasSizeForm, canvasSizeInput, canvasSizeLabel } from '~/styles/section/canvas.css';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/section_global.css';
import { Consts } from '~/utils/consts';

const CanvasSettings: Component = () => {
  const [width, setWidth] = createSignal(canvasStore.canvas.width);
  const [height, setHeight] = createSignal(canvasStore.canvas.height);

  const changeCanvasSize = (e: any) => {
    e.preventDefault();
    setCanvasStore('canvas', 'width', width());
    setCanvasStore('canvas', 'height', height());

    changeCanvasSize({ width: width(), height: height() });

    console.log(`canvas size changed. ${width()} x ${height}`);

    adjustZoomToFit(width(), height());
  };

  const resetAllLayers = (e: any) => {
    layerListStore.layers.forEach((l) => {
      resetLayerImage(l.id, l.dotMagnification);
    });
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>canvas.</p>

      <form
        class={sectionContent}
        onSubmit={(e) => {
          changeCanvasSize(e);
        }}
      >
        <div class={canvasSizeForm}>
          <div>
            <p class={canvasSizeLabel}>width</p>
            <input
              class={canvasSizeInput}
              type='number'
              name='width'
              onChange={(e) => setWidth(Number(e.target.value))}
              value={width()}
              min={Consts.minCanvasWidth}
              max={Consts.maxCanvasWidth}
              required
            />
          </div>
          <div>
            <p class={canvasSizeLabel}>height</p>
            <input
              class={canvasSizeInput}
              type='number'
              name='height'
              onChange={(e) => setHeight(Number(e.target.value))}
              value={height()}
              min={Consts.minCanvasHeight}
              max={Consts.maxCanvasHeight}
              required
            />
          </div>
          <button class={canvasSizeButton} type='submit'>
            change
          </button>
        </div>
      </form>

      <button class={canvasSizeButton} onClick={resetAllLayers}>
        RESET ALL LAYERS
      </button>
    </div>
  );
};

export default CanvasSettings;
</file>

<file path="components/section/Color.tsx">
import { Component, For } from 'solid-js';
import ColorPicker from '~/components/section/item/ColorPicker';
import ColorBox from '../common/ColorBox';
import Palette from './item/Palette';

import { setCurrentColor } from '~/controllers/color/ColorController';
import { colorStore } from '~/stores/EditorStores';
import { swatchContainer } from '~/styles/section/color.css';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/section_global.css';
import { flexCol } from '~/styles/snippets.css';

const Color: Component = () => {
  const onColorClicked = (color: string, index: number) => {
    setCurrentColor(color);
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>color.</p>
      <div class={sectionContent} style={{ 'flex-direction': 'row', margin: '8px 0' }}>
        <div class={swatchContainer}>
          <For each={colorStore.swatches}>
            {(item, index) => (
              <ColorBox
                color={item}
                sizePx={8}
                onClick={(color) => onColorClicked(color, index())}
                enableUsingSelection={true}
              />
            )}
          </For>
        </div>
        {/* <div class={descriptionContainer}>
          <p class={colorElemDescription}>picker.</p>
        </div> */}
        <div class={flexCol}>
          <ColorPicker width={150} />
          <Palette />
        </div>
      </div>
    </div>
  );
};

export default Color;
</file>

<file path="components/section/item/ColorPicker.tsx">
import iro from '@jaames/iro';
import { IroColorPicker } from '@jaames/iro/dist/ColorPicker';
import { Component, createEffect } from 'solid-js';
import { currentColor, setCurrentColor } from '~/controllers/color/ColorController';

const ColorPicker: Component<{ width: number }> = (props) => {
  let colorPicker: IroColorPicker;

  createEffect(() => {
    colorPicker.setColors([currentColor()]);
  });

  return (
    <div
      ref={(el) => {
        colorPicker = iro.ColorPicker(el, {
          width: props.width,
          padding: 0,
          color: currentColor(),
          handleRadius: 4,
          layoutDirection: 'horizontal',
          layout: [
            {
              component: iro.ui.Box,
              options: {},
            },
            {
              component: iro.ui.Slider,
              options: {
                // can also be 'saturation', 'value', 'red', 'green', 'blue', 'alpha' or 'kelvin'
                sliderType: 'hue',
              },
            },
          ],
        });
        colorPicker.on('color:change', function (color: any) {
          setCurrentColor(color.hexString);
        });
      }}
    />
  );
};

export default ColorPicker;
</file>

<file path="components/section/item/LayerItem.tsx">
import { createSortable, useDragDropContext } from '@thisbeyond/solid-dnd';
import { Component } from 'solid-js';
import Light from '~/components/common/Light';
import { getNextMagnification } from '~/controllers/layer/LayerController';
import { layerListStore, setLayerListStore } from '~/stores/ProjectStores';
import {
  activeLight,
  dotMagnifContainer,
  dotMagnifText,
  layerItem,
  layerItemDisabled,
  layerItemIndex,
  layerItemName,
  layerItemType,
} from '~/styles/section/layer.css';
import { flexRow, w100 } from '~/styles/snippets.css';
import { Layer, LayerType } from '~/types/Layer';
import LayerPreview from '../../common/LayerPreview';

interface LayerItemProps {
  index: number;
  isLast?: boolean;
  layer: Layer;
  draggingId?: string | null;
}

const LayerItem: Component<LayerItemProps> = (props) => {
  const sortable = createSortable(props.layer.id);
  const context = useDragDropContext();
  const state = context?.[0];

  let detClass: 'dot' | 'image' | 'automate' | undefined;
  switch (props.layer.type) {
    case LayerType.Dot:
      detClass = 'dot';
      break;
    case LayerType.Image:
      detClass = 'image';
      break;
    case LayerType.Automate:
      detClass = 'automate';
      break;
  }

  const onDetClicked = () => {
    setLayerListStore('activeLayerId', props.layer.id);
  };

  const onPreviewClicked = () => {
    if (props.index !== -1) {
      setLayerListStore('layers', props.index, 'enabled', (v: boolean) => !v);
    }
  };

  const onMagnifClicked = () => {
    const next = getNextMagnification(props.layer.dotMagnification);
    if (props.index !== -1) {
      setLayerListStore('layers', props.index, 'dotMagnification', next);
    }
  };

  const isActive = () => layerListStore.activeLayerId === props.layer.id;

  return (
    <div
      class={w100}
      classList={{
        'opacity-50': sortable.isActiveDraggable,
        'transition-transform': state && !!state.active.draggable,
      }}
      style={{ opacity: props.draggingId === props.layer.id ? 0.4 : 1 }}
      ref={sortable}
    >
      {/* <DSLButton /> */}
      <div
        class={[layerItem, !props.layer.enabled && layerItemDisabled].filter(Boolean).join(' ')}
        // style={{ 'border-bottom': props.isLast ? 'none' : '1px solid #333' }}
        onClick={onDetClicked}
      >
        <LayerPreview layer={props.layer} onClick={onPreviewClicked} maxHeight={36} maxWidth={36} />

        <div
          class={[flexRow, w100].join(' ')}
          style={{
            'align-items': 'center',
            position: 'relative',
          }}
        >
          <div
            class={flexRow}
            style={{
              top: '2px',
              right: 0,
              left: 0,
              'margin-left': '6px',
              position: 'absolute',
            }}
          >
            <p class={layerItemIndex}>{props.index}.</p>
            <p class={layerItemType}>{props.layer.typeDescription}</p>
          </div>

          <p class={layerItemName}> {props.layer.name}</p>
          <div
            class={dotMagnifContainer}
            onClick={(e) => {
              e.stopPropagation();
              onMagnifClicked();
            }}
            onMouseOver={(e) => e.stopPropagation()}
          >
            <p class={dotMagnifText}>x{props.layer.dotMagnification}</p>
          </div>
          <Light class={activeLight} on={isActive()} />
        </div>
      </div>
    </div>
  );
};

export default LayerItem;
</file>

<file path="components/section/item/Palette.tsx">
import { Component } from 'solid-js';
import ColorBox from '~/components/common/ColorBox';
import { selectPalette } from '~/controllers/color/ColorController';
import { colorStore } from '~/stores/EditorStores';
import { paletteRoot } from '~/styles/components/palette.css';
import { PaletteType } from '~/types/PaletteType';

const Palette: Component = () => {
  return (
    <div class={paletteRoot}>
      <ColorBox
        color={colorStore.primary}
        sizePx={24}
        onClick={(color) => selectPalette(PaletteType.primary)}
        enableUsingSelection={colorStore.currentPalette === PaletteType.primary}
      />
      <ColorBox
        color={colorStore.secondary}
        sizePx={24}
        onClick={(color) => selectPalette(PaletteType.secondary)}
        enableUsingSelection={colorStore.currentPalette === PaletteType.secondary}
      />
    </div>
  );
};

export default Palette;
</file>

<file path="components/section/item/ToolItem.tsx">
import { Component } from 'solid-js';
import Slider from '~/components/common/Slider';
import { sayRandomQuote } from '~/components/common/companion/QuotePool';
import { setToolStore, toolStore } from '~/stores/EditorStores';
import { toolConfigRow, toolConfigRowClickable, toolConfigRowIcon, toolConfigRowName } from '~/styles/section/pen.css';
import { Tool, ToolType } from '~/types/Tool';
import { Consts } from '~/utils/consts';

interface Props {
  tool: Tool;
  isInUse: boolean;
}

const ToolItem: Component<Props> = (props: Props) => {
  let src = '';
  switch (props.tool.type) {
    case ToolType.Pen:
      src = '/pen.png';
      break;
    case ToolType.Eraser:
      src = '/eraser_b.png';
      break;
    case ToolType.Fill:
      src = '/fill_G_x10.png';
      break;
  }
  return (
    <div class={toolConfigRow}>
      {/* <Light on={props.isInUse} /> */}
      <div
        class={toolConfigRowClickable}
        onClick={() => {
          setToolStore({ usingIndex: toolStore.tools.indexOf(props.tool) });
        }}
      >
        <img
          class={toolConfigRowIcon}
          style={{
            'image-rendering': 'pixelated',
            filter: props.isInUse
              ? 'invert(11%) sepia(92%) saturate(7351%) hue-rotate(0deg) brightness(99%) contrast(109%)'
              : 'none',
          }}
          src={src}
          width={20}
          height={20}
        />
        <p
          class={toolConfigRowName}
          style={{
            color: props.isInUse ? 'red' : 'unset',
          }}
        >
          {props.tool.name}.
        </p>
      </div>

      {(props.tool.type === ToolType.Pen || props.tool.type === ToolType.Eraser) && (
        <>
          <div style={{ 'flex-grow': 1 }}>
            <Slider
              min={1}
              max={Consts.maxPenSize}
              default={props.tool.size}
              onValueChanged={(newValue) => {
                sayRandomQuote('pen-resize');
                console.log('size set to ' + newValue);
                const penIndex = toolStore.tools.findIndex((p) => p.id === props.tool.id);
                setToolStore('tools', penIndex, 'size', newValue);
              }}
            />
          </div>

          <p style={{ width: 'auto' }}>{props.tool.size}.</p>
        </>
      )}
    </div>
  );
};

export default ToolItem;
</file>

<file path="components/section/LayerList.tsx">
import { closestCenter, DragDropProvider, DragDropSensors, SortableProvider } from '@thisbeyond/solid-dnd';
import { Component, createEffect, createSignal, For, onMount } from 'solid-js';
import { activeLayer, addLayer, allLayers, removeLayer } from '~/controllers/layer_list/LayerListController';

import { layerListStore, setLayerListStore } from '~/stores/ProjectStores';
import { layerList } from '~/styles/section/layer.css';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/section_global.css';
import { flexRow } from '~/styles/snippets.css';
import LayerItem from './item/LayerItem';
// 並べ替え用ユーティリティ関数

const LayerList: Component<{}> = () => {
  const [items, setItems] = createSignal(allLayers());
  const [activeItem, setActiveItem] = createSignal(null);
  const ids = () => items().map((l) => l.id);

  onMount(() => {
    setItems(allLayers());
  });

  createEffect(() => {
    setItems(allLayers());
  });

  const onDragStart = ({ draggable }: { draggable: any }) => setActiveItem(draggable.id);

  function moveLayer(draggedId: string, targetIndex: number) {
    const fromIndex = layerListStore.layers.findIndex((l) => l.id === draggedId);
    if (fromIndex === -1 || fromIndex === targetIndex) return;

    const updated = [...layerListStore.layers];
    const [moved] = updated.splice(fromIndex, 1);
    updated.splice(targetIndex, 0, moved);
    setLayerListStore('layers', updated);
    setItems(allLayers());
  }

  const onDragEnd = ({ draggable, droppable }: { draggable: any; droppable: any }) => {
    if (draggable && droppable) {
      const currentItems = ids();
      const fromIndex = currentItems.indexOf(draggable.id);
      const toIndex = currentItems.indexOf(droppable.id);
      if (fromIndex !== toIndex) {
        moveLayer(draggable.id, toIndex);
      }
    }
  };

  return (
    <DragDropProvider
      onDragStart={onDragStart}
      onDragEnd={(e) => {
        onDragEnd({ draggable: e.draggable, droppable: e.droppable });
      }}
      collisionDetector={closestCenter}
    >
      <DragDropSensors>
        <div class={sectionRoot}>
          <div class={flexRow} style={{ 'margin-bottom': '6px' }}>
            <p class={sectionCaption} style={{ 'flex-grow': 1 }}>
              layers.
            </p>

            <div class={flexRow} style={{ gap: '4px' }}>
              <button
                onClick={async () => {
                  await addLayer('dot1');
                  setItems(allLayers());
                }}
              >
                + add.
              </button>

              <button
                onClick={() => {
                  removeLayer(activeLayer()?.id);
                  setItems(allLayers());
                }}
              >
                - remove.
              </button>
            </div>
          </div>
          <div class={sectionContent}>
            <div class={layerList}>
              <SortableProvider ids={ids()}>
                <For each={items()}>
                  {(layer, index) => (
                    <LayerItem layer={layer} index={index()} isLast={index() === items().length - 1} />
                  )}
                </For>
              </SortableProvider>
            </div>
            {/* <DragOverlay>
                                    <div class="sortable"><LayerItem layer={activeItemLayer()} /></div>
                                </DragOverlay> */}
          </div>
        </div>
      </DragDropSensors>
    </DragDropProvider>
  );
};

export default LayerList;
</file>

<file path="components/section/Project.tsx">
import { Component, createSignal, onMount, Show } from 'solid-js';
import { exportActiveLayerUpscaled } from '~/io/image_io/save';
import { saveProject } from '~/io/project/project';
import { projectStore, setProjectStore } from '~/stores/ProjectStores';

import { vars } from '~/styles/global.css';
import { projectNameInput } from '~/styles/section/project.css';
import { sectionContent, sectionRoot } from '~/styles/section_global.css';
import { flexCol, flexRow } from '~/styles/snippets.css';

const Project: Component = () => {
  const [saveLog, setSaveLog] = createSignal<string | undefined>(undefined);
  const isNameChanged = () => projectStore.name !== projectStore.newName;
  const isOWPossible = () => projectStore.name !== undefined && projectStore.path !== undefined && !isNameChanged();

  onMount(() => {
    setProjectStore('newName', projectStore.name);
  });

  const save = () => {
    if (isNameChanged()) {
      setProjectStore('name', projectStore.newName);
    }
    if (isOWPossible()) {
      // 上書き保存
      saveProject(`${projectStore.path}`).then(() => {
        setSaveLog('saved!');
        setProjectStore('isProjectChangedAfterSave', false);
      });
    } else {
      saveProject().then(() => {
        setSaveLog('saved!');
        setProjectStore('isProjectChangedAfterSave', false);
      });
    }
  };
  const OWSave = () => {
    if (isNameChanged()) {
      setProjectStore('name', projectStore.newName);
    }
    // 上書き保存
    saveProject(`${projectStore.path}`).then(() => {
      setSaveLog('saved!');
      setProjectStore('isProjectChangedAfterSave', false);
    });
  };
  const forceNewSave = () => {
    if (isNameChanged()) {
      setProjectStore('name', projectStore.newName);
    }
    saveProject().then(() => {
      setSaveLog('saved!');
      setProjectStore('isProjectChangedAfterSave', false);
    });
  };

  return (
    <div class={sectionRoot}>
      {/* <p class={sectionCaption}>project.</p> */}
      <div class={sectionContent}>
        <div
          class={flexCol}
          style={{
            'margin-top': '8px',
          }}
        >
          <Show when={isNameChanged()}>
            <p>{projectStore.name} →</p>
          </Show>

          <input
            class={projectNameInput}
            type='text'
            name='height'
            onInput={(e) => {
              if (e.target.value) setProjectStore('newName', e.target.value);
            }}
            onChange={(e) => {
              if (e.target.value) setProjectStore('newName', e.target.value);
            }}
            value={projectStore.name}
            placeholder='project name'
            autocomplete='off'
          />

          {/* <p class={styles.project_file_path}>{projectStore.path}</p> */}
        </div>
        {/* <button class={styles.loadsave_button} onClick={() => importProjectJsonFromFileSelection()}>
                        load.
                    </button> */}

        <div
          class={flexRow}
          style={{
            'align-items': 'center',
            'margin-top': '4px',
            'margin-bottom': '12px',
            gap: vars.spacing.sm,
          }}
        >
          <Show when={isOWPossible()}>
            <button
              onClick={() => OWSave()}
              style={{
                color: vars.color.accent,
                'border-color': vars.color.accent,
              }}
            >
              save.
            </button>
            <button onClick={() => forceNewSave()}>save (new).</button>
          </Show>
          <Show when={!isOWPossible()}>
            <button
              onClick={() => forceNewSave()}
              style={{
                color: vars.color.accent,
                'border-color': vars.color.accent,
              }}
            >
              save (new).
            </button>
          </Show>
          <button onClick={() => exportActiveLayerUpscaled(projectStore.newName || projectStore.name)}>export.</button>
          {/*   {!projectStore.isProjectChangedAfterSave && <p class={styles.save_log}>{saveLog()}</p>} */}
        </div>
      </div>
    </div>
  );
};

export default Project;
</file>

<file path="components/section/settings/EditorSettings.tsx">
import { Component } from 'solid-js';
import { globalStore, setGlobalStore } from '~/stores/GlobalStores';
import { vars } from '~/styles/global.css';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/section_global.css';
import { flexRow } from '~/styles/snippets.css';
import { CanvasRenderingMode } from '~/types/Canvas';
import { Consts } from '~/utils/consts';
import Dropdown, { DropdownOption } from '../../common/Dropdown';

const renderingOptions: DropdownOption<CanvasRenderingMode>[] = [
  { label: 'adaptive', value: 'adaptive' },
  { label: 'pixelated', value: 'pixelated' },
  { label: 'crispEdges', value: 'crispEdges' },
];

const EditorSettings: Component = () => {
  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>editor.</p>
      <div class={sectionContent} style={{ gap: '8px' }}>
        <div>
          <p>default canvas size.</p>
          <div class={flexRow} style={{ gap: vars.spacing.xs, 'margin-top': vars.spacing.sm, 'align-items': 'center' }}>
            <input
              type='number'
              name='width'
              min={Consts.minCanvasWidth}
              max={Consts.maxCanvasWidth}
              value={globalStore.newProjectCanvasSize.width}
              onChange={(e) => {
                setGlobalStore('newProjectCanvasSize', 'width', Number(e.target.value));
              }}
              style={{ 'font-size': vars.text.lg }}
              required
            />
            <p>x</p>
            <input
              type='number'
              name='height'
              min={Consts.minCanvasHeight}
              max={Consts.maxCanvasHeight}
              value={globalStore.newProjectCanvasSize.height}
              onChange={(e) => {
                setGlobalStore('newProjectCanvasSize', 'height', Number(e.target.value));
              }}
              style={{ 'font-size': vars.text.lg }}
              required
            />
          </div>
        </div>

        <div>
          <p>autosave span (wip).</p>
          <input type='number' name='width' min={100} max={1000000} required />
        </div>

        <p>canvas rendering (temp not works).</p>
        <Dropdown
          selected={globalStore.canvasRenderingMode}
          value={globalStore.canvasRenderingMode}
          options={renderingOptions}
          onChange={(v) => {
            setGlobalStore('canvasRenderingMode', v);
          }}
        />
      </div>
    </div>
  );
};

export default EditorSettings;
</file>

<file path="components/section/settings/PerformanceSettings.tsx">
import { Component } from 'solid-js';
import Checkbox from '~/components/common/Checkbox';
import { globalStore, setGlobalStore } from '~/stores/GlobalStores';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/section_global.css';

const PerformanceSettings: Component = () => {
  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>performance.</p>
      <div class={sectionContent} style={{ gap: '8px' }}>
        <Checkbox
          label='show dirtyrects.'
          checked={globalStore.showDirtyRects}
          onChange={(e) => setGlobalStore('showDirtyRects', e)}
        />
        <Checkbox
          label='performance monitor.'
          checked={globalStore.showPerfMonitor}
          onChange={(e) => setGlobalStore('showPerfMonitor', e)}
        />
      </div>
    </div>
  );
};

export default PerformanceSettings;
</file>

<file path="components/section/ToolConfig.tsx">
import { Component, For } from 'solid-js';
import { toolStore } from '~/stores/EditorStores';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/section_global.css';
import ToolItem from './item/ToolItem';

const ToolConfig: Component = () => {
  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>tools.</p>
      <div class={sectionContent}>
        <For each={toolStore.tools}>
          {(item, index) => <ToolItem tool={item} isInUse={index() === toolStore.usingIndex} />}
        </For>
      </div>
    </div>
  );
};

export default ToolConfig;
</file>

<file path="controllers/canvas/CanvasController.ts">
import { interactStore, setInteractStore } from '~/stores/EditorStores';
import { canvasStore, setCanvasStore } from '~/stores/ProjectStores';
import { Size2D } from '~/types/Size';
import { Consts } from '~/utils/consts';
import { resetLayerImage } from '../layer/LayerController';
import { allLayers } from '../layer_list/LayerListController';

export function changeCanvasSize(newSize: Size2D): boolean {
  if (newSize.width < Consts.minCanvasWidth || Consts.maxCanvasWidth < newSize.width) return false;
  if (newSize.height < Consts.minCanvasHeight || Consts.maxCanvasHeight < newSize.height) return false;

  setCanvasStore('canvas', newSize);
  allLayers().forEach((layer) => {
    resetLayerImage(layer.id, layer.dotMagnification);
  });
  return true;
}

const REFERENCE_LENGTH = 600;

export const getReferencedZoom = (length?: number) => {
  if (length === undefined) {
    const width = canvasStore.canvas.width;
    const height = canvasStore.canvas.height;
    length = width > height ? width : height;
    if (!length) return undefined;
  }

  return REFERENCE_LENGTH / length;
};

export const adjustZoomToFit = (width?: number, height?: number) => {
  if (width === undefined) width = canvasStore.canvas.width;
  if (height === undefined) height = canvasStore.canvas.height;
  if (!width || !height) return;

  const isWide = width > height;
  const longerLength = isWide ? width : height;

  const referencedZoom = getReferencedZoom(longerLength);
  if (!referencedZoom) return;
  setInteractStore('zoom', referencedZoom);
  centeringCanvas();
};

export const centeringCanvas = () => {
  const canvasSize = canvasStore.canvas;
  const canvasArea = interactStore.canvasAreaSize;
  const zoom = interactStore.zoom;

  setInteractStore('offsetOrigin', {
    x: canvasArea.width / 2 - (canvasSize.width * zoom) / 2,
    y: canvasArea.height / 2 - (canvasSize.height * zoom) / 2,
  });
  setInteractStore('offset', {
    x: 0,
    y: 0,
  });
};
</file>

<file path="controllers/canvas/LayerCanvasOperator.ts">
import { LayerCanvasRef } from '~/components/canvas/stacks/LayerCanvas';
import { setBottomBarText } from '~/controllers/log/LogController';
import { currentTool } from '~/controllers/tool/ToolController';
import { Vec2 } from '~/types/Vector';
import { hexToRGBA } from '~/utils/ColorUtils';
import LayerImageAgent from '../../models/layer_image/LayerImageAgent';
import TileLayerImageAgent from '../../models/layer_image/agents/TileLayerImageAgent';
import { getToolInstance } from '../../models/tool/ToolBase';
import { DrawState } from '../../types/DrawState';
import { Tool } from '../../types/Tool';
import { currentColor } from '../color/ColorController';

export default class LayerCanvasOperator {
  constructor(private readonly getActiveLayerCanvas: () => LayerCanvasRef) {}

  public handleDraw(state: DrawState, position: Vec2, last?: Vec2) {
    const layerCanvasRef = this.getActiveLayerCanvas();
    const layer = layerCanvasRef.getLayer();
    const agent = layerCanvasRef.getAgent();
    const image = agent.getImage();
    if (!image) return;

    position = this.getMagnificatedPosition(position, layer.dotMagnification);
    if (last) last = this.getMagnificatedPosition(last, layer.dotMagnification);

    const result = this.useTool(agent, state, image, currentTool(), position, last);

    if (result) {
      agent.setDrawingBuffer(result);
      if (state === DrawState.end) {
        agent.registerDiffAction();
        agent.setImage(result);

        if (agent instanceof TileLayerImageAgent) {
          (agent as TileLayerImageAgent).resetAllDirtyStates();
        }
      }
    }
  }

  private useTool(agent: LayerImageAgent, state: DrawState, image: ImageData, tool: Tool, position: Vec2, last?: Vec2) {
    const toolInstance = getToolInstance(tool.type);
    const toolArgs = {
      image,
      position,
      lastPosition: last,
      size: tool.size,
      color: hexToRGBA(currentColor()),
    };
    const startTime = Date.now();
    let isDrawnAction;
    switch (state) {
      case DrawState.start:
        const isDrawnActionInStart = toolInstance.onStart(agent, toolArgs);
        const isDrawnActionInMove = toolInstance.onMove(agent, toolArgs);
        isDrawnAction = isDrawnActionInStart || isDrawnActionInMove;
        break;
      case DrawState.move:
        isDrawnAction = toolInstance.onMove(agent, toolArgs);
        break;
      case DrawState.end:
        isDrawnAction = toolInstance.onEnd(agent, toolArgs);
        break;
    }
    const endTime = Date.now();
    if (isDrawnAction) {
      if (agent instanceof TileLayerImageAgent) {
        setBottomBarText(
          `${tool.type} finished. ${endTime - startTime} ms. (updated ${(agent as TileLayerImageAgent).getDirtyTiles().length} dirty tiles)`
        );
      } else {
        setBottomBarText(`${tool.type} finished. ${endTime - startTime} ms.`);
      }
    }
    return image;
  }

  private getMagnificatedPosition(position: Vec2, dotMagnification: number) {
    return {
      x: Math.floor(position.x / dotMagnification),
      y: Math.floor(position.y / dotMagnification),
    };
  }
}
</file>

<file path="controllers/canvas/PreviewCanvasFactory.ts">
export function createPreviewCanvas(imageData: ImageData, targetHeight: number): HTMLCanvasElement {
  const aspectRatio = imageData.width / imageData.height;
  const targetWidth = Math.round(targetHeight * aspectRatio);

  const canvas = document.createElement('canvas');
  canvas.width = targetWidth;
  canvas.height = targetHeight;

  const ctx = canvas.getContext('2d')!;
  ctx.imageSmoothingEnabled = false;

  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = imageData.width;
  tmpCanvas.height = imageData.height;
  tmpCanvas.getContext('2d')!.putImageData(imageData, 0, 0);

  ctx.drawImage(tmpCanvas, 0, 0, imageData.width, imageData.height, 0, 0, targetWidth, targetHeight);

  return canvas;
}
</file>

<file path="controllers/color/ColorController.ts">
import { colorStore, setColorStore } from '~/stores/EditorStores';
import { PaletteType } from '~/types/PaletteType';

export const currentColor = (): string => {
  return colorStore[colorStore.currentPalette];
};
export const setCurrentColor = (colorHexString: string) => {
  return setColorStore(colorStore.currentPalette, colorHexString);
};
export const setColor = (palette: PaletteType, colorHexString: string) => {
  return setColorStore(palette, colorHexString);
};
export const selectPalette = (palette: PaletteType) => {
  return setColorStore('currentPalette', palette);
};
</file>

<file path="controllers/config/GlobalConfigController.ts">
import { saveGlobalSettings } from '~/io/global_config/globalSettings';
import { setGlobalStore } from '~/stores/GlobalStores';
import { FileLocation } from '~/types/FileLocation';

export const addRecentFile = (fileLocation?: FileLocation) => {
  if (!fileLocation) return;
  const path = fileLocation.path;
  const name = fileLocation.name;

  // add to recent
  setGlobalStore((store) => {
    console.log('path: ' + path);
    console.log('name: ' + name);
    if (name && path && store.recentFiles) {
      const oldRecentFiles = store.recentFiles.filter((f) => {
        return f.name !== name || f.path !== path?.toString();
      });
      // その後、一番上に追加
      const newRecentFiles: FileLocation[] = [
        {
          name: name,
          path: path,
        },
        ...oldRecentFiles,
      ];
      setGlobalStore('recentFiles', newRecentFiles);
      saveGlobalSettings();
    }
    return store;
  });
};
</file>

<file path="controllers/layer_list/LayerListController.ts">
import { layerHistoryStore, layerListStore, setLayerHistoryStore, setLayerListStore } from '~/stores/ProjectStores';
import { LayerType } from '~/types/Layer';
import { DSL } from '../../models/dsl/DSL';
import { createLayer } from '../layer/LayerFactory';

export const addLayer = async (
  name: string,
  type: LayerType = LayerType.Dot,
  enabled = true,
  dotMagnification = 1,
  dsl?: DSL
) => {
  const newLayer = createLayer(name, type, enabled, dotMagnification, dsl);

  const layers = [...allLayers()];
  layers.push(newLayer);

  setLayerListStore('layers', layers);
  setLayerListStore('activeLayerId', newLayer.id);

  return layers;
};

export const removeLayer = (layerId?: string) => {
  if (layerId === undefined) return;
  const layers = [...allLayers()];
  if (layers.length <= 1) return;
  const index = layers.findIndex((l) => l.id === layerId);
  let newActiveIndex = 0;
  if (index !== 0) newActiveIndex = index - 1;

  layers.splice(index, 1);
  const histories = Object.assign({}, layerHistoryStore);
  delete histories[layerId];

  setLayerListStore('layers', layers);
  setLayerListStore('activeLayerId', layers[newActiveIndex].id);
  setLayerHistoryStore(histories);
};

export const allLayers = () => layerListStore.layers;
export const findLayerById = (id: string) => allLayers().find((layer) => layer.id === id);
export const activeLayer = () => findLayerById(layerListStore.activeLayerId) || allLayers()[0] || undefined;
export const activeIndex = () => allLayers().findIndex((layer) => layer.id === layerListStore.activeLayerId);
</file>

<file path="controllers/layer/LayerController.ts">
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';
import { layerImageManager } from '~/routes/editor';
import { canvasStore, layerHistoryStore, layerListStore, setLayerHistoryStore } from '~/stores/ProjectStores';

const magnificationList: number[] = [1, 2, 4];

export const getNextMagnification = (dotMagnification: number) => {
  const index = magnificationList.findIndex((m) => m === dotMagnification);
  if (index != -1) {
    // 循環
    const nextIndex = index !== magnificationList.length - 1 ? index + 1 : 0;
    return magnificationList[nextIndex];
  } else return 1;
};

export function resetLayerImage(layerId: string, dotMagnification: number): LayerImageAgent {
  const blank = new ImageData(
    Math.round(canvasStore.canvas.width / dotMagnification),
    Math.round(canvasStore.canvas.height / dotMagnification)
  );
  setLayerHistoryStore(layerId, {
    undoStack: [],
    redoStack: [],
  });
  const agent = layerImageManager.getAgent(layerId);
  if (agent !== undefined) {
    console.log('udpate');
    agent.setImage(blank, false);
    return agent;
  } else {
    console.log('not found');
    return layerImageManager.registerAgent(layerId, blank);
  }
}

export const canUndo = (): boolean => layerHistoryStore[layerListStore.activeLayerId]?.undoStack.length > 0;
export const canRedo = (): boolean => layerHistoryStore[layerListStore.activeLayerId]?.redoStack.length > 0;
</file>

<file path="controllers/layer/LayerFactory.ts">
import { v4 } from 'uuid';
import { resetLayerImage } from '~/controllers/layer/LayerController';
import { layerListStore } from '~/stores/ProjectStores';
import { Layer, LayerType } from '~/types/Layer';
import { DSL } from '../../models/dsl/DSL';

export const createLayer = (name: string, type: LayerType, enabled = true, dotMagnification = 1, dsl?: DSL): Layer => {
  // check if name already exists
  const endNums = name.match(/^(.*)(\d+)$/);
  if (endNums && endNums.length >= 3) {
    const nameWithoutNum = endNums[1];
    const endNum = Number(endNums[2]);

    const foundSameNameNums: number[] = [];
    layerListStore.layers.forEach((layer) => {
      const layerEndNums = layer.name.match(/^(.*)(\d+)$/);
      if (layerEndNums && layerEndNums.length >= 3) {
        const layerNameWithoutNum = layerEndNums[1];
        const layerEndNum = Number(layerEndNums[2]);
        if (nameWithoutNum === layerNameWithoutNum) {
          foundSameNameNums.push(layerEndNum);
        }
      }
    });

    let num = endNum;
    while (foundSameNameNums.find((foundNum) => foundNum === num)) {
      num++;
    }
    name = nameWithoutNum + num;
  }

  const id = v4();
  resetLayerImage(id, dotMagnification);

  return {
    id,
    name,
    type,
    typeDescription: getTypeString(type),
    enabled,
    dotMagnification,
    dsl: dsl || new DSL(id, id),
  };
};

function getTypeString(type: LayerType): string {
  switch (type) {
    case LayerType.Dot:
      return 'dot layer.';
    case LayerType.Image:
      return 'image layer.';
    case LayerType.Automate:
      return 'automate layer.';
    default:
      return 'N/A.';
  }
}
</file>

<file path="controllers/log/LogController.tsx">
import { setLogStore } from '~/stores/EditorStores';

export function setBottomBarText(text: string) {
  setLogStore('bottomBarText', text);
}
</file>

<file path="controllers/tool/ToolController.ts">
import { toolStore } from '~/stores/EditorStores';

export const currentTool = () => toolStore.tools[toolStore.usingIndex];
</file>

<file path="io/global_config/globalSettings.ts">
import { BaseDirectory, mkdir, readTextFile, writeTextFile } from '@tauri-apps/plugin-fs';
import { globalStore, setGlobalStore } from '~/stores/GlobalStores';

const FILE_NAME = 'global.sledgeconfig';

export async function saveGlobalSettings() {
  try {
    const json = JSON.stringify(globalStore);
    await mkdir('', { baseDir: BaseDirectory.AppConfig, recursive: true });
    await writeTextFile(FILE_NAME, json, { baseDir: BaseDirectory.AppConfig });
    console.log('[globalIO] 設定保存完了');
  } catch (e) {
    console.error('[globalIO] 設定保存失敗', e);
  }
}

export async function loadGlobalSettings() {
  try {
    const json = await readTextFile(FILE_NAME, {
      baseDir: BaseDirectory.AppConfig,
    });
    const data = JSON.parse(json);

    setGlobalStore(data);

    console.log('[globalIO] 設定読み込み完了', data);
  } catch (e) {
    console.warn('[globalIO] 設定ファイルが存在しないか、読み込み失敗:', e);
  }
}
</file>

<file path="io/image_io/save.ts">
import { layerListStore } from '~/stores/ProjectStores';

export function exportActiveLayerUpscaled(fileName?: string, path?: string, scale = 10) {
  const layerId = layerListStore.activeLayerId;
  if (!layerId) return;

  const originalCanvas = document.getElementById(`canvas-${layerId}`) as HTMLCanvasElement;
  if (!originalCanvas) {
    alert('対象のレイヤーが見つかりません。');
    return;
  }

  const w = originalCanvas.width;
  const h = originalCanvas.height;

  // オフスクリーンキャンバスを作る
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = w * scale;
  exportCanvas.height = h * scale;

  const ctx = exportCanvas.getContext('2d');
  if (!ctx) {
    alert('Canvasコンテキスト取得に失敗しました。');
    return;
  }

  // ピクセル補間を無効化
  ctx.imageSmoothingEnabled = false;

  // 元のキャンバスをscale倍に引き伸ばして描画（補完なし）
  ctx.drawImage(originalCanvas, 0, 0, exportCanvas.width, exportCanvas.height);

  // エクスポート処理
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      alert('エクスポートに失敗しました。');
      return;
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${fileName || layerId}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, 'image/png');
}

export function downloadImageData(imageData: ImageData, filename: string = 'image', scale: number = 10) {
  // 一時的な canvas を作成
  const canvas = document.createElement('canvas');
  canvas.width = imageData.width;
  canvas.height = imageData.height;

  // ImageData を描画
  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('2D context not available');
    return;
  }
  ctx.putImageData(imageData, 0, 0);

  const w = canvas.width;
  const h = canvas.height;

  // オフスクリーンキャンバスを作る
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = w * scale;
  exportCanvas.height = h * scale;

  const ctxEx = exportCanvas.getContext('2d');
  if (!ctxEx) {
    alert('Canvasコンテキスト取得に失敗しました。');
    return;
  }

  // ピクセル補間を無効化
  ctxEx.imageSmoothingEnabled = false;
  // 元のキャンバスをscale倍に引き伸ばして描画（補完なし）
  ctxEx.drawImage(canvas, 0, 0, exportCanvas.width, exportCanvas.height);

  // エクスポート処理
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      alert('エクスポートに失敗しました。');
      return;
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, 'image/png');
}
</file>

<file path="io/project/project.ts">
import { path } from '@tauri-apps/api';
import { open as dialogOpen, save } from '@tauri-apps/plugin-dialog';
import { BaseDirectory, mkdir, readTextFile, writeTextFile } from '@tauri-apps/plugin-fs';
import { addRecentFile } from '~/controllers/config/GlobalConfigController';
import { findLayerById } from '~/controllers/layer_list/LayerListController';
import { getImageOf } from '~/routes/editor';
import {
  canvasStore,
  layerHistoryStore,
  layerListStore,
  loadStoreFromProjectJson as loadProjectStore,
  projectStore,
  setProjectStore,
} from '~/stores/ProjectStores';
import { encodeImageData } from '~/utils/ImageUtils';
import { getFileNameAndPath } from '~/utils/PathUtils';

export async function importProjectJsonFromFileSelection(): Promise<string | undefined> {
  const home = await path.homeDir();
  const file = await dialogOpen({
    multiple: false,
    directory: false,
    defaultPath: await path.join(home, 'sledge'),
    filters: [
      {
        name: 'sledge files',
        extensions: ['sledge'],
      },
    ],
  });
  if (!file) {
    console.log('ファイルが選択されていません');
    return undefined;
  }

  const jsonText = await readTextFile(file);
  const projectJson = JSON.parse(jsonText);

  loadProjectStore(projectJson);

  return file;
}

export async function importProjectJsonFromPath(filePath: string) {
  if (!filePath) {
    console.log('ファイルが選択されていません');
    return;
  }
  const jsonText = await readTextFile(filePath);
  const projectJson = JSON.parse(jsonText);

  loadProjectStore(projectJson);
}

export const parseCurrentProject = (): string => {
  return JSON.stringify({
    project: projectStore,
    canvas: canvasStore.canvas,
    images: Object.fromEntries(
      Object.entries(layerHistoryStore).map(([id, state]) => {
        const image = getImageOf(id);
        if (!image) return [];
        return [
          id,
          {
            current: encodeImageData(image),
            width: image.width,
            height: image.height,
            dotMagnification: findLayerById(id)?.dotMagnification,
          },
        ];
      })
    ),
    layer: {
      layers: layerListStore.layers.map((layer) => ({
        ...layer,
        dsl: undefined, // TODO: save dsl
      })),
      activeLayerId: layerListStore.activeLayerId,
    },
  });
};

export async function saveProject(existingPath?: string) {
  let selectedPath: string | null;
  if (existingPath) {
    selectedPath = existingPath;
  } else {
    try {
      await mkdir('sledge', {
        baseDir: BaseDirectory.Home,
        recursive: true,
      });
    } catch (e) {
      console.warn('ディレクトリ作成スキップまたは失敗:', e);
    }

    const home = await path.homeDir();
    selectedPath = await save({
      title: 'Sledge プロジェクトを保存',
      defaultPath: await path.join(home, `sledge/${projectStore.name}.sledge`),
      filters: [{ name: 'Sledge Project', extensions: ['sledge'] }],
    });
  }

  if (typeof selectedPath === 'string') {
    setProjectStore('path', selectedPath);
    const data = parseCurrentProject();
    await writeTextFile(selectedPath, data);
    console.log('プロジェクト保存:', selectedPath);

    setProjectStore('isProjectChangedAfterSave', false);
    addRecentFile(getFileNameAndPath(selectedPath));
  } else {
    console.log('保存キャンセルされました');
  }
}
</file>

<file path="main.tsx">
import { render } from 'solid-js/web';
import App from './app';
import './styles/global.css';
import './styles/reset.css';

render(() => <App />, document.getElementById('root')!);
</file>

<file path="models/dsl/DSL.ts">
import { SledgeNode } from '~/models/dsl/nodes/DSLNodes';
import { findLayerById } from '../../controllers/layer_list/LayerListController';
import { LayerIn } from './nodes/pass/LayerIn';
import { LayerOut } from './nodes/pass/LayerOut';

export class DSL {
  layerIn: LayerIn;
  readonly nodes: SledgeNode[];
  layerOut: LayerOut;

  constructor(inLayerId: string, outLayerId: string) {
    this.layerIn = new LayerIn(inLayerId);
    this.nodes = [];
    this.layerOut = new LayerOut(outLayerId);
  }

  public addNode(node: SledgeNode) {
    this?.nodes.push(node);
  }

  public build(exceptIn: boolean = false): string | undefined {
    const nodes = exceptIn ? [...this.nodes, this.layerOut] : [this.layerIn, ...this.nodes, this.layerOut];

    const nodeStrings: string[] = [];
    let isAllNodeParseSuccessful = true;
    nodes.forEach((node, i) => {
      const nodeStr = node.getNodeString();
      if (nodeStr !== undefined) nodeStrings.push(nodeStr);
      else {
        isAllNodeParseSuccessful = false;
        throw `DSL parse failed in: ${node.name} [${i}]`;
      }
    });

    if (isAllNodeParseSuccessful) {
      // if all nodes parsed successfully
      return nodeStrings.join(' > '); // in(inLayerId) > out(outLayerId) by default
    } else {
      // if some nodes failed to parse
      return undefined;
    }
  }

  public toString(): string {
    let str = this.build();
    if (str === undefined) throw 'DSL parse failed.';
    else {
      // 読みやすくする
      const inId = this.layerIn.layerId;
      const outId = this.layerOut.layerId;
      if (inId !== undefined) str = str.replaceAll(inId, `${findLayerById(inId)?.name || 'N/A'} ID`);
      if (outId !== undefined) str = str.replaceAll(outId, `${findLayerById(outId)?.name || 'N/A'} ID`);
      str = str.replaceAll(' > ', '\n> ');
      return str;
    }
  }
}
</file>

<file path="models/dsl/DSLRunner.ts">
import { decodeImageData, encodeImageData } from '~/utils/ImageUtils';
import { safeInvoke } from '~/utils/TauriUtils';
import { DSL } from './DSL';

export async function runDSL(dsl: DSL, image: ImageData): Promise<ImageData | undefined> {
  const encoded = encodeImageData(image);

  const dslStr = dsl.build(true);
  if (dslStr === undefined) return;

  const result = await safeInvoke<string>('run_pipeline', {
    dsl: dslStr,
    encoded,
    width: image.width,
    height: image.height,
  });

  if (!result) return;
  return decodeImageData(result, image.width, image.height);
}
</file>

<file path="models/dsl/nodes/AvailableNodes.ts">
import { SledgeNode } from './DSLNodes';
import { Brightness } from './effect/Brightness';
import { GrayScale } from './effect/GrayScale';
import { Invert } from './effect/Invert';
import { Sepia } from './effect/Sepia';
import { JpegGlitch } from './fracture/JpegGlitch';

export const ALL_NODES: SledgeNode[] = [
  // effect
  new Brightness(),
  new GrayScale(),
  new Invert(),
  new Sepia(),
  // pass
  // new LayerIn(""),
  // new LayerOut(""),
  // fracture
  new JpegGlitch(),
];
</file>

<file path="models/dsl/nodes/DSLNodes.ts">
// 旧
// export enum ImageCommands {
//   INVERT = "invert",
//   GRAYSCALE = "grayscale",
//   GLITCH = "glitch",
//   SEPIA = "sepia",
//   BRIGHTNESS = "brightness",
// }
// export type ImageCommandParams =
//   | {
//       command:
//         | ImageCommands.INVERT
//         | ImageCommands.GRAYSCALE
//         | ImageCommands.SEPIA;
//     }
//   | { command: ImageCommands.BRIGHTNESS; delta: number };

export type NodeType = 'effect' | 'pass' | 'fracture';

export interface NodeArg {
  name: string;
  default: number | string | undefined;
}

export abstract class SledgeNode {
  abstract name: string;
  abstract type: NodeType;
  abstract description: string;

  constructor() {}

  // error occured = undefined
  abstract getNodeString(): string | undefined;
}
</file>

<file path="models/dsl/nodes/effect/Brightness.ts">
import { EffectNode } from './EffectNode';

export class Brightness extends EffectNode {
  name: string = 'brightness';
  description: string = 'brightness';

  constructor(private delta: number = 30) {
    super();
  }

  getNodeString(): string {
    return `${this.name}(${this.delta})`;
  }
}
</file>

<file path="models/dsl/nodes/effect/EffectNode.ts">
import { NodeType, SledgeNode } from '../DSLNodes';

export abstract class EffectNode extends SledgeNode {
  type: NodeType = 'effect';
}
</file>

<file path="models/dsl/nodes/effect/GrayScale.ts">
import { EffectNode } from './EffectNode';

export class GrayScale extends EffectNode {
  name: string = 'grayscale';
  description: string = 'grayscale';

  getNodeString(): string {
    return `${this.name}()`;
  }
}
</file>

<file path="models/dsl/nodes/effect/Invert.ts">
import { EffectNode } from './EffectNode';

export class Invert extends EffectNode {
  name: string = 'invert';
  description: string = 'invert';

  getNodeString(): string {
    return `${this.name}()`;
  }
}
</file>

<file path="models/dsl/nodes/effect/Sepia.ts">
import { EffectNode } from './EffectNode';

export class Sepia extends EffectNode {
  name: string = 'sepia';
  description: string = 'sepia';

  getNodeString(): string {
    return `${this.name}()`;
  }
}
</file>

<file path="models/dsl/nodes/fracture/FractureNode.ts">
import { NodeType, SledgeNode } from '../DSLNodes';

export abstract class FractureNode extends SledgeNode {
  type: NodeType = 'fracture';
}
</file>

<file path="models/dsl/nodes/fracture/JpegGlitch.ts">
import { FractureNode } from './FractureNode';

export class JpegGlitch extends FractureNode {
  name = 'jpeg_glitch';
  description = 'JPEG glitch effect using random byte corruption';

  private seed = Math.floor(Math.random() * 100);
  private quality = 90;
  private amount = 0.001; // 2%の破壊

  getNodeString(): string {
    return `${this.name}(${this.seed}, ${this.quality}, ${this.amount})`;
  }
}
</file>

<file path="models/dsl/nodes/pass/LayerIn.ts">
import { PassNode } from './PassNode';

export class LayerIn extends PassNode {
  name: string = 'in';
  description: string = 'layer_in';

  constructor(public layerId?: string) {
    super();
  }

  getNodeString(): string | undefined {
    if (!this.layerId) return undefined;
    return `${this.name}(${this.layerId})`;
  }
}
</file>

<file path="models/dsl/nodes/pass/LayerOut.ts">
import { PassNode } from './PassNode';

export class LayerOut extends PassNode {
  name: string = 'out';
  description: string = 'out';

  constructor(public layerId?: string) {
    super();
  }

  getNodeString(): string | undefined {
    if (!this.layerId) return undefined;
    return `${this.name}(${this.layerId})`;
  }
}
</file>

<file path="models/dsl/nodes/pass/PassNode.ts">
import { NodeType, SledgeNode } from '../DSLNodes';

export abstract class PassNode extends SledgeNode {
  type: NodeType = 'pass';
}
</file>

<file path="models/layer_image/agents/RawLayerImageAgent.ts">
import { Vec2 } from '~/types/Vector';
import { RGBAColor } from '~/utils/ColorUtils';
import { PixelDiff } from '../HistoryManager';
import LayerImageAgent from '../LayerImageAgent';

export default class RawLayerImageAgent extends LayerImageAgent {
  putImageInto(ctx: CanvasRenderingContext2D) {
    ctx.putImageData(this.image, 0, 0);
  }

  putDrawingBufferInto(ctx: CanvasRenderingContext2D) {
    if (this.drawingBuffer) ctx.putImageData(this.drawingBuffer, 0, 0);
  }

  public setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.setPixelInPosition(position, color, excludePositionMatch, excludeColorMatch);
  }

  public deletePixel(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.deletePixelInPosition(position, excludePositionMatch, excludeColorMatch);
  }

  public getPixel(position: Vec2): RGBAColor {
    const i = (position.y * this.image.width + position.x) * 4;
    const d = this.image.data;
    return [d[i], d[i + 1], d[i + 2], d[i + 3]];
  }
}
</file>

<file path="models/layer_image/agents/TileLayerImageAgent.ts">
import Tile, { TileIndex } from '~/types/Tile';
import { Vec2 } from '~/types/Vector';
import { colorMatch, RGBAColor } from '~/utils/ColorUtils';
import { HistoryManager, PixelDiff, TileDiff } from '../HistoryManager';
import LayerImageAgent from '../LayerImageAgent';

export default class TileLayerImageAgent extends LayerImageAgent {
  readonly TILE_SIZE = 16;

  private tiles: Tile[][] = [];

  getTile(index: TileIndex) {
    // console.log(`tile access to ${index.row}. ${index.column}`)
    return this.tiles[index.row][index.column];
  }

  getTiles() {
    return this.tiles;
  }

  constructor(imageData: ImageData, historyManager: HistoryManager) {
    super(imageData, historyManager);
    this.initTile();
  }

  initTile() {
    const tileRowCount = Math.ceil(this.getHeight() / this.TILE_SIZE);
    const tileColumnCount = Math.ceil(this.getWidth() / this.TILE_SIZE);
    for (let row = 0; row < tileRowCount; row++) {
      this.tiles[row] = [];
      for (let column = 0; column < tileColumnCount; column++) {
        this.tiles[row][column] = new Tile(row, column, this.TILE_SIZE);
      }
    }
    this.scanAllTilesUniformity();
  }

  scanAllTilesUniformity() {
    const { TILE_SIZE } = this;
    const w = this.getWidth();
    const h = this.getHeight();

    for (const row of this.tiles) {
      for (const tile of row) {
        const { x: ox, y: oy } = tile.getOffset();

        // ①タイルの左上ピクセルを基準色に
        const base = this.getPixel({ x: ox, y: oy });

        let uniform = true;
        // ②タイル内を走査（画像端は超えないよう clamp）
        for (let dy = 0; dy < TILE_SIZE && uniform; dy++) {
          const py = oy + dy;
          if (py >= h) break;
          for (let dx = 0; dx < TILE_SIZE; dx++) {
            const px = ox + dx;
            if (px >= w) break;
            if (!colorMatch(this.getPixel({ x: px, y: py }), base)) {
              uniform = false;
              break;
            }
          }
        }
        // ③結果を保存
        tile.isUniform = uniform;
        tile.uniformColor = uniform ? base : undefined;
      }
    }
  }

  setImage(image: ImageData): void {
    super.setImage(image);
    this.initTile();
  }

  putImageInto(ctx: CanvasRenderingContext2D) {
    if (this.getDirtyTiles().length > 0) {
      this.putOnlyForDirtyTiles(ctx, this.image);
    }
  }

  putDrawingBufferInto(ctx: CanvasRenderingContext2D) {
    if (this.getDirtyTiles().length > 0) {
      if (this.drawingBuffer) this.putOnlyForDirtyTiles(ctx, this.drawingBuffer);
    }
  }

  private putOnlyForDirtyTiles(ctx: CanvasRenderingContext2D, image: ImageData) {
    const dirtyTiles = this.getDirtyTiles();

    dirtyTiles.forEach((dirtyTile) => {
      const offset = dirtyTile.getOffset();
      ctx.putImageData(image, 0, 0, offset.x, offset.y, this.TILE_SIZE, this.TILE_SIZE);
    });

    this.resetDirtyStates();
  }

  public getTileIndex(layerPosition: Vec2): TileIndex {
    const row = Math.floor(layerPosition.y / this.TILE_SIZE);
    const column = Math.floor(layerPosition.x / this.TILE_SIZE);
    return { row, column };
  }

  public resetDirtyStates() {
    this.tiles = this.tiles.map((tR) => {
      tR = tR.map((t) => {
        t.isDirty = false;
        return t;
      });
      return tR;
    });
  }

  public resetAllDirtyStates() {
    this.tiles = this.tiles.map((tR) => {
      tR = tR.map((t) => {
        t.isDirty = false;
        t.isDirtyThroughAction = false;
        return t;
      });
      return tR;
    });
  }

  public getDirtyTiles(): Tile[] {
    return this.tiles.flatMap((tR) => tR.filter((t) => t.isDirty));
  }
  public getDirtyTilesInAction(): Tile[] {
    return this.tiles.flatMap((tR) => tR.filter((t) => t.isDirtyThroughAction));
  }

  protected undoTileDiff(tileDiff: TileDiff): void {
    console.log(`tilediff. fill ${tileDiff.beforeColor}`);
    if (tileDiff.beforeColor) this.fillWholeTile(tileDiff.index, tileDiff.beforeColor, false);
  }

  protected redoTileDiff(tileDiff: TileDiff): void {
    console.log(`tilediff. fill ${tileDiff.afterColor}`);
    this.fillWholeTile(tileDiff.index, tileDiff.afterColor, false);
  }

  public setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    const result = this.setPixelInPosition(position, color, excludePositionMatch, excludeColorMatch);
    if (result !== undefined) {
      const tileIndex = this.getTileIndex(position);
      this.tiles[tileIndex.row][tileIndex.column].isDirty = true;
      this.tiles[tileIndex.row][tileIndex.column].isDirtyThroughAction = true;

      const tile = this.getTile(tileIndex);
      if (tile.isUniform && tile.uniformColor !== undefined && colorMatch(tile.uniformColor, color)) {
        this.tiles[tileIndex.row][tileIndex.column].isUniform = false;
        this.tiles[tileIndex.row][tileIndex.column].uniformColor = undefined;
      }
    }
    return result;
  }

  fillWholeTile(index: TileIndex, color: RGBAColor, collectDiff = true) {
    const tile = this.getTile(index);
    if (tile.isUniform && tile.uniformColor && colorMatch(tile.uniformColor, color)) return;

    const [r, g, b, a] = color;
    const { x: ox, y: oy } = tile.getOffset();
    const { TILE_SIZE } = this;
    const { width, data } = this.image;

    for (let dy = 0; dy < TILE_SIZE; dy++) {
      const y = oy + dy;
      if (y >= this.getHeight()) break;
      let i = (y * width + ox) * 4; // 行頭インデックス
      for (let dx = 0; dx < TILE_SIZE; dx++) {
        const x = ox + dx;
        if (x >= this.getWidth()) break;

        data[i] = r;
        data[i + 1] = g;
        data[i + 2] = b;
        data[i + 3] = a;
        i += 4;
      }
    }

    if (collectDiff)
      this.addDiffs([
        {
          kind: 'tile',
          index,
          beforeColor: tile.uniformColor,
          afterColor: [r, g, b, a],
        },
      ]);

    // 状態更新
    tile.isDirty = tile.isDirty = true;
    tile.isDirty = tile.isDirtyThroughAction = true;
    tile.isUniform = true;
    tile.uniformColor = color;
  }

  public deletePixel(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    const result = this.deletePixelInPosition(position, excludePositionMatch, excludeColorMatch);
    if (result !== undefined) {
      const tileIndex = this.getTileIndex(position);
      this.tiles[tileIndex.row][tileIndex.column].isDirty = true;
      this.tiles[tileIndex.row][tileIndex.column].isDirtyThroughAction = true;
    }
    return result;
  }

  public getPixel(position: Vec2): RGBAColor {
    const i = (position.y * this.image.width + position.x) * 4;
    const d = this.image.data;

    return [d[i], d[i + 1], d[i + 2], d[i + 3]];
  }

  public getTileRowCount() {
    return this.tiles.length;
  }

  public getTileColumnCount() {
    return this.tiles[0].length;
  }

  public isTileInBounds(index: TileIndex) {
    return (
      index.row >= 0 &&
      index.row < this.getTileRowCount() &&
      index.column >= 0 &&
      index.column < this.getTileColumnCount()
    );
  }
}
</file>

<file path="models/layer_image/HistoryManager.ts">
import { reconcile } from 'solid-js/store';
import { setLayerHistoryStore } from '~/stores/ProjectStores';
import { TileIndex } from '~/types/Tile';
import { RGBAColor } from '~/utils/ColorUtils';
import { Vec2 } from '../../types/Vector';

export type PixelDiff = {
  kind: 'pixel';
  position: Vec2;
  before: RGBAColor;
  after: RGBAColor;
};

export type TileDiff = {
  kind: 'tile';
  index: TileIndex;
  beforeColor: RGBAColor | undefined;
  afterColor: RGBAColor;
};

export type Diff = PixelDiff | TileDiff;

export const getDiffHash = (diff: Diff) => {
  switch (diff.kind) {
    case 'pixel':
      return `px:${diff.position.x},${diff.position.y}`;
    case 'tile':
      return `tile:${diff.index.row},${diff.index.column}`;
  }
};

export type DiffAction = {
  diffs: Map<string, Diff>;
};

export class HistoryManager {
  protected undoActionsStack: DiffAction[] = [];
  protected redoActionsStack: DiffAction[] = [];
  private readonly maxStackSize = 50;

  constructor(public layerId: string) {}

  public getUndoStack() {
    return this.undoActionsStack;
  }

  public getRedoStack() {
    return this.redoActionsStack;
  }

  public canUndo() {
    return this.undoActionsStack.length > 0;
  }

  public canRedo() {
    return this.redoActionsStack.length > 0;
  }

  public addAction(action: DiffAction) {
    // push new action and cap undo history
    this.undoActionsStack.push(action);
    if (this.undoActionsStack.length > this.maxStackSize) {
      this.undoActionsStack.shift();
    }
    // clear redo history
    this.redoActionsStack = [];

    this.syncStores();
  }

  public undo(): DiffAction | undefined {
    const undoedAction = this.undoActionsStack.pop();
    if (!undoedAction) return undefined;

    // push to redo and cap redo history
    this.redoActionsStack.unshift(undoedAction);
    if (this.redoActionsStack.length > this.maxStackSize) {
      this.redoActionsStack.pop();
    }

    this.syncStores();
    return undoedAction;
  }

  public redo(): DiffAction | undefined {
    const redoedAction = this.redoActionsStack.shift();
    if (!redoedAction) return undefined;

    // push back to undo and cap undo history
    this.undoActionsStack.push(redoedAction);
    if (this.undoActionsStack.length > this.maxStackSize) {
      this.undoActionsStack.shift();
    }

    this.syncStores();
    return redoedAction;
  }

  /**
   * Synchronize the undo/redo stacks with the SolidJS store
   */
  private syncStores() {
    setLayerHistoryStore(this.layerId, 'undoStack', reconcile(this.undoActionsStack));
    setLayerHistoryStore(this.layerId, 'redoStack', reconcile(this.redoActionsStack));
  }
}
</file>

<file path="models/layer_image/LayerImageAgent.ts">
import { setBottomBarText } from '~/controllers/log/LogController';
import { Vec2 } from '~/types/Vector';
import { colorMatch, RGBAColor } from '~/utils/ColorUtils';
import { Diff, DiffAction, getDiffHash, HistoryManager, PixelDiff, TileDiff } from './HistoryManager';

interface DrawingBufferChangeEvent {}
interface ImageChangeEvent {}

// それぞれのLayerCanvasの描画、表示までの処理過程を記述するクラス
export default abstract class LayerImageAgent {
  protected image: ImageData;
  protected drawingBuffer: ImageData | undefined;
  protected historyManager;

  protected onImageChangedListeners: {
    [key: string]: (e: ImageChangeEvent) => void;
  } = {};
  protected onDrawingBufferChangedListeners: {
    [key: string]: (e: DrawingBufferChangeEvent) => void;
  } = {};

  constructor(imageData: ImageData, historyManager?: HistoryManager) {
    this.image = imageData;
    this.drawingBuffer = imageData;
    this.historyManager = historyManager;
  }

  getHistoryManager() {
    return this.historyManager;
  }

  getImage() {
    return this.image;
  }

  setImage(image: ImageData, silentlySet: boolean = false) {
    this.image = image;
    if (!silentlySet) this.callOnImageChangeListeners();
    this.resetDrawingBuffer();
  }

  getDrawingBuffer() {
    return this.drawingBuffer;
  }

  setDrawingBuffer(imageData?: ImageData) {
    this.drawingBuffer = imageData;
    this.callOnDrawingBufferChangeListeners();
  }

  resetDrawingBuffer() {
    this.setDrawingBuffer(this.image);
  }

  abstract putImageInto(ctx: CanvasRenderingContext2D): void;
  abstract putDrawingBufferInto(ctx: CanvasRenderingContext2D): void;

  putImageIntoForce(ctx: CanvasRenderingContext2D) {
    ctx.putImageData(this.image, 0, 0);
  }
  putDrawingBufferIntoForce(ctx: CanvasRenderingContext2D) {
    if (this.drawingBuffer) ctx.putImageData(this.drawingBuffer, 0, 0);
  }

  setOnImageChangeListener(key: string, listener: (e: ImageChangeEvent) => void) {
    this.onImageChangedListeners[key] = listener;
  }
  clearOnImageChangeListener(key: string) {
    delete this.onImageChangedListeners[key];
  }

  setOnDrawingBufferChangeListener(key: string, listener: (e: DrawingBufferChangeEvent) => void) {
    this.onDrawingBufferChangedListeners[key] = listener;
  }
  clearOnDrawingBufferChangeListener(key: string) {
    delete this.onDrawingBufferChangedListeners[key];
  }

  callOnImageChangeListeners() {
    Object.values(this.onImageChangedListeners).forEach((listener) => listener({}));
  }

  callOnDrawingBufferChangeListeners() {
    Object.values(this.onDrawingBufferChangedListeners).forEach((listener) => listener({}));
  }

  getWidth = (): number => this.image.width;
  getHeight = (): number => this.image.height;

  public currentDiffAction: DiffAction = { diffs: new Map() };

  addDiffs(diffs: Diff[]) {
    diffs.forEach((d) => this.currentDiffAction.diffs.set(getDiffHash(d), d));
  }

  public registerDiffAction() {
    this.historyManager?.addAction(this.currentDiffAction);
    this.currentDiffAction = { diffs: new Map() };
  }

  public canUndo = () => this.historyManager?.canUndo();
  public canRedo = () => this.historyManager?.canRedo();

  public undo() {
    const undoStart = Date.now();
    const undoedAction = this.historyManager?.undo();
    if (undoedAction === undefined) return;
    setBottomBarText(`undo.`);
    undoedAction.diffs.forEach((diff) => {
      switch (diff.kind) {
        case 'pixel':
          this.setPixelInPosition(diff.position, diff.before, false, false);
          break;
        case 'tile':
          this.undoTileDiff(diff);
          break;
      }
    });
    const undoEnd = Date.now();
    setBottomBarText(`undo done. (${undoedAction.diffs.size} px updated, ${undoEnd - undoStart}ms)`);

    this.callOnImageChangeListeners();
  }

  protected undoTileDiff(tileDiff: TileDiff) {}

  public redo() {
    const redoStart = Date.now();
    const redoedAction = this.historyManager?.redo();
    if (redoedAction === undefined) return;
    setBottomBarText(`redo.`);
    redoedAction.diffs.forEach((diff) => {
      switch (diff.kind) {
        case 'pixel':
          this.setPixelInPosition(diff.position, diff.after, false, false);
          break;
        case 'tile':
          this.redoTileDiff(diff);
          break;
      }
    });
    const redoEnd = Date.now();
    setBottomBarText(`redo done. (${redoedAction.diffs.size} px updated, ${redoEnd - redoStart}ms)`);

    this.callOnImageChangeListeners();
  }

  protected redoTileDiff(tileDiff: TileDiff) {}

  public abstract setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean,
    excludeColorMatch: boolean
  ): PixelDiff | undefined;

  protected setPixelInPosition(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    if (!this.isInBounds(position)) return undefined;
    if (excludePositionMatch && this.currentDiffAction.diffs.has(`${position.x},${position.y}`)) return undefined;
    const i = (position.y * this.getWidth() + position.x) * 4;
    const beforeColor: RGBAColor = [
      this.image.data[i + 0],
      this.image.data[i + 1],
      this.image.data[i + 2],
      this.image.data[i + 3],
    ];
    if (excludeColorMatch && colorMatch(beforeColor, color)) return undefined;

    if (!this.drawingBuffer) return;

    this.drawingBuffer.data[i + 0] = color[0];
    this.drawingBuffer.data[i + 1] = color[1];
    this.drawingBuffer.data[i + 2] = color[2];
    this.drawingBuffer.data[i + 3] = color[3];

    return {
      kind: 'pixel',
      position,
      before: beforeColor,
      after: color,
    };
  }

  public abstract deletePixel(
    position: Vec2,
    excludePositionMatch: boolean,
    excludeColorMatch: boolean
  ): PixelDiff | undefined;

  protected deletePixelInPosition(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.setPixelInPosition(position, [0, 0, 0, 0], excludePositionMatch, excludeColorMatch);
  }

  public abstract getPixel(position: Vec2): RGBAColor;

  public isInBounds(position: Vec2) {
    return position.x >= 0 && position.y >= 0 && position.x < this.getWidth() && position.y < this.getHeight();
  }
}
</file>

<file path="models/layer_image/LayerImageManager.ts">
import { HistoryManager } from './HistoryManager';
import LayerImageAgent from './LayerImageAgent';
import TileLayerImageAgent from './agents/TileLayerImageAgent';

export class LayerImageManager {
  private agents: Map<string, LayerImageAgent> = new Map();

  public getAgent(layerId: string): LayerImageAgent | undefined {
    return this.agents.get(layerId);
  }

  public registerAgent(layerId: string, image: ImageData): LayerImageAgent {
    const agent = new TileLayerImageAgent(image, new HistoryManager(layerId));
    this.agents.set(layerId, agent);
    return agent;
  }
}
</file>

<file path="models/tool/eraser/EraserTool.ts">
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';
import { drawCompletionLine, drawSquarePixel } from '../../../utils/DrawUtils';
import { Tool, ToolArgs } from '../ToolBase';

export class EraserTool implements Tool {
  onStart(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }

  onMove(agent: LayerImageAgent, { position, lastPosition, size }: ToolArgs) {
    if (!size) return false;

    drawSquarePixel(position, size, (px, py) => {
      const diff = agent.deletePixel({ x: px, y: py }, true, true);
      if (diff !== undefined) {
        agent.addDiffs([diff]);
      }
    });

    if (lastPosition !== undefined) {
      drawCompletionLine(position, lastPosition, (x, y) => {
        drawSquarePixel({ x, y }, size, (px, py) => {
          const diff = agent.deletePixel({ x: px, y: py }, true, true);
          if (diff !== undefined) {
            agent.addDiffs([diff]);
          }
        });
      });
    }

    return true;
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }
}
</file>

<file path="models/tool/fill/FillTool.ts">
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';
import { Vec2 } from '~/types/Vector';
import { RGBAColor } from '~/utils/ColorUtils';
import { Tool, ToolArgs } from '../ToolBase';
import { TileFloodFill } from './TileFloodFill';

export interface FillProps {
  agent: LayerImageAgent;
  color: RGBAColor;
  position: Vec2;
}
export interface Fill {
  fill: (props: FillProps) => void;
}

export class FillTool implements Tool {
  onStart(agent: LayerImageAgent, { position, lastPosition, color }: ToolArgs) {
    const fill = new TileFloodFill();

    fill.fill({ agent, color, position });

    return true;
  }

  onMove(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }
}
</file>

<file path="models/tool/fill/PixelFloodFill.ts">
import { PixelDiff } from '~/models/layer_image/HistoryManager';
import { Vec2 } from '~/types/Vector';
import { colorMatch } from '~/utils/ColorUtils';
import { Fill, FillProps } from './FillTool';

export class PixelFloodFill implements Fill {
  fill({ agent, color, position }: FillProps) {
    const targetColor = agent.getPixel(position);
    const matches = (p: Vec2) => colorMatch(agent.getPixel(p), targetColor);

    console.log(color);
    console.log(targetColor);

    if (colorMatch(targetColor, color)) return false;

    // console.log(`---${image.width}x${image.height} flood fill---`)

    if (colorMatch(targetColor, color)) return false;
    console.log('fill started.');

    const scanStart = Date.now();
    const queue: Vec2[] = [position];
    const filled: Vec2[] = [];
    const visited = new Uint8Array(agent.getWidth() * agent.getHeight()); // 0:未訪問, 1:訪問済
    const index = (p: Vec2) => p.y * agent.getWidth() + p.x;
    let queueCount = 0;
    let visitCount = 0;
    while (queue.length > 0) {
      queueCount++;
      const c = queue.pop()!;
      if (!agent.isInBounds(c)) continue;

      const i = index(c);
      if (visited[i]) continue;
      visited[i] = 1;
      visitCount++;

      if (matches(c)) {
        filled.push(c);
        queue.push({ x: c.x + 1, y: c.y });
        queue.push({ x: c.x - 1, y: c.y });
        queue.push({ x: c.x, y: c.y + 1 });
        queue.push({ x: c.x, y: c.y - 1 });
      }
    }

    const scanEnd = Date.now();
    console.log('scan finished. ' + (scanEnd - scanStart) + 'ms.');

    const writeStart = Date.now();

    const pxDiffs: PixelDiff[] = [];
    // バッファに一括反映
    for (const p of filled) {
      const diff = agent.setPixel(p, color, false, false);
      if (diff !== undefined) pxDiffs.push(diff);
    }
    const writeEnd = Date.now();
    console.log('write finished. ' + (writeEnd - writeStart) + 'ms.');

    agent.addDiffs(pxDiffs);
  }
}
</file>

<file path="models/tool/fill/TileFloodFill.ts">
import { PixelDiff } from '~/models/layer_image/HistoryManager';
import TileLayerImageAgent from '~/models/layer_image/agents/TileLayerImageAgent';
import { TileIndex } from '~/types/Tile';
import { Vec2 } from '~/types/Vector';
import { colorMatch } from '~/utils/ColorUtils';
import { Fill, FillProps } from './FillTool';

interface FillPassProps {
  index: TileIndex;
}

export class TileFloodFill implements Fill {
  fill({ agent, color, position }: FillProps) {
    if (!(agent instanceof TileLayerImageAgent)) throw 'Agent is not a TileLayerImageAgent';
    const tileAgent = agent as TileLayerImageAgent;

    const targetColor = tileAgent.getPixel(position);
    if (colorMatch(targetColor, color)) return false;

    const tileRowCount = tileAgent.getTileRowCount();
    const tileColumnCount = tileAgent.getTileColumnCount();
    const flatten = (ti: TileIndex) => ti.row * tileColumnCount + ti.column;
    const tileUniformMatches = (ti: TileIndex) => {
      const tile = tileAgent.getTile(ti);
      return tile.isUniform && tile.uniformColor && colorMatch(tile.uniformColor, targetColor);
    };

    const visitedTiles = new Uint8Array(tileRowCount * tileColumnCount);
    const tilesFilled: TileIndex[] = [];
    const tileQueue: TileIndex[] = [tileAgent.getTileIndex(position)];

    const pxDiffs: PixelDiff[] = [];
    const visitedPx = new Uint8Array(agent.getWidth() * agent.getHeight());

    // First tile flood pass
    let tileFillCount = 0;
    while (tileQueue.length > 0) {
      const ti = tileQueue.pop()!;
      if (!tileAgent.isTileInBounds(ti)) continue;
      const i = flatten(ti);
      if (visitedTiles[i]) continue;
      visitedTiles[i] = 1;
      if (!tileUniformMatches(ti)) continue;

      tilesFilled.push(ti);
      tileFillCount++;
      tileQueue.push({ row: ti.row - 1, column: ti.column });
      tileQueue.push({ row: ti.row + 1, column: ti.column });
      tileQueue.push({ row: ti.row, column: ti.column - 1 });
      tileQueue.push({ row: ti.row, column: ti.column + 1 });
    }
    for (const ti of tilesFilled) {
      const offset = tileAgent.getTile(ti).getOffset();
      for (let dy = 0; dy < tileAgent.TILE_SIZE; dy++) {
        for (let dx = 0; dx < tileAgent.TILE_SIZE; dx++) {
          const x = offset.x + dx;
          const y = offset.y + dy;
          const i = y * agent.getWidth() + x;
          visitedPx[i] = 1;
        }
      }
    }
    console.log(`initial tile fill finished: ${tileFillCount} tiles`);

    const edgePixels = tilesFilled.length > 0 ? this.collectEdgePixels(tileAgent, tilesFilled) : [position];

    const pixelQueue: Vec2[] = edgePixels;
    const pixelsFilled: Vec2[] = [];
    const pxIndex = (p: Vec2) => p.y * agent.getWidth() + p.x;

    let pixelFillCount = 0;
    while (pixelQueue.length > 0) {
      const p = pixelQueue.pop()!;
      if (!agent.isInBounds(p)) continue;
      const idx = pxIndex(p);
      if (visitedPx[idx]) continue;
      visitedPx[idx] = 1;

      const tileIndex = tileAgent.getTileIndex(p);
      const tileIdxFlat = flatten(tileIndex);
      const tilesFilledInReEntry: TileIndex[] = [];
      if (!visitedTiles[tileIdxFlat] && tileUniformMatches(tileIndex)) {
        const reentryQueue: TileIndex[] = [tileIndex];
        let reentryCount = 0;
        while (reentryQueue.length > 0) {
          const ti = reentryQueue.pop()!;
          if (!tileAgent.isTileInBounds(ti)) continue;
          const i = flatten(ti);
          if (visitedTiles[i]) continue;
          visitedTiles[i] = 1;
          if (!tileUniformMatches(ti)) continue;
          tilesFilled.push(ti);
          tilesFilledInReEntry.push(ti);
          reentryCount++;
          reentryQueue.push({ row: ti.row - 1, column: ti.column });
          reentryQueue.push({ row: ti.row + 1, column: ti.column });
          reentryQueue.push({ row: ti.row, column: ti.column - 1 });
          reentryQueue.push({ row: ti.row, column: ti.column + 1 });
        }
        // ↓ 前はこれがなかった ↓
        const newEdges = this.collectEdgePixels(tileAgent, tilesFilledInReEntry);
        for (const edge of newEdges) {
          pixelQueue.push(edge);
        }
        for (const ti of tilesFilled) {
          const offset = tileAgent.getTile(ti).getOffset();
          for (let dy = 0; dy < tileAgent.TILE_SIZE; dy++) {
            for (let dx = 0; dx < tileAgent.TILE_SIZE; dx++) {
              const x = offset.x + dx;
              const y = offset.y + dy;
              const i = y * agent.getWidth() + x;
              visitedPx[i] = 1;
            }
          }
        }
        console.log(`tile reentry fill: ${reentryCount} tiles`);
        continue;
      }

      if (!colorMatch(tileAgent.getPixel(p), targetColor)) continue;
      pixelsFilled.push(p);
      pixelFillCount++;
      pixelQueue.push({ x: p.x + 1, y: p.y });
      pixelQueue.push({ x: p.x - 1, y: p.y });
      pixelQueue.push({ x: p.x, y: p.y + 1 });
      pixelQueue.push({ x: p.x, y: p.y - 1 });
    }
    console.log(`pixel fill finished: ${pixelFillCount} pixels`);

    for (const ti of tilesFilled) tileAgent.fillWholeTile(ti, color, true);
    for (const p of pixelsFilled) {
      const diff = tileAgent.setPixel(p, color, false, false);
      if (diff) pxDiffs.push(diff);
    }

    if (pxDiffs.length > 0) tileAgent.addDiffs(pxDiffs);
  }

  collectEdgePixels(agent: TileLayerImageAgent, filled: TileIndex[]): Vec2[] {
    const edge: Vec2[] = [];
    const TILE_SIZE = agent.TILE_SIZE;
    const filledSet = new Set(filled.map((t) => `${t.row},${t.column}`));

    for (const ti of filled) {
      const offset = agent.getTile(ti).getOffset();
      const neighbors = [
        { dr: -1, dc: 0, dx: 0, dy: -1, axis: 'x' },
        { dr: 1, dc: 0, dx: 0, dy: TILE_SIZE, axis: 'x' },
        { dr: 0, dc: -1, dx: -1, dy: 0, axis: 'y' },
        { dr: 0, dc: 1, dx: TILE_SIZE, dy: 0, axis: 'y' },
      ];

      for (const { dr, dc, dx, dy, axis } of neighbors) {
        const ni = `${ti.row + dr},${ti.column + dc}`;
        if (filledSet.has(ni)) continue;
        for (let i = 0; i < TILE_SIZE; i++) {
          const x = axis === 'x' ? offset.x + i : offset.x + dx;
          const y = axis === 'y' ? offset.y + i : offset.y + dy;
          edge.push({ x, y });
        }
      }
    }
    return edge;
  }
}
</file>

<file path="models/tool/pen/PenTool.ts">
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';
import { drawCompletionLine, drawSquarePixel } from '../../../utils/DrawUtils';
import { Tool, ToolArgs } from '../ToolBase';

export class PenTool implements Tool {
  onStart(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }

  onMove(agent: LayerImageAgent, { position, lastPosition, color, size }: ToolArgs) {
    if (!size) return false;

    drawSquarePixel(position, size, (px, py) => {
      const diff = agent.setPixel({ x: px, y: py }, color, true, true);
      if (diff !== undefined) {
        agent.addDiffs([diff]);
      }
    });

    if (lastPosition !== undefined) {
      drawCompletionLine(position, lastPosition, (x, y) => {
        drawSquarePixel({ x, y }, size, (px, py) => {
          const diff = agent.setPixel({ x: px, y: py }, color, true, true);
          if (diff !== undefined) {
            agent.addDiffs([diff]);
          }
        });
      });
    }

    return true;
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }
}
</file>

<file path="models/tool/ToolBase.ts">
import { RGBAColor } from '~/utils/ColorUtils';
import { ToolType } from '../../types/Tool';
import { Vec2 } from '../../types/Vector';
import LayerImageAgent from '../layer_image/LayerImageAgent';
import { EraserTool } from './eraser/EraserTool';
import { FillTool } from './fill/FillTool';
import { PenTool } from './pen/PenTool';

export interface Tool {
  onStart: (agent: LayerImageAgent, args: ToolArgs) => boolean;

  onMove: (agent: LayerImageAgent, args: ToolArgs) => boolean;

  onEnd: (agent: LayerImageAgent, args: ToolArgs) => boolean;
}

export interface ToolArgs {
  position: Vec2;
  lastPosition?: Vec2;
  color: RGBAColor; // RGBA
  size?: number;
  // TODO: pressure, tilt, ...
}

export const getToolInstance = (toolType: ToolType) => {
  switch (toolType) {
    case ToolType.Pen:
      return new PenTool();
    case ToolType.Eraser:
      return new EraserTool();
    case ToolType.Fill:
      return new FillTool();

    default:
      return new PenTool();
  }
};
</file>

<file path="models/tool/ToolFactory.ts">
import { v4 } from 'uuid';
import { Tool, ToolType } from '~/types/Tool';

export const createTool = (type: ToolType, name: string, size: number): Tool => ({
  id: v4(),
  type,
  name,
  size,
});
</file>

<file path="routes/[...404].tsx">
import { Title } from '@solidjs/meta';

export default function NotFound() {
  return (
    <main>
      <Title>Not Found</Title>
      <h1>Page Not Found</h1>
      <p>
        Visit{' '}
        <a href='https://start.solidjs.com' target='_blank'>
          start.solidjs.com
        </a>{' '}
        to learn how to build SolidStart apps.
      </p>
    </main>
  );
}
</file>

<file path="routes/about/about.css.ts">
import { style } from '@vanilla-extract/css';
import { k12x8, Terminus, vars, ZFB03, ZFB08, ZFB31 } from '~/styles/global.css';
import { flexCol } from '~/styles/snippets.css';

export const aaContainer = style([
  flexCol,
  {
    position: 'absolute',
    top: '32px',
    right: '40px',
    width: '200px',
    height: '100%',
    alignItems: 'center',
    pointerEvents: 'none',
  },
]);

export const aaText = style({
  fontFamily: Terminus,
  fontSize: '22px',
  opacity: 0.4,
});

export const contentContainer = style([
  flexCol,
  {
    width: '100%',
    margin: '0 30px',
    marginTop: '8px',
    pointerEvents: 'none',
  },
]);

export const aboutLink = style({
  pointerEvents: 'all',
  borderBottom: '1px solid black',
  paddingBottom: '1px',
  ':hover': {
    borderBottom: 'none',
    color: 'magenta',
  },
});

export const aboutTitle = style({
  fontFamily: ZFB31,
  fontSize: '31px',
});

export const aboutSubTitle = style({
  fontFamily: ZFB03,
  fontSize: '9px',
  color: '#777',
});

export const aboutDev = style({
  fontFamily: ZFB08,
  fontSize: '8px',
});

export const aboutContent = style({
  fontFamily: ZFB08,
  fontSize: '8px',
  lineHeight: 1.6,
});

export const sendFBButton = style({
  width: 'fit-content',
  padding: '4px 4px',
  fontSize: '8px',
  borderColor: 'blue',
  background: vars.color.button,
  color: 'blue',
  ':hover': {
    color: 'white',
    background: 'blue',
  },
});

export const aboutFeedback = style({
  fontFamily: k12x8,
  fontSize: '8px',
  marginRight: '50px',
  lineHeight: 1.5,
});
</file>

<file path="routes/about/index.tsx">
import { WebviewOptions } from '@tauri-apps/api/webview';
import { WindowOptions } from '@tauri-apps/api/window';
import { open } from '@tauri-apps/plugin-shell';
import {
  aaContainer,
  aaText,
  aboutContent,
  aboutFeedback,
  aboutLink,
  aboutSubTitle,
  aboutTitle,
  contentContainer,
  sendFBButton,
} from './about.css';
import { pageRoot } from '~/styles/global.css';
import { flexRow, w100, wh100 } from '~/styles/snippets.css';

export const AboutWindowOptions: Omit<WebviewOptions, 'x' | 'y' | 'width' | 'height'> & WindowOptions = {
  url: '/about',
  width: 400,
  height: 290,
  resizable: false,
  decorations: false,
  minimizable: false,
  maximizable: false,
  closable: true,
  acceptFirstMouse: true,
  focus: true,
  skipTaskbar: true,
  alwaysOnTop: true,
};

const About = () => {
  const openLink = (url: string) => {
    open(url);
  };

  return (
    <div class={pageRoot}>
      <div class={`${flexRow} ${wh100}`} style={{ 'align-items': 'center' }}>
        <div class={aaContainer}>
          <p class={aaText}>
            ⠀⠀⠀⠀⠀⠀⠀⠀⢠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⢀⣀⣀⣱⣠⣤⣤⣤⣤⣶⣶⣶⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⢠⢤⣴⣷⣾⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠹⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⠁⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠹⣟⣻⠿⠿⠿⠭⢽⡿⠛⠊⠁⠁⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⢣⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡄⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⠀⠀⠀⠀⠀⠀⠀
            <br />
          </p>
        </div>
        <div class={`${contentContainer} ${w100}`}>
          <div class={`${flexRow}`} style={{ width: '360px' }}>
            <p class={aboutTitle}>SLEDGE.</p>
            {/* <p class={aboutDev} style={{ 'margin-top': '3px' }}>
              by alphendp
            </p> */}
          </div>
          <p class={aboutSubTitle} style={{ 'margin-bottom': '14px' }}>
            pre-alpha v0.1
          </p>
          <p class={aboutContent} style={{ 'margin-bottom': '50px' }}>
            made with much <span style={{ color: 'magenta' }}>love</span> for:
            <br />-{' '}
            <a class={aboutLink} onClick={(e) => openLink('https://www.sojamo.de/libraries/controlP5/')}>
              ControlP5
            </a>
            <br />-{' '}
            <a class={aboutLink} onClick={(e) => openLink('https://archlinux.org/')}>
              Arch Linux
            </a>
            <br />-{' '}
            <a class={aboutLink} onClick={(e) => openLink('https://apps.apple.com/jp/app/caustic/id775735447/')}>
              Caustic3
            </a>{' '}
            &lt;HP dead RIP&gt;
            <br />
          </p>
          <div class={[flexRow, w100].join(' ')} style={{ 'align-items': 'center' }}>
            <p class={aboutFeedback}>
              気軽に意見を投げつけよう！
              <br />
              feel FREE to send feedback!!
            </p>
            <button class={sendFBButton} onClick={(e) => openLink('https://tally.so/r/w7jZNL')}>
              &gt;&gt; send feedback
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default About;
</file>

<file path="routes/editor/index.tsx">
import { trackStore } from '@solid-primitives/deep';
import { useLocation } from '@solidjs/router';
import { UnlistenFn } from '@tauri-apps/api/event';
import { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';
import { confirm } from '@tauri-apps/plugin-dialog';
import { createEffect, createSignal, onCleanup, onMount } from 'solid-js';
import CanvasArea from '~/components/canvas/CanvasArea';
import EdgeInfo from '~/components/global/EdgeInfo';
import SideSections from '~/components/global/SideSections';
import { adjustZoomToFit, centeringCanvas, changeCanvasSize } from '~/controllers/canvas/CanvasController';
import { resetLayerImage } from '~/controllers/layer/LayerController';
import { addLayer } from '~/controllers/layer_list/LayerListController';
import { loadGlobalSettings } from '~/io/global_config/globalSettings';
import { importProjectJsonFromPath } from '~/io/project/project';
import { LayerImageManager } from '~/models/layer_image/LayerImageManager';
import { globalStore } from '~/stores/GlobalStores';
import { canvasStore, layerHistoryStore, layerListStore, projectStore, setProjectStore } from '~/stores/ProjectStores';

import { pageRoot } from '~/styles/global.css';
import { LayerType } from '~/types/Layer';
import { closeWindowsByLabel, openStartWindow, WindowOptionsProp } from '~/utils/windowUtils';

export const EditorWindowOptions: WindowOptionsProp = {
  width: 1000,
  height: 750,
  acceptFirstMouse: true,
  resizable: true,
  closable: true,
  maximizable: true,
  minimizable: true,
  decorations: false,
  fullscreen: false,
};

export const layerImageManager = new LayerImageManager();

export const getImageOf = (layerId: string) => layerImageManager.getAgent(layerId)?.getImage();

export default function Editor() {
  const window = getCurrentWebviewWindow();
  const location = useLocation();

  createEffect(() => {
    trackStore(canvasStore.canvas);
    trackStore(layerHistoryStore);
    trackStore(layerListStore);
    setProjectStore('isProjectChangedAfterSave', true);
  });

  const isNewProject = location.search === '';
  const [isLoading, setIsLoading] = createSignal(true);

  const onProjectLoad = () => {
    setProjectStore('isProjectChangedAfterSave', false);
    setIsLoading(false);

    loadGlobalSettings();

    if (isNewProject) {
      changeCanvasSize(globalStore.newProjectCanvasSize);
    }

    layerListStore.layers.forEach((layer) => {
      resetLayerImage(layer.id, 1);
    });

    adjustZoomToFit();
    centeringCanvas();
  };

  if (location.search) {
    const sp = new URLSearchParams(location.search);
    const fileName = sp.get('name');
    const filePath = sp.get('path');
    const path = `${filePath}\\${fileName}`;
    importProjectJsonFromPath(path).then(() => {
      onProjectLoad();
    });
  } else {
    // create new
    setProjectStore('name', 'new project');
    addLayer('dot', LayerType.Dot, true, 1).then(() => {
      onProjectLoad();
    });
  }

  const [isCloseRequested, SetIsCloseRequested] = createSignal(false);
  let unlisten: UnlistenFn;

  onMount(async () => {
    unlisten = await window.onCloseRequested(async (event) => {
      if (isCloseRequested()) {
        event.preventDefault();
        return;
      }
      SetIsCloseRequested(true);
      event.preventDefault();
      if (projectStore.isProjectChangedAfterSave) {
        const confirmed = await confirm('the project is not saved.\nsure to quit without save?', {
          okLabel: 'quit w/o save.',
          cancelLabel: 'cancel.',
        });
        if (confirmed) {
          await openStartWindow();
          closeWindowsByLabel('editor');
          SetIsCloseRequested(false);
        } else {
          event.preventDefault();
          SetIsCloseRequested(false);
        }
      } else {
        await openStartWindow();
        closeWindowsByLabel('editor');
        SetIsCloseRequested(false);
      }
    });
  });

  onCleanup(() => {
    unlisten();
  });

  return (
    <>
      {isLoading() && (
        <div class={pageRoot}>
          <p style={{ 'font-size': '2rem' }}>please wait.</p>
        </div>
      )}

      {!isLoading() && (
        <div class={pageRoot}>
          <EdgeInfo />
          <SideSections />
          <div style={{ 'flex-grow': 1 }}>
            <CanvasArea />
          </div>
          {/* <Companion /> */}
        </div>
      )}
    </>
  );
}
</file>

<file path="routes/index.tsx">
import { For, onMount } from 'solid-js';
import { addRecentFile } from '~/controllers/config/GlobalConfigController';
import { loadGlobalSettings } from '~/io/global_config/globalSettings';
import { importProjectJsonFromFileSelection } from '~/io/project/project';
import { globalStore, setGlobalStore } from '~/stores/GlobalStores';
import { sectionRoot } from '~/styles/section_global.css';
import { flexCol, flexRow, w100 } from '~/styles/snippets.css';
import { FileLocation } from '~/types/FileLocation';
import { getFileNameAndPath } from '~/utils/PathUtils';
import { closeWindowsByLabel, openEditorWindow, openSingletonWindow, WindowOptionsProp } from '~/utils/windowUtils';
import { SettingsWindowOptions } from './settings';
import {
  recentFilesCaption,
  recentFilesContainer,
  recentFilesItem,
  recentFilesName,
  recentFilesPath,
  sideSection,
  sideSectionItem,
  welcomeHeadline,
  welcomeRoot,
} from './start.css';

export const StartWindowOptions: WindowOptionsProp = {
  title: 'sledge',
  width: 700,
  height: 500,
  acceptFirstMouse: true,
  resizable: false,
  parent: undefined,
  closable: true,
  maximizable: true,
  minimizable: true,
  decorations: false,
  fullscreen: false,
};

export default function Home() {
  onMount(() => {
    loadGlobalSettings();
  });

  const moveToEditor = (selectedFile: FileLocation) => {
    openEditorWindow(selectedFile);
    closeWindowsByLabel('start');
  };

  const createNew = () => {
    openEditorWindow();
    closeWindowsByLabel('start');
  };

  const openProject = () => {
    importProjectJsonFromFileSelection().then((file: string | undefined) => {
      if (file !== undefined) {
        const loc = getFileNameAndPath(file);
        addRecentFile(loc);
        openEditorWindow(loc);
        closeWindowsByLabel('start');
      }
    });
  };

  const clearRecentFiles = () => {
    setGlobalStore('recentFiles', []);
  };

  return (
    <div class={welcomeRoot}>
      <div class={flexCol}>
        <p class={welcomeHeadline}>HELLO.</p>
        <div class={sideSection}>
          <a class={sideSectionItem} onClick={() => createNew()}>
            +&ensp;new.
          </a>
          <a class={sideSectionItem} style={{ 'margin-left': '2px' }} onClick={(e) => openProject()}>
            &gt;&ensp;open.
          </a>
          <a
            class={sideSectionItem}
            style={{ 'margin-left': '2px' }}
            onClick={(e) => openSingletonWindow('settings', SettingsWindowOptions)}
          >
            <img src={'/settings.png'} width={16} height={16} />
            &ensp;settings.
          </a>
        </div>

        <div class={sectionRoot}>
          <div class={[flexRow, w100].join(' ')}>
            <p class={recentFilesCaption}>recent files.</p>
            {/* <p class={clear} onClick={() => clearRecentFiles()}>
                clear
              </p> */}
          </div>
          <div class={recentFilesContainer} style={{ 'margin-bottom': '24px' }}>
            <For each={globalStore.recentFiles}>
              {(item, i) => {
                return (
                  <div class={recentFilesItem}>
                    <p>■</p>
                    <a class={recentFilesName} onClick={(e) => moveToEditor(item)}>
                      {item.name}
                    </a>
                    <p class={recentFilesPath}>{item.path}</p>
                  </div>
                );
              }}
            </For>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="routes/settings/index.tsx">
import { onCleanup, onMount } from 'solid-js';
import EditorSettings from '~/components/section/settings/EditorSettings';
import PerformanceSettings from '~/components/section/settings/PerformanceSettings';
import { loadGlobalSettings, saveGlobalSettings } from '~/io/global_config/globalSettings';
import { pageRoot } from '~/styles/global.css';
import { WindowOptionsProp } from '~/utils/windowUtils';
import { settingContainer } from './settings.css';

export const SettingsWindowOptions: WindowOptionsProp = {
  url: '/settings',
  width: 420,
  height: 290,
  resizable: false,
  decorations: false,
  minimizable: false,
  maximizable: false,
  closable: true,
  acceptFirstMouse: true,
  focus: true,
  skipTaskbar: true,
  alwaysOnTop: true,
};

export default function Settings() {
  onMount(() => {
    loadGlobalSettings();
  });

  onCleanup(async () => {
    await saveGlobalSettings();
  });

  return (
    <div class={pageRoot}>
      <form
        class={settingContainer}
        onChange={(e) => {
          saveGlobalSettings();
        }}
      >
        <EditorSettings />
        <PerformanceSettings />
      </form>
    </div>
  );
}
</file>

<file path="routes/settings/settings.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';
import { flexCol } from '~/styles/snippets.css';

export const settingContainer = style([
  flexCol,
  {
    padding: vars.spacing.lg,
    gap: vars.spacing.lg,
  },
]);
</file>

<file path="routes/start.css.ts">
import { style } from '@vanilla-extract/css';
import { ZFB03B, ZFB09, ZFB31 } from '~/styles/global.css';
import { flexCol, flexRow, w100, wh100 } from '~/styles/snippets.css';

export const welcomeRoot = style([
  flexCol,
  wh100,
  {
    alignItems: 'center',
    justifyContent: 'center',
  },
]);

export const welcomeHeadline = style({
  fontFamily: ZFB31,
  fontSize: '3rem',
  letterSpacing: '8px',
  marginBottom: '12px',
});

export const recentFilesCaption = style({
  fontFamily: ZFB03B,
  fontSize: '16px',
  color: '#000',
  flexGrow: 1,
  marginBottom: '12px',
});

export const clear = style({
  fontFamily: ZFB03B,
  fontSize: '15px',
  ':hover': {
    color: 'red',
  },
});

export const recentFilesContainer = style([
  flexCol,
  w100,
  {
    gap: '8px',
    marginTop: '4px',
  },
]);

export const recentFilesItem = style([
  flexRow,
  w100,
  {
    alignItems: 'center',
    gap: '8px',
  },
]);

export const recentFilesName = style({
  fontFamily: ZFB09,
  fontSize: '0.5rem',
  textOverflow: 'ellipsis',
  color: '#555',
  whiteSpace: 'nowrap',
});

export const recentFilesPath = style({
  fontFamily: ZFB03B,
  fontSize: '0.5rem',
  color: '#00000030',
});

export const sideSection = style([
  flexRow,
  {
    gap: '24px',
    paddingBottom: '48px',
    paddingTop: '12px',
  },
]);

export const sideSectionItem = style([
  flexRow,
  {
    cursor: 'pointer',
    fontSize: '1rem',
    width: 'fit-content',
    alignItems: 'center',
    justifyContent: 'center',
    ':hover': {
      color: 'red',
    },
  },
]);
</file>

<file path="stores/EditorStores.ts">
// editorStore.tsx
import { createStore } from 'solid-js/store';
import { createTool } from '~/models/tool/ToolFactory';
import { PaletteType } from '~/types/PaletteType';
import { Size2D } from '~/types/Size';
import { Tool, ToolType } from '~/types/Tool';
import { Vec2 } from '~/types/Vector';

type ColorStore = {
  currentPalette: PaletteType;
  primary: string;
  secondary: string;
  swatches: string[];
};
type InteractStore = {
  canvasAreaSize: Size2D;
  canvasElementSize: Size2D;
  lastMouseWindow: Vec2;
  lastMouseOnCanvas: Vec2;
  isInStroke: boolean;
  zoom: number;
  zoomMin: number;
  zoomMax: number;
  touchZoomSensitivity: number;
  wheelZoomStep: number;
  offsetOrigin: Vec2;
  offset: Vec2;

  isCtrlPressed: boolean;
  isDragging: boolean;
};
type LogStore = {
  bottomBarText: string;
};
type ToolStore = {
  usingIndex: number;
  tools: Tool[];
};

const defaultColorStore: ColorStore = {
  currentPalette: 'primary' as PaletteType,
  primary: '#000000', // 通常の描画色
  secondary: '#ffffff', // 背景・消しゴムなど
  swatches: [
    '#000000',
    '#FFFFFF',
    '#ffff00',
    '#00ffff',
    '#00ff00',
    '#ff00ff',
    '#ff0000',
    '#0000ff',
    '#000080',
    '#400080',
  ],
};
const defaultInteractStore: InteractStore = {
  canvasAreaSize: { width: 0, height: 0 },
  canvasElementSize: { width: 0, height: 0 },
  lastMouseWindow: { x: 0, y: 0 },
  lastMouseOnCanvas: { x: 0, y: 0 },
  isInStroke: false,
  zoom: 1,
  zoomMin: 0.5,
  zoomMax: 8,
  touchZoomSensitivity: 0.5,
  wheelZoomStep: 0.05,
  // オフセットの初期値
  offsetOrigin: { x: 0, y: 0 },
  offset: { x: 0, y: 0 },

  isCtrlPressed: false,
  isDragging: false,
};
const defaultLogStore: LogStore = {
  bottomBarText: '',
};
const defaultToolStore: ToolStore = {
  usingIndex: 0,
  tools: [
    createTool(ToolType.Pen, 'pen', 1),
    createTool(ToolType.Eraser, 'eraser', 1),
    createTool(ToolType.Fill, 'fill', 1),
  ],
};

export const initEditorStore = () => {
  const [colorStore, setColorStore] = createStore<ColorStore>(defaultColorStore);
  const [interactStore, setInteractStore] = createStore<InteractStore>(defaultInteractStore);
  const [toolStore, setToolStore] = createStore<ToolStore>(defaultToolStore);
  const [logStore, setLogStore] = createStore<LogStore>(defaultLogStore);

  return {
    colorStore,
    setColorStore,
    interactStore,
    setInteractStore,
    logStore,
    setLogStore,
    toolStore,
    setToolStore,
  };
};

const editorStore = initEditorStore();

export const colorStore = editorStore.colorStore;
export const setColorStore = editorStore.setColorStore;

export const interactStore = editorStore.interactStore;
export const setInteractStore = editorStore.setInteractStore;

export const logStore = editorStore.logStore;
export const setLogStore = editorStore.setLogStore;

export const toolStore = editorStore.toolStore;
export const setToolStore = editorStore.setToolStore;
</file>

<file path="stores/GlobalStores.ts">
import { createStore } from 'solid-js/store';
import { CanvasRenderingMode } from '~/types/Canvas';
import { FileLocation } from '~/types/FileLocation';
import { Size2D } from '~/types/Size';

// global
export const getCanvasImageRenderingAttribute = (
  zoom: number,
  mode: CanvasRenderingMode
): 'pixelated' | 'crisp-edges' => {
  switch (mode) {
    case 'pixelated':
      return 'pixelated';
    case 'crispEdges':
      return 'crisp-edges';
    case 'adaptive':
      return zoom > 1.0 ? 'pixelated' : 'crisp-edges';
  }
};

type GlobalConfigStore = {
  maxRecentFiles: number;
  recentFiles: FileLocation[];
  newProjectCanvasSize: Size2D;
  canvasRenderingMode: CanvasRenderingMode;
  showDirtyRects: boolean;
  showPerfMonitor: boolean;
};
const defaultGlobalConfigStore: GlobalConfigStore = {
  maxRecentFiles: 8,
  recentFiles: [],

  newProjectCanvasSize: {
    width: 1000,
    height: 1000,
  },
  canvasRenderingMode: 'adaptive' as CanvasRenderingMode,

  showDirtyRects: false,
  showPerfMonitor: false,
};

const initGlobalStore = () => {
  const [globalConfigStore, setGlobalConfigStore] = createStore(defaultGlobalConfigStore);
  return { globalConfigStore, setGlobalConfigStore };
};

let globalRootStore = initGlobalStore();

export const globalStore = globalRootStore.globalConfigStore;
export const setGlobalStore = globalRootStore.setGlobalConfigStore;
</file>

<file path="stores/ProjectStores.ts">
// projectStore.ts
import { createStore } from 'solid-js/store';
import { Layer } from '~/types/Layer';
import { LayerHistory } from '~/types/LayerHistory';
import { Size2D } from '~/types/Size';
import { decodeImageData } from '~/utils/ImageUtils';
import { globalStore } from './GlobalStores';
import { resetLayerImage } from '~/controllers/layer/LayerController';

type CanvasStore = {
  canvas: Size2D;
};
type ProjectStore = {
  newName: string | undefined;
  name: string | undefined;
  path: string | undefined;
  isProjectChangedAfterSave: boolean;
};
type LayerHistoryStore = Record<string, LayerHistory>;
type LayerListStore = {
  layers: Layer[];
  activeLayerId: string;
};

const defaultProjectStore: ProjectStore = {
  newName: undefined as string | undefined,
  name: undefined as string | undefined,
  path: undefined as string | undefined,
  isProjectChangedAfterSave: false,
};
const defaultCanvasStore: CanvasStore = {
  canvas: {
    width: 400,
    height: 400,
  },
};
const defaultLayerHistoryStore: LayerHistoryStore = {};
const defaultLayerListStore: LayerListStore = {
  layers: new Array<Layer>(),
  activeLayerId: '',
};

export const initProjectStore = () => {
  const [canvasStore, setCanvasStore] = createStore<CanvasStore>(defaultCanvasStore);
  const [projectStore, setProjectStore] = createStore<ProjectStore>(defaultProjectStore);
  const [layerHistoryStore, setLayerHistoryStore] = createStore<LayerHistoryStore>(defaultLayerHistoryStore);
  const [layerListStore, setLayerListStore] = createStore<LayerListStore>(defaultLayerListStore);

  console.log(globalStore.newProjectCanvasSize);
  setCanvasStore('canvas', globalStore.newProjectCanvasSize);

  return {
    canvasStore,
    setCanvasStore,
    layerListStore,
    setLayerListStore,
    layerHistoryStore,
    setLayerHistoryStore,
    projectStore,
    setProjectStore,
  };
};

const projectRootStore = initProjectStore();

export const canvasStore = projectRootStore.canvasStore;
export const setCanvasStore = projectRootStore.setCanvasStore;

export const layerListStore = projectRootStore.layerListStore;
export const setLayerListStore = projectRootStore.setLayerListStore;

export const layerHistoryStore = projectRootStore.layerHistoryStore;
export const setLayerHistoryStore = projectRootStore.setLayerHistoryStore;

export const projectStore = projectRootStore.projectStore;
export const setProjectStore = projectRootStore.setProjectStore;

export const loadStoreFromProjectJson = async (projectJson: any) => {
  if (projectJson.project) {
    console.log(projectJson.project);
    setProjectStore('name', projectJson.project.name || undefined);
    setProjectStore('path', projectJson.project.path || undefined);
  }

  if (projectJson.canvas) {
    const { width, height } = projectJson.canvas;
    setCanvasStore('canvas', 'width', width);
    setCanvasStore('canvas', 'height', height);
  }

  if (projectJson.images) {
    setLayerHistoryStore({});
    Object.keys(projectJson.images).forEach((id) => {
      const imageData = projectJson.images[id];
      const agent = resetLayerImage(id, Number(imageData.dotMagnification || 1));
      const image = decodeImageData(imageData.current, Number(imageData.width), Number(imageData.height));
      agent.setImage(image);
    });
  }

  if (projectJson.layer && projectJson.layer.layers && Array.isArray(projectJson.layer.layers)) {
    const layers: Layer[] = [];
    projectJson.layer.layers.map((l: any) => {
      layers.push({
        ...l,
        dsl: undefined,
      } as Layer);
    });

    setLayerListStore('layers', layers);
    setLayerListStore('activeLayerId', projectJson.layer.activeLayerId);
  }
};
</file>

<file path="styles/components/bottom_info.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';
import { flexRow, w100 } from '../snippets.css';

export const bottomInfoRoot = style([
  flexRow,
  w100,
  {
    position: 'fixed',
    backgroundColor: vars.color.bg,
    borderTop: '1px solid #aaa',
    height: '20px',
    alignItems: 'center',
    padding: `0 ${vars.spacing.md}`,
    margin: 0,
    bottom: 0,
    gap: vars.spacing.md,
  },
]);

export const bottomInfoText = style({});
</file>

<file path="styles/components/canvas/canvas_area.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';
import { flexCol } from '../../snippets.css';

export const canvasArea = style([
  flexCol,
  {
    backgroundColor: vars.color.bg_canvas_area,
    display: 'flex',
    position: 'relative',
    height: '100%',
    overflow: 'hidden',
  },
]);
</file>

<file path="styles/components/canvas/canvas_debug_overlay.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';
import { flexCol, flexRow } from '~/styles/snippets.css';

export const canvasDebugOverlayTopLeft = style([
  flexCol,
  {
    // gap: vars.spacing.xs,
    position: 'absolute',
    left: vars.spacing.sm,
    top: vars.spacing.sm,
    pointerEvents: 'none',
  },
]);

export const canvasDebugOverlayBottomLeft = style([
  flexRow,
  {
    // gap: vars.spacing.xs,
    position: 'absolute',
    left: vars.spacing.sm,
    bottom: 0,
    transform: 'translateY(-50%)',
    alignItems: 'end',
    gap: vars.spacing.md,
    pointerEvents: 'none',
  },
]);
</file>

<file path="styles/components/canvas/canvas_stack.css.ts">
'background-image';
import { style } from '@vanilla-extract/css';
import { flexRow } from '~/styles/snippets.css';

const transparent_bg_size = 4;
const transparent_bg_color = '#0000000A';

export const canvasStack = style([
  flexRow,
  {
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',

    backgroundImage:
      `linear-gradient(45deg, ${transparent_bg_color} 25%, transparent 25%, transparent 75%, ${transparent_bg_color} 75%),` +
      `linear-gradient(45deg, ${transparent_bg_color} 25%, transparent 25%, transparent 75%, ${transparent_bg_color} 75%)`,
    backgroundSize: `${transparent_bg_size * 2}px ${transparent_bg_size * 2}px`,
    backgroundPosition: `0 0, ${transparent_bg_size}px ${transparent_bg_size}px`,
  },
]);
</file>

<file path="styles/components/canvas/canvas_stack.module.css">
.canvas_stack {
  align-items: center;
  display: flex;
  justify-content: center;
  position: relative;
}

.image-container:focus-within {
  border: 2px black solid;
}

.resize-image {
  height: 100%;
  object-fit: fill;
  width: 100%;
}
</file>

<file path="styles/components/canvas/controls.module.css">
.cursor {
  background-color: black;
  height: 4px;
  left: 220px;
  position: absolute;
  top: 170px;
  width: 4px;
}

.top-right-button-container {
  display: flex;
  flex-direction: row;
  gap: 10px;
  position: absolute;
  right: 30px;
  top: 20px;
}

.top-right-nav {
  display: flex;
  flex-direction: row;
  gap: 25px;
  position: absolute;
  right: 30px;
  top: 30px;
}

.bottom-history {
  bottom: 50px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  position: absolute;
}

.history-row {
  display: flex;
  gap: 20px;
  opacity: 0.2;
  width: 60%;
}

.history-text {
  white-space: nowrap;
}

.undo_redo {
  cursor: pointer;
  height: 24px;
  image-rendering: pixelated;
  padding: 8px;
  pointer-events: all;
  width: 24px;
}
</file>

<file path="styles/components/canvas/image_pool.module.css">
.resize-drag-container {
  /* This makes things *much* easier */
  box-sizing: border-box;
  font-family: sans-serif;
  left: 0;
  padding: 0;
  position: absolute;
  top: 0;
  touch-action: none;
  width: 120px;
  z-index: 100;
}

.image-container {
  height: 100%;
  width: 100%;
}
</file>

<file path="styles/components/canvas/layer_canvas.css.ts">
import { style } from '@vanilla-extract/css';

export const layerCanvas = style({});
</file>

<file path="styles/components/checkbox.css.ts">
import { style } from '@vanilla-extract/css';

export const checkboxWrapper = style({
  display: 'inline-flex',
  alignItems: 'center',
  cursor: 'pointer',
  position: 'relative',
});

export const hiddenCheckbox = style({
  opacity: 0,
  width: 0,
  height: 0,
  position: 'absolute',
});

export const customCheckbox = style({
  width: '10px',
  height: '10px',
  border: '1px solid #000',
  borderRadius: '0px',
  marginRight: '8px',
  display: 'inline-block',
  position: 'relative',
  overflow: 'hidden',
  transition: 'all 0.1s',
  selectors: {
    [`&::before`]: {
      content: '',
      position: 'absolute',
      left: '50%',
      top: '50%',
      width: '14px', // √2倍ちょい弱くらい
      height: '1px',
      backgroundColor: 'red',
      opacity: 0,
      transform: 'translate(-50%, -50%) rotate(45deg)',
      transformOrigin: 'center center',
      transition: 'opacity 0.1s',
    },
    [`&::after`]: {
      content: '',
      position: 'absolute',
      left: '50%',
      top: '50%',
      width: '14px',
      height: '1px',
      backgroundColor: 'red',
      opacity: 0,
      transform: 'translate(-50%, -50%) rotate(-45deg)',
      transformOrigin: 'center center',
      transition: 'opacity 0.1s',
    },
    [`${checkboxWrapper} input:checked + &::before`]: {
      opacity: 1,
    },
    [`${checkboxWrapper} input:checked + &::after`]: {
      opacity: 1,
    },
  },
});
</file>

<file path="styles/components/companion.module.css">
.root {
  bottom: 0;
  left: 500px;
  pointer-events: none;
  position: absolute;
  z-index: 999;
}

.wrapper {
  animation: fluffy 2s ease-in-out infinite;
  height: 300px;
  transform-origin: center center;
  width: 300px;
}

.companion {
  anchor-name: --companion;
  display: flex;
  flex-direction: column;
  height: 50px;
  image-rendering: pixelated;
  margin: 80px auto;
  margin-left: 0;
  width: 50px;
}

.giggle {
  animation: giggle 0.5s;
  animation-iteration-count: 10;
}

.quote_box_container {
  background-color: #ddd;
  bottom: calc(anchor(top) + 17px);
  justify-self: anchor-center;
  position: absolute;
  position-anchor: --companion;
  width: fit-content;
}

.quote_box {
  anchor-name: --box;
  background: #fff;
  border: solid 1px #555;
  border-radius: 3px;
  max-width: 200px;
  overflow-wrap: break-word;
  padding: 12px;
  width: fit-content;
}

.quote_box::before {
  border: 7px solid transparent;
  border-top: 7px solid #fff;
  content: '';
  padding-left: 1px;
  position: absolute;
  position-anchor: --companion;
  top: calc(anchor(--box bottom) - 2px);
  z-index: 2;
}

.quote_box::after {
  border: 8px solid transparent;
  border-top: 8px solid #555;
  content: '';
  position: absolute;
  position-anchor: --companion;
  top: calc(anchor(--box bottom) - 1px);
}

.quote {
  image-rendering: pixelated;
}

@keyframes fluffy {
  0%,
  100% {
    transform: translateY(0);
  }

  50% {
    transform: translateY(-5px);
  }
}

@keyframes giggle {
  0% {
    transform: rotate(0deg);
  }

  25% {
    transform: rotate(2deg);
  }

  50% {
    transform: rotate(0deg);
  }

  75% {
    transform: rotate(-2deg);
  }

  100% {
    transform: rotate(0deg);
  }
}
</file>

<file path="styles/components/dropdown.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';

export const dropdownRoot = style({
  fontFamily: vars.font.body,
  fontSize: vars.text.sm,
  backgroundColor: vars.color.secondary,
  border: '0px solid black',
  borderRadius: '0px',
  padding: '2px 6px',
  height: '20px',
  cursor: 'pointer',
  lineHeight: '12px',

  selectors: {
    '&:hover': { backgroundColor: vars.color.button_hover },
    '&:active': {
      backgroundColor: vars.color.button_pressed,
    },
    /* Windows の ▼ 矢印が滲むのを抑止 */
    '&::-ms-expand': { display: 'none' },
  },
});
</file>

<file path="styles/components/dsl_button.module.css">
.root {
  cursor: pointer;
  height: 20px;
  image-rendering: pixelated;
  margin: 4px;
  opacity: 0.7;
  pointer-events: all;
  width: 20px;
}

.root:hover {
  opacity: 0.3;
  transform: translate(0, 1px);
}
</file>

<file path="styles/components/edge_info.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';
import { flexCol, flexRow } from '../snippets.css';

export const edgeInfoRoot = style([
  flexCol,
  {
    position: 'absolute',
    top: 0,
    bottom: 0,
    left: 0,
    gap: '10px',
    paddingTop: '32px',
    width: vars.size.edge_info,
    justifyContent: 'start',
    alignItems: 'center',
  },
]);
export const edgeInfoItem = style([
  flexRow,
  {
    position: 'relative',
    justifyContent: 'center',
  },
]);

export const edgeInfoText = style({
  fontSize: '0.5rem',
  letterSpacing: '2px',
  whiteSpace: 'nowrap',
  transform: 'rotate(180deg)',
  transformOrigin: 'center',
  writingMode: 'vertical-lr',
});
</file>

<file path="styles/components/layer_preview.module.css">
.canvas {
  height: 100%;
  width: 100%;
  image-rendering: crisp-edges;
  border-right: 1px solid black;
}
</file>

<file path="styles/components/light.module.css">
.light-inner {
  filter: drop-shadow(0 0 0 red);
  opacity: 0;
  transition: none;
}

.light-inner.on {
  filter: drop-shadow(0 0 1px red);
  opacity: 1;
  transition: opacity 01s ease;
}
</file>

<file path="styles/components/palette.css.ts">
import { style } from '@vanilla-extract/css';
import { flexRow } from '../snippets.css';

export const paletteRoot = style([
  flexRow,
  {
    gap: '6px',
  },
]);

export const paletteColorBoxContainer = style({
  position: 'relative',
});

export const paletteColorBoxPrimary = style({
  position: 'absolute',
  top: 0,
  left: 0,
});

export const paletteColorBoxSecondary = style({
  position: 'absolute',
  top: 10,
  left: 10,
});
</file>

<file path="styles/components/radio_button.css.ts">
import { style } from '@vanilla-extract/css';
import { checkboxWrapper } from '~/styles/components/checkbox.css';

export const radioWrapper = checkboxWrapper; // チェックボックスと共通でOK！

export const hiddenRadio = style({
  opacity: 0,
  width: 0,
  height: 0,
  position: 'absolute',
});

export const customRadio = style({
  width: '10px',
  height: '10px',
  border: '1px solid #000',
  borderRadius: '0px', // 今は四角、丸くしたかったら '50%' にするだけ
  marginLeft: '8px',
  display: 'inline-block',
  position: 'relative',
  transition: 'all 0.1s',
  selectors: {
    [`&::after`]: {
      content: '',
      position: 'absolute',
      left: '2px',
      top: '2px',
      width: '6px',
      height: '6px',
      backgroundColor: 'red',
      opacity: 0,
      transition: 'opacity 0.1s',
    },
    [`${radioWrapper} input:checked + &::after`]: {
      opacity: 1,
    },
  },
});
</file>

<file path="styles/components/side_sections.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';
import { flexCol, h100 } from '../snippets.css';

export const sideAreaContent = style([
  flexCol,
  h100,
  {
    borderRight: '1px solid #aaa',
    gap: '1rem',
    marginLeft: vars.size.edge_info,
    padding: '20px 30px 90px 20px',
    width: vars.size.side_area,
    overflowY: 'scroll',

    '::-webkit-scrollbar': {
      width: '4px',
    },
    '::-webkit-scrollbar-thumb': {
      backgroundColor: 'transparent',
    },
    selectors: {
      '&:hover::-webkit-scrollbar-thumb': {
        backgroundColor: '#ddd',
      },
    },
  },
]);
</file>

<file path="styles/components/slider.module.css">
.root {
  width: 100%;
}

.slider {
  align-items: center;
  display: flex;
  height: auto;
  overflow: visible;
  position: relative;
  width: 100%;
}

.line-hitbox {
  align-items: center;
  background-color: transparent;
  cursor: pointer;
  display: flex;
  height: 16px;
  position: absolute;
  width: 100%;
}

.line {
  background-color: black;
  display: flex;
  height: 1px;
  pointer-events: none; /* イベントは親に任せる */
  width: 100%;
}

.handle-hitbox {
  align-items: center;

  /* ユーザーには見えないけどクリックできる */
  background-color: transparent;
  cursor: pointer;
  display: flex;
  height: 24px;
  position: absolute;
  transform: translateX(-50%);
  width: 20px;
}

.handle {
  background-color: black;
  height: 8px;
  left: 50%;
  pointer-events: none; /* イベントは親に任せる */
  position: absolute;
  transform: translateX(-50%);
  width: 2px;
}
</file>

<file path="styles/components/title_bar.css.ts">
import { style } from '@vanilla-extract/css';
import { vars, ZFB08 } from '../global.css';
import { flexCol, flexRow, h100, w100 } from '../snippets.css';

export const titleBarRoot = style([
  flexRow,
  w100,
  {
    background: '#fff',
    pointerEvents: 'all',
    height: '28px',
    // borderBottom: "1px solid #aaa",
    alignItems: 'center',
    zIndex: 9999,
  },
]);

export const titleBarTitle = style([
  flexRow,
  w100,
  {
    width: 'fit-content',
    fontFamily: ZFB08,
    fontSize: vars.text.sm,
    marginRight: 'auto',
    paddingLeft: vars.spacing.lg,
    pointerEvents: 'none',
  },
]);

export const titleBarControls = style([
  flexRow,
  h100,
  {
    gap: vars.spacing.sm,
    marginRight: vars.spacing.sm,
  },
]);

export const titleBarControlButton = style([
  flexCol,
  h100,
  {
    background: 'none',
    backgroundColor: 'transparent',
    border: 'none',
    alignItems: 'center',
    justifyContent: 'center',
    minWidth: '24px',
    ':hover': {
      backgroundColor: 'transparent',
    },
  },
]);

export const titleBarControlMinimizeButton = style([
  titleBarControlButton,
  {
    ':hover': {
      filter: 'invert(9%) sepia(100%) saturate(6812%) hue-rotate(247deg) brightness(96%) contrast(146%);', // 青っぽく
    },
  },
]);

export const titleBarControlMaximizeButton = style([
  titleBarControlButton,
  {
    ':hover': {
      filter: 'invert(92%) sepia(20%) saturate(3846%) hue-rotate(112deg) brightness(105%) contrast(102%);', // 緑っぽく
    },
  },
]);

export const titleBarControlCloseButton = style([
  titleBarControlButton,
  {
    ':hover': {
      filter: 'invert(11%) sepia(92%) saturate(7351%) hue-rotate(0deg) brightness(99%) contrast(109%);', // 赤っぽく
    },
  },
]);

export const titleBarControlButtonImg = style({
  width: '10px',
  height: '10px',
  imageRendering: 'pixelated',
});
</file>

<file path="styles/components/toggle_switch.css.ts">
import { globalStyle, style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';

const globalWidth = 16;
const thumbWidth = 10;
const thumbPadding = 2;
const globalHeight = 10;

/* ラベル全体 */
export const toggleWrapper = style({
  display: 'inline-flex',
  alignItems: 'center',
  gap: vars.spacing.sm,
  cursor: 'pointer',
  userSelect: 'none',
});

/* 入力本体 (隠す) */
export const toggleInput = style({
  opacity: 0,
  width: 0,
  height: 0,
  position: 'absolute',
});

/* バックグラウンドとなるトラック */
export const toggleTrack = style({
  width: `${globalWidth}px`,
  height: `${globalHeight}px`,
  backgroundColor: vars.color.muted,
  border: '1px solid black',
  borderRadius: '0px',
  position: 'relative',
  transition: 'background-color 0.05s',
});

/* つまみ */
export const toggleThumb = style({
  position: 'absolute',
  top: '-1px',
  left: '-1px',
  width: `${thumbWidth - thumbPadding}px`,
  height: `${globalHeight}px`,
  backgroundColor: vars.color.button,
  border: '1px solid black',
  borderRadius: '0px',
  transition: 'transform 0.02s',
});

/* ───────── 状態連動スタイル ───────── */

/* input が :checked のとき隣接する track を赤系へ */
globalStyle(`${toggleInput}:checked + ${toggleTrack}`, {
  backgroundColor: vars.color.danger,
});

/* さらに thumb を右へスライド */
globalStyle(`${toggleInput}:checked + ${toggleTrack} ${toggleThumb}`, {
  transform: `translateX(${globalWidth - thumbWidth + 2}px)`,
});
</file>

<file path="styles/global.css.ts">
import { createGlobalTheme, fontFace, globalStyle, style } from '@vanilla-extract/css';

export const ZFB03 = fontFace({
  src: 'url("/fonts/04B_03__.ttf")',
});
export const ZFB03B = fontFace({
  src: 'url("/fonts/04B_03B_.ttf")',
});
export const ZFB08 = fontFace({
  src: 'url("/fonts/04B_08__.ttf")',
});
export const ZFB09 = fontFace({
  src: 'url("/fonts/04B_09__.ttf")',
});
export const ZFB11 = fontFace({
  src: 'url("/fonts/04B_11__.ttf")',
});
export const ZFB31 = fontFace({
  src: 'url("/fonts/04B_31__.ttf")',
});
export const Terminus = fontFace({
  src: 'url("/fonts/terminus/TerminusTTF-4.49.3.ttf")',
});
export const k8x12 = fontFace({
  src: 'url("/fonts/k8x12/k8x12.ttf")',
});
export const k8x12L = fontFace({
  src: 'url("/fonts/k8x12/k8x12L.ttf")',
});
export const k8x12S = fontFace({
  src: 'url("/fonts/k8x12/k8x12S.ttf")',
});
export const k12x8 = fontFace({
  src: 'url("/fonts/k12x8/k12x8.ttf")',
});

export const vars = createGlobalTheme(':root', {
  color: {
    primary: '#ffffff',
    secondary: '#f0f0f0',
    text: '#111111',
    danger: '#ff0000',
    muted: '#00000030',

    accent: '#0000ff',

    bg: '#ffffff',
    bg_canvas_area: '#fefefe',

    surface: '#f2f2f2',

    button: '#ffffff',
    button_hover: '#f0f0f0',
    button_pressed: '#f0f0f0',

    input_bg: '#fafafa',
  },
  size: {
    edge_info: '32px',
    side_area: '220px',
    bottom_bar_margin: '252px',
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '12px',
    lg: '16px',
    xl: '24px',
  },
  text: {
    xs: '6px',
    sm: '8px',
    md: '10px',
    lg: '12px',
    xl: '16px',
  },
  font: {
    body: `${ZFB08}, ${k8x12}`,
  },
});

globalStyle('button, p, a, input, label', {
  fontFamily: `${ZFB08}, ${k12x8}`,
  color: vars.color.text,
});

globalStyle('a:hover', {
  color: 'red',
});

globalStyle('button', {
  background: vars.color.button,
  border: '1px black solid',
  borderRadius: '2px',
  cursor: 'pointer',
  fontSize: '0.5rem',
  height: 'fit-content',
  padding: '2px 6px',
  pointerEvents: 'all',
  width: 'fit-content',
});

globalStyle('button:hover', {
  background: vars.color.button_hover,
});

globalStyle('button:active', {
  background: vars.color.button_pressed,
  transform: 'translateY(1px)',
});

export const pageRoot = style({
  display: 'flex',
  flexDirection: 'row',
  height: '100%',
  width: '100vw',
  userSelect: 'none',
});

export const sledgeLogo = style({
  bottom: '2px',
  position: 'absolute',
  right: '2px',
});
</file>

<file path="styles/reset.css.ts">
import { globalStyle } from '@vanilla-extract/css';

globalStyle('html, body', {
  height: '100vh',
  width: '100vw',
  margin: 0,
  overflow: 'hidden',
  padding: 0,
  touchAction: 'none',
  display: 'flex',
  flexDirection: 'row',
  userSelect: 'none',
});

globalStyle('main', {
  height: '100%',
  width: '100vw',
  userSelect: 'none',
});

globalStyle('p, a, label', {
  fontSize: '0.5rem',
  letterSpacing: '1px',
  margin: 0,
});

globalStyle('ul', {
  listStyle: 'none',
  paddingLeft: 0,
});

globalStyle('a', {
  cursor: 'pointer',
});

globalStyle('input', {
  border: 'none',
  outline: 'none',
  borderBottom: '1px solid black',
  fontSize: '0.5rem',
});

globalStyle('input::-webkit-outer-spin-button, input::-webkit-inner-spin-button', {
  appearance: 'none',
  margin: 0,
});
</file>

<file path="styles/section_global.css.ts">
import { style } from '@vanilla-extract/css';
import { vars, ZFB11 } from './global.css';
import { flexCol, w100 } from './snippets.css';

export const sectionRoot = style([
  flexCol,
  {
    // border: '1px solid black',
  },
]);

export const sectionCaption = style({
  fontFamily: ZFB11,
  fontSize: vars.text.sm,
  marginBottom: vars.spacing.sm,
});

export const sectionContent = style([flexCol, w100]);
</file>

<file path="styles/section/canvas.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';
import { flexRow } from '../snippets.css';

export const canvasSizeForm = style([
  flexRow,
  {
    alignItems: 'flex-end',
    marginBottom: '6px',
  },
]);

export const canvasSizeLabel = style({
  fontSize: vars.text.sm,
});

export const canvasSizeInput = style({
  fontSize: vars.text.md,
  margin: `${vars.spacing.xs}`,
  width: '50px',
});

export const canvasSizeButton = style({
  margin: vars.spacing.sm,
});
</file>

<file path="styles/section/color.css.ts">
import { style } from '@vanilla-extract/css';
import { vars, ZFB03 } from '../global.css';
import { flexCol } from '../snippets.css';

export const swatchContainer = style([
  flexCol,
  {
    position: 'relative',
    gap: vars.spacing.xs,
    marginRight: vars.spacing.md,
  },
]);

export const descriptionContainer = style([
  flexCol,
  {
    justifyContent: 'end',
    marginBottom: vars.spacing.sm,
  },
]);

export const colorElemDescription = style({
  color: vars.color.muted,
  fontFamily: ZFB03,
  fontSize: vars.text.sm,
  transform: 'rotate(180deg)',
  whiteSpace: 'nowrap',
  writingMode: 'vertical-rl',
});

export const colorContent = style([
  flexCol,
  {
    marginLeft: vars.spacing.sm,
  },
]);
</file>

<file path="styles/section/layer.css.ts">
import { style } from '@vanilla-extract/css';
import { vars, ZFB03B } from '../global.css';
import { flexCol, flexRow, w100 } from '../snippets.css';

export const layerList = style([
  flexCol,
  w100,
  {
    flexGrow: 1,
    position: 'relative',
    gap: vars.spacing.xs,
    // border: '1px solid #333',
  },
]);

export const layerItem = style([
  flexRow,
  w100,
  {
    height: '36px',
    flexGrow: 1,
    cursor: 'pointer',
    backgroundColor: vars.color.surface,
    borderLeft: '3px solid #333',

    ':hover': {
      filter: 'brightness(0.94)',
    },
    ':active': {
      transform: 'translate(0, 1px)',
    },
  },
]);

export const layerItemDisabled = style({
  opacity: 0.3,
});

export const layerItemIndex = style([
  {
    flexGrow: 1,
    fontSize: vars.text.sm,
  },
]);

export const layerItemType = style({
  whiteSpace: 'nowrap',
  fontSize: vars.text.sm,
  opacity: 0.4,
});

export const layerItemName = style([
  {
    fontSize: vars.text.xl,
    fontFamily: ZFB03B,
    margin: `${vars.spacing.md} 0 0 ${vars.spacing.lg}`,
  },
]);

export const dotMagnifContainer = style([
  {
    alignSelf: 'center',
    // border: '1px black solid',
    // borderRadius: vars.spacing.xs,
    cursor: 'pointer',
    marginTop: vars.spacing.sm,
    marginLeft: 'auto',
    marginRight: 0,
    padding: `2px ${vars.spacing.xs}`,
    pointerEvents: 'all',

    ':hover': {
      color: vars.color.muted,
    },
  },
]);

export const dotMagnifText = style([
  {
    fontFamily: ZFB03B,
    fontSize: vars.text.lg,
  },
]);

export const activeLight = style([
  {
    alignSelf: 'center',
    margin: `${vars.spacing.sm}px 0`,
    marginLeft: vars.spacing.sm,
    marginRight: vars.spacing.md,
  },
]);

export const dropPlaceholder = style([
  {
    border: '2px dashed #aaa',
    borderRadius: vars.spacing.md,
    height: '32px',
    margin: `${vars.spacing.xs}px 0`,
  },
]);
</file>

<file path="styles/section/pen.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';
import { flexRow, w100 } from '../snippets.css';

export const toolConfigRow = style([
  flexRow,
  w100,
  {
    gap: vars.spacing.md,
    alignItems: 'center',
  },
]);
export const toolConfigRowClickable = style([
  flexRow,
  {
    gap: vars.spacing.md,
    alignItems: 'center',
    width: '35%',
  },
]);

export const toolConfigRowName = style({
  cursor: 'pointer',
  fontSize: vars.text.sm,
  padding: `${vars.spacing.md} 0`,
  pointerEvents: 'all',
});

export const toolConfigRowIcon = style({
  ':hover': {
    filter: 'invert(11%) sepia(92%) saturate(7351%) hue-rotate(0deg) brightness(99%) contrast(109%);', // 赤っぽく
  },
});
</file>

<file path="styles/section/project.css.ts">
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';

export const projectNameInput = style({
  border: 'none',
  fontSize: vars.text.xl,
  marginBottom: vars.spacing.sm,
  marginLeft: '-2px',
  outline: 'none',

  '::placeholder': {
    opacity: 0.5,
  },
});

export const saveLog = style({
  color: 'limegreen',
  marginLeft: vars.spacing.sm,
});
</file>

<file path="styles/snippets.css.ts">
import { style } from '@vanilla-extract/css';

export const flexCol = style({
  display: 'flex',
  flexDirection: 'column',
});

export const flexRow = style({
  display: 'flex',
  flexDirection: 'row',
});

export const w100 = style({
  width: '100%',
});

export const h100 = style({
  height: '100%',
});

export const wh100 = style([w100, h100]);
</file>

<file path="types/Canvas.ts">
export type Canvas = {
  width: number;
  height: number;
};

export type ImageRenderingAttribute = 'auto' | 'pixelated' | 'crispEdges';
export type CanvasRenderingMode = 'adaptive' | 'pixelated' | 'crispEdges';
</file>

<file path="types/DrawState.ts">
export enum DrawState {
  start,
  move,
  end,
}
</file>

<file path="types/FileLocation.ts">
export type FileLocation = {
  path: string;
  name: string;
};
</file>

<file path="types/Layer.ts">
import { DSL } from '~/models/dsl/DSL';

export enum LayerType {
  Dot,
  Image,
  Automate,
}

export type Layer = {
  id: string;
  name: string;
  type: LayerType;
  typeDescription: string; // 各タイプの説明
  enabled: boolean;
  dotMagnification: number;
  dsl: DSL;
};
</file>

<file path="types/LayerHistory.ts">
import { DiffAction } from '../models/layer_image/HistoryManager';

export type LayerHistory = {
  undoStack: DiffAction[];
  redoStack: DiffAction[];
};
</file>

<file path="types/PaletteType.ts">
export enum PaletteType {
  primary = 'primary',
  secondary = 'secondary',
}
</file>

<file path="types/Size.ts">
export type Size2D = {
  width: number;
  height: number;
};
</file>

<file path="types/Tile.ts">
import { RGBAColor } from '~/utils/ColorUtils';
import { Vec2 } from './Vector';

export interface TileIndex {
  row: number;
  column: number;
}

export default class Tile {
  // 一連の動作全体で変更があったか（累計表示、UI表示用）
  public isDirtyThroughAction: boolean;
  // 前回の描画更新から変更があったか（canvas更新用）
  public isDirty: boolean;

  // このタイルが単色（すべて同一RGBA）なら true
  public isUniform = false;
  // 単色時のカラーキャッシュ
  public uniformColor: RGBAColor | undefined = undefined;

  constructor(
    public readonly row: number,
    public readonly column: number,
    public readonly globalTileSize: number
  ) {
    this.isDirtyThroughAction = false;
    this.isDirty = false;
  }

  toString(): string {
    return `Tile[${this.row},${this.column}]`;
  }

  public getOffset(): Vec2 {
    return {
      x: this.column * this.globalTileSize,
      y: this.row * this.globalTileSize,
    };
  }

  public isInBounds(positionInTile: Vec2) {
    return (
      positionInTile.x >= 0 &&
      positionInTile.x < this.globalTileSize &&
      positionInTile.y >= 0 &&
      positionInTile.y < this.globalTileSize
    );
  }

  updateState() {}
}
</file>

<file path="types/Tool.ts">
export enum ToolType {
  Pen = 'pen',
  Eraser = 'eraser',
  Fill = 'fill',
}

export type Tool = {
  type: ToolType;
  id: string;
  name: string;
  size: number;
};
</file>

<file path="types/Vector.ts">
export interface Vec2 {
  x: number;
  y: number;
}
</file>

<file path="utils/ColorUtils.ts">
export type RGBColor = [number, number, number];
export type RGBAColor = [number, number, number, number];

// "#rrggbb" -> r/g/b
export function hexToRGB(hex: string): RGBColor {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

// "#rrggbbaa" -> r/g/b/a
export function hexToRGBA(hex: string): RGBAColor {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  let a = parseInt(hex.slice(7, 9), 16);
  if (!a) a = 255; // ここがなかったので a=NaN となり、塗る際にエラー？
  return [r, g, b, a];
}

export function colorMatch(a: RGBAColor, b: RGBAColor): boolean {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
</file>

<file path="utils/consts.ts">
export const Consts = {
  maxPenSize: 20,
  minCanvasWidth: 1,
  maxCanvasWidth: 5000,
  minCanvasHeight: 1,
  maxCanvasHeight: 5000,
};
</file>

<file path="utils/DrawUtils.ts">
import { Vec2 } from '../types/Vector';

export function drawSquarePixel(p: Vec2, size: number, drawFn: (x: number, y: number) => void) {
  const half = Math.floor(size / 2);
  for (let dy = -half; dy <= half; dy++) {
    for (let dx = -half; dx <= half; dx++) {
      drawFn(p.x + dx, p.y + dy);
    }
  }
}

export function drawCompletionLine(p0: Vec2, p1: Vec2, draw: (x: number, y: number) => void) {
  const dx = Math.abs(p1.x - p0.x);
  const dy = Math.abs(p1.y - p0.y);
  const sx = p0.x < p1.x ? 1 : -1;
  const sy = p0.y < p1.y ? 1 : -1;
  let err = dx - dy;

  const steps = Math.max(dx, dy); // 移動回数の上限

  let x = p0.x;
  let y = p0.y;

  for (let i = 0; i <= steps; i++) {
    draw(x, y);
    if (x === p1.x && y === p1.y) {
      break; // 念のため（ただたどり着く設計にはなってる）
    }
    const e2 = 2 * err;
    if (e2 > -dy) {
      err -= dy;
      x += sx;
    }
    if (e2 < dx) {
      err += dx;
      y += sy;
    }
  }
}
</file>

<file path="utils/ImageUtils.ts">
export function encodeImageData(imageData: ImageData): string {
  const bytes = new Uint8Array(imageData.data.buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary); // Base64 encode
}

export function decodeImageData(encoded: string, width: number, height: number): ImageData {
  const binary = atob(encoded);
  const buffer = new Uint8ClampedArray(binary.length);
  for (let i = 0; i < binary.length; i++) {
    buffer[i] = binary.charCodeAt(i);
  }
  return new ImageData(buffer, width, height);
}
</file>

<file path="utils/PathUtils.ts">
import { FileLocation } from '~/types/FileLocation';

export const getFileNameAndPath = (fullPath: string): FileLocation | undefined => {
  const filePath = fullPath.substring(0, fullPath.lastIndexOf('\\'));
  const fileName = fullPath.split('\\').pop()?.split('/').pop();

  if (filePath === undefined || fileName === undefined) return undefined;
  else {
    return {
      path: filePath,
      name: fileName,
    };
  }
};
</file>

<file path="utils/TauriUtils.ts">
import { getTauriVersion } from '@tauri-apps/api/app';
import { invoke as tauriInvoke } from '@tauri-apps/api/core';

let _isTauri: boolean | null = null;

export async function isTauri(): Promise<boolean> {
  if (_isTauri !== null) return _isTauri;
  try {
    await getTauriVersion();
    _isTauri = true;
  } catch {
    _isTauri = false;
  }
  return _isTauri;
}

export async function safeInvoke<T>(cmd: string, args?: Record<string, unknown>): Promise<T | undefined> {
  if (!(await isTauri())) {
    console.warn(`[safeInvoke] '${cmd}' skipped (not in Tauri environment)`);
    return undefined;
  }

  try {
    const result = await tauriInvoke<T>(cmd, args);
    return result;
  } catch (e) {
    console.error(`[safeInvoke] '${cmd}' failed:`, e);
    return undefined;
  }
}
</file>

<file path="utils/windowUtils.ts">
import { WebviewOptions } from '@tauri-apps/api/webview';
import { getAllWebviewWindows, WebviewWindow } from '@tauri-apps/api/webviewWindow';
import { WindowOptions } from '@tauri-apps/api/window';
import { StartWindowOptions } from '~/routes';
import { EditorWindowOptions } from '~/routes/editor';
import { FileLocation } from '~/types/FileLocation';

export type WindowOptionsProp = Omit<WebviewOptions, 'x' | 'y' | 'width' | 'height'> & WindowOptions;

/** 同一ラベルのウィンドウがあれば再利用してフォーカスする */
export async function openSingletonWindow(label: string, options?: WindowOptionsProp) {
  let win = await WebviewWindow.getByLabel(label);
  if (win) {
    win.show();
    win.setFocus();
    return win;
  }
  return new WebviewWindow(label, {
    ...options,
    title: label,
  });
}

export async function closeWindowsByLabel(label: string) {
  (await getAllWebviewWindows())
    .filter((w) => w.label === label)
    .forEach(async (w) => {
      await w.close();
      await w.destroy();
    });
}

export async function openEditorWindow(fileLocation?: FileLocation) {
  if (fileLocation === undefined) {
    const editorWin = new WebviewWindow('editor', {
      ...EditorWindowOptions,
      url: `/editor`,
      title: 'sledge',
    });
  } else {
    const params = new URLSearchParams();
    params.append('name', fileLocation.name);
    params.append('path', fileLocation.path);
    console.log(`/editor?${params.toString()}`);
    const editorWin = new WebviewWindow('editor', {
      ...EditorWindowOptions,
      url: `/editor?${params.toString()}`,
      title: 'sledge',
    });
  }
}

export async function openStartWindow() {
  let startWin = await WebviewWindow.getByLabel('start');
  if (startWin) {
    startWin.show();
    startWin.setFocus();
    return;
  }

  startWin = new WebviewWindow('start', {
    ...StartWindowOptions,
    url: `/`,
  });
}
</file>

</files>
