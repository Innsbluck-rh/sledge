This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------
User Provided Header:
-----------------------
REPOMIX output file

================================================================
Directory Structure
================================================================
.eslintrc.cjs
.gitignore
.prettierignore
.prettierrc
.repomix/bundles.json
.repomixignore
.stylelintrc.json
dist-tcm/styles/canvas/canvas_stack.module.css.d.ts
dist-tcm/styles/canvas/controls.module.css.d.ts
dist-tcm/styles/components/canvas/canvas_stack.module.css.d.ts
dist-tcm/styles/components/canvas/controls.module.css.d.ts
dist-tcm/styles/components/canvas/image_pool.module.css.d.ts
dist-tcm/styles/components/canvas/layer_canvas.module.css.d.ts
dist-tcm/styles/components/companion.module.css.d.ts
dist-tcm/styles/components/dsl_button.module.css.d.ts
dist-tcm/styles/components/edge_info.module.css.d.ts
dist-tcm/styles/components/layer_preview.module.css.d.ts
dist-tcm/styles/components/light.module.css.d.ts
dist-tcm/styles/components/side_sections.module.css.d.ts
dist-tcm/styles/components/slider.module.css.d.ts
dist-tcm/styles/components/toast.module.css.d.ts
dist-tcm/styles/reset.css.d.ts
dist-tcm/styles/section.css.d.ts
dist-tcm/styles/utils.css.d.ts
dist-tcm/styles/ve/canvas/canvas_stack.module.css.d.ts
dist-tcm/styles/ve/canvas/controls.module.css.d.ts
DSL_doc_jp.md
index.html
package.json
patches/@thisbeyond+solid-dnd+0.7.5.patch
public/fonts/k8x12/k8x12.txt
public/fonts/k8x12/readme.txt
public/fonts/terminus/COPYING
README.md
repomix.config.json
src-tauri/.gitignore
src-tauri/build.rs
src-tauri/capabilities/default.json
src-tauri/Cargo.toml
src-tauri/src/lib.rs
src-tauri/src/main.rs
src-tauri/tauri.conf.json
src/app.tsx
src/components/canvas/CanvasArea.tsx
src/components/canvas/CanvasControls.tsx
src/components/canvas/CanvasDebugOverlay.tsx
src/components/canvas/stacks/CanvasOverlaySVG.tsx
src/components/canvas/stacks/CanvasStack.tsx
src/components/canvas/stacks/InteractCanvas.tsx
src/components/canvas/stacks/LayerCanvas.tsx
src/components/common/basics/Checkbox.tsx
src/components/common/basics/Dropdown.tsx
src/components/common/basics/RadioButton.tsx
src/components/common/basics/Slider.tsx
src/components/common/basics/ToggleSwitch.tsx
src/components/common/ColorBox.tsx
src/components/common/companion/Companion.tsx
src/components/common/companion/QuotePool.ts
src/components/common/LayerPreview.tsx
src/components/common/Light.tsx
src/components/common/PixelLineChart.tsx
src/components/global/BottomInfo.tsx
src/components/global/EdgeInfo.tsx
src/components/global/SideSections.tsx
src/components/global/TitleBar.tsx
src/components/section/CanvasSettings.tsx
src/components/section/Color.tsx
src/components/section/item/ColorPicker.tsx
src/components/section/item/LayerItem.tsx
src/components/section/item/Palette.tsx
src/components/section/item/ToolItem.tsx
src/components/section/LayerList.tsx
src/components/section/Project.tsx
src/components/section/settings/EditorSettings.tsx
src/components/section/settings/KeyConfigSettings.tsx
src/components/section/settings/PerformanceSettings.tsx
src/components/section/ToolConfig.tsx
src/controllers/canvas/CanvasAreaInteract.tsx
src/controllers/canvas/CanvasController.ts
src/controllers/canvas/LayerCanvasOperator.ts
src/controllers/color/ColorController.ts
src/controllers/config/GlobalConfigController.ts
src/controllers/config/KeyConfigController.ts
src/controllers/layer_list/LayerListController.ts
src/controllers/layer/LayerController.ts
src/controllers/layer/LayerFactory.ts
src/controllers/log/LogController.tsx
src/controllers/tool/ToolController.ts
src/io/global_config/globalSettings.ts
src/io/image/save.ts
src/io/project/project.ts
src/main.tsx
src/models/dsl/DSL.ts
src/models/dsl/DSLRunner.ts
src/models/dsl/nodes/AvailableNodes.ts
src/models/dsl/nodes/DSLNodes.ts
src/models/dsl/nodes/effect/Brightness.ts
src/models/dsl/nodes/effect/EffectNode.ts
src/models/dsl/nodes/effect/GrayScale.ts
src/models/dsl/nodes/effect/Invert.ts
src/models/dsl/nodes/effect/Sepia.ts
src/models/dsl/nodes/fracture/FractureNode.ts
src/models/dsl/nodes/fracture/JpegGlitch.ts
src/models/dsl/nodes/pass/LayerIn.ts
src/models/dsl/nodes/pass/LayerOut.ts
src/models/dsl/nodes/pass/PassNode.ts
src/models/layer_image/agents/RawLayerImageAgent.ts
src/models/layer_image/agents/TileLayerImageAgent.ts
src/models/layer_image/HistoryManager.ts
src/models/layer_image/LayerImageAgent.ts
src/models/layer_image/LayerImageManager.ts
src/models/tool/eraser/EraserTool.ts
src/models/tool/fill/FillTool.ts
src/models/tool/fill/PixelFloodFill.ts
src/models/tool/fill/TileFloodFill.ts
src/models/tool/pen/PenTool.ts
src/models/tool/ToolBase.ts
src/models/tool/ToolFactory.ts
src/routes/[...404].tsx
src/routes/about/about.css.ts
src/routes/about/index.tsx
src/routes/editor/index.tsx
src/routes/index.tsx
src/routes/settings/index.tsx
src/routes/settings/settings.css.ts
src/routes/start.css.ts
src/stores/EditorStores.ts
src/stores/GlobalStores.ts
src/stores/ProjectStores.ts
src/styles/components/basics/checkbox.css.ts
src/styles/components/basics/dropdown.css.ts
src/styles/components/basics/radio_button.css.ts
src/styles/components/basics/slider.css.ts
src/styles/components/basics/toggle_switch.css.ts
src/styles/components/canvas/canvas_area.css.ts
src/styles/components/canvas/canvas_controls.css.ts
src/styles/components/canvas/canvas_debug_overlay.css.ts
src/styles/components/canvas/canvas_stack.css.ts
src/styles/components/canvas/layer_canvas.css.ts
src/styles/components/globals/bottom_info.css.ts
src/styles/components/globals/companion.module.css
src/styles/components/globals/edge_info.css.ts
src/styles/components/globals/section_global.css.ts
src/styles/components/globals/side_sections.css.ts
src/styles/components/globals/title_bar.css.ts
src/styles/components/layer_preview.css.ts
src/styles/components/light.css.ts
src/styles/components/palette.css.ts
src/styles/components/settings/key_config_settings.css.ts
src/styles/global.css.ts
src/styles/reset.css.ts
src/styles/section/canvas.css.ts
src/styles/section/color.css.ts
src/styles/section/layer.css.ts
src/styles/section/pen.css.ts
src/styles/section/project.css.ts
src/styles/snippets.css.ts
src/types/Canvas.ts
src/types/DrawState.ts
src/types/FileLocation.ts
src/types/KeyConfig.ts
src/types/Layer.ts
src/types/LayerHistory.ts
src/types/PaletteType.ts
src/types/Size.ts
src/types/Tile.ts
src/types/Tool.ts
src/types/Vector.ts
src/utils/ColorUtils.ts
src/utils/consts.ts
src/utils/DrawUtils.ts
src/utils/ImageUtils.ts
src/utils/PathUtils.ts
src/utils/TauriUtils.ts
src/utils/windowUtils.ts
todo_dsl.md
todo.md
tsconfig.json
vite.config.js

================================================================
Files
================================================================

================
File: src/io/image/save.ts
================
import { layerListStore } from '~/stores/ProjectStores';

export function exportActiveLayerUpscaled(fileName?: string, path?: string, scale = 10) {
  const layerId = layerListStore.activeLayerId;
  if (!layerId) return;

  const originalCanvas = document.getElementById(`canvas-${layerId}`) as HTMLCanvasElement;
  if (!originalCanvas) {
    alert('対象のレイヤーが見つかりません。');
    return;
  }

  const w = originalCanvas.width;
  const h = originalCanvas.height;

  // オフスクリーンキャンバスを作る
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = w * scale;
  exportCanvas.height = h * scale;

  const ctx = exportCanvas.getContext('2d');
  if (!ctx) {
    alert('Canvasコンテキスト取得に失敗しました。');
    return;
  }

  // ピクセル補間を無効化
  ctx.imageSmoothingEnabled = false;

  // 元のキャンバスをscale倍に引き伸ばして描画（補完なし）
  ctx.drawImage(originalCanvas, 0, 0, exportCanvas.width, exportCanvas.height);

  // エクスポート処理
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      alert('エクスポートに失敗しました。');
      return;
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${fileName || layerId}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, 'image/png');
}

export function downloadImageData(imageData: ImageData, filename: string = 'image', scale: number = 10) {
  // 一時的な canvas を作成
  const canvas = document.createElement('canvas');
  canvas.width = imageData.width;
  canvas.height = imageData.height;

  // ImageData を描画
  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('2D context not available');
    return;
  }
  ctx.putImageData(imageData, 0, 0);

  const w = canvas.width;
  const h = canvas.height;

  // オフスクリーンキャンバスを作る
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = w * scale;
  exportCanvas.height = h * scale;

  const ctxEx = exportCanvas.getContext('2d');
  if (!ctxEx) {
    return;
  }

  // ピクセル補間を無効化
  ctxEx.imageSmoothingEnabled = false;
  // 元のキャンバスをscale倍に引き伸ばして描画（補完なし）
  ctxEx.drawImage(canvas, 0, 0, exportCanvas.width, exportCanvas.height);

  // エクスポート処理
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      alert('export failed.');
      return;
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, 'image/png');
}

================
File: src/utils/ColorUtils.ts
================
export type RGBColor = [number, number, number];
export type RGBAColor = [number, number, number, number];

// "#rrggbb" -> r/g/b
export function hexToRGB(hex: string): RGBColor {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

// "#rrggbbaa" -> r/g/b/a
export function hexToRGBA(hex: string): RGBAColor {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  let a = parseInt(hex.slice(7, 9), 16);
  if (!a) a = 255; // ここがなかったので a=NaN となり、塗る際にエラー？
  return [r, g, b, a];
}

export function colorMatch(a: RGBAColor, b: RGBAColor): boolean {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

================
File: src/utils/PathUtils.ts
================
import { FileLocation } from '~/types/FileLocation';

export const getFileNameAndPath = (fullPath: string): FileLocation | undefined => {
  const filePath = fullPath.substring(0, fullPath.lastIndexOf('\\'));
  const fileName = fullPath.split('\\').pop()?.split('/').pop();

  if (filePath === undefined || fileName === undefined) return undefined;
  else {
    return {
      path: filePath,
      name: fileName,
    };
  }
};

================
File: src/utils/TauriUtils.ts
================
import { getTauriVersion } from '@tauri-apps/api/app';
import { invoke as tauriInvoke } from '@tauri-apps/api/core';

let _isTauri: boolean | null = null;

export async function isTauri(): Promise<boolean> {
  if (_isTauri !== null) return _isTauri;
  try {
    await getTauriVersion();
    _isTauri = true;
  } catch {
    _isTauri = false;
  }
  return _isTauri;
}

export async function safeInvoke<T>(cmd: string, args?: Record<string, unknown>): Promise<T | undefined> {
  if (!(await isTauri())) {
    console.warn(`[safeInvoke] '${cmd}' skipped (not in Tauri environment)`);
    return undefined;
  }

  try {
    const result = await tauriInvoke<T>(cmd, args);
    return result;
  } catch (e) {
    console.error(`[safeInvoke] '${cmd}' failed:`, e);
    return undefined;
  }
}

================
File: .prettierignore
================
node_modules
public

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: .repomixignore
================
node_modules
public/libs

================
File: dist-tcm/styles/canvas/canvas_stack.module.css.d.ts
================
declare const styles: {
  readonly "canvas_stack": string;
  readonly "image-container": string;
  readonly "resize-image": string;
};
export = styles;

================
File: dist-tcm/styles/canvas/controls.module.css.d.ts
================
declare const styles: {
  readonly "bottom-history": string;
  readonly "cursor": string;
  readonly "history-row": string;
  readonly "history-text": string;
  readonly "top-right-button-container": string;
  readonly "top-right-nav": string;
  readonly "undo_redo": string;
};
export = styles;

================
File: dist-tcm/styles/components/canvas/image_pool.module.css.d.ts
================
declare const styles: {
  readonly "image-container": string;
  readonly "resize-drag-container": string;
};
export = styles;

================
File: dist-tcm/styles/components/canvas/layer_canvas.module.css.d.ts
================
declare const styles: {
  readonly "dev-hint": string;
  readonly "hidden": string;
  readonly "layer-canvas": string;
};
export = styles;

================
File: dist-tcm/styles/components/dsl_button.module.css.d.ts
================
declare const styles: {
  readonly "root": string;
};
export = styles;

================
File: dist-tcm/styles/components/edge_info.module.css.d.ts
================
declare const styles: {
  readonly "root": string;
  readonly "text": string;
};
export = styles;

================
File: dist-tcm/styles/components/layer_preview.module.css.d.ts
================
declare const styles: {
  readonly "canvas": string;
  readonly "wrapper": string;
};
export = styles;

================
File: dist-tcm/styles/components/light.module.css.d.ts
================
declare const styles: {
  readonly "light-inner": string;
  readonly "on": string;
};
export = styles;

================
File: dist-tcm/styles/components/side_sections.module.css.d.ts
================
declare const styles: {
  readonly "content": string;
};
export = styles;

================
File: dist-tcm/styles/components/slider.module.css.d.ts
================
declare const styles: {
  readonly "handle": string;
  readonly "handle-hitbox": string;
  readonly "line": string;
  readonly "line-hitbox": string;
  readonly "root": string;
  readonly "slider": string;
};
export = styles;

================
File: dist-tcm/styles/components/toast.module.css.d.ts
================
declare const styles: {
  readonly "close_persistent_button": string;
  readonly "error": string;
  readonly "fade-in-out-bottom": string;
  readonly "fade-in-out-top": string;
  readonly "info": string;
  readonly "success": string;
  readonly "toast": string;
  readonly "toastContainer": string;
  readonly "toast_root": string;
  readonly "warn": string;
};
export = styles;

================
File: dist-tcm/styles/section.css.d.ts
================
declare const styles: {
  readonly "section_caption": string;
  readonly "section_content": string;
  readonly "section_root": string;
};
export = styles;

================
File: dist-tcm/styles/utils.css.d.ts
================
declare const styles: {
  readonly "fl-col": string;
  readonly "fl-row": string;
};
export = styles;

================
File: dist-tcm/styles/ve/canvas/canvas_stack.module.css.d.ts
================
declare const styles: {
  readonly "canvas_stack": string;
  readonly "image-container": string;
  readonly "resize-image": string;
};
export = styles;

================
File: dist-tcm/styles/ve/canvas/controls.module.css.d.ts
================
declare const styles: {
  readonly "bottom-history": string;
  readonly "cursor": string;
  readonly "history-row": string;
  readonly "history-text": string;
  readonly "top-right-button-container": string;
  readonly "top-right-nav": string;
  readonly "undo_redo": string;
};
export = styles;

================
File: DSL_doc_jp.md
================
# DSL (Data Shaping Lines)

`version:` v.pre-alpha-0.1\
`author:` innsbluck

## 定義

DSL (Data Shaping Lines) とは、2次元の画像データを高速かつフレキシブルに処理するためのsledge独自の言語および記法です。

主に以下のような用途で使用されます。

1. 各レイヤーの色調補正・エフェクト追加。
2. インポートした画像の色調補正・エフェクト追加。
3. 別のレイヤーから参照した情報(side-chain)を用いたエフェクト処理。
4. 各レイヤーを合成し、１枚の画像にまとめる。

1、2，3 のような要素ごとに対するエフェクト処理のほか、4のようなペイントソフトの根幹とも言える**レイヤー合成と出力画像の生成処理**であっても、DSLを用いて記述できます。

> 1、2，3 のような各レイヤーや要素のみに機能するDSLを`Layer-level DSL (LDSL)`と呼びます。\
> 4 のように、レイヤー等を取りまとめて一枚の画像に集約するDSLを`Image-level DSL (IDSL)`と呼びます。

## 記法

> ここでは、DSL＝`Layer-level DSL`であるものとして解説します。

### 概念

DSLは、一言で表すなら **「2次元画像データのストリーム」** です。

```bash
in
> contrast(50%)
> invert()
> brightness(-40%)
> jpeg_glitch(40, 90, 0.001) > out;
```

入力ポート(`in`)から入力された画像データは様々なエフェクトを通過し、
最終的にエフェクトが適用された画像データが出力ポート(`out`)に送信されます。

この`in`と`out`にあたる入力元と送信先は、画像データでさえあれば**なんでも**指定できます。

例えばレイヤーの加工においては、\
入力ポート(`in`)はエフェクト適用前のレイヤーの画像データであり、\
出力ポート(`out`)はプレビューやエクスポートに使用されるレイヤーの「表示先」を意味します。

> DSLの思想や構文は、以下の概念に大きく影響を受けています。
>
> - Linuxのshellにおけるパイプライン
> - DAW(digital audio workstation)におけるFXチェーン、サイドチェイン

### 基本構造

DSLの記法には、関数・クラスの定義やブロック、スコープといった概念は存在しません。

ユーザーは`node`と呼ばれるエフェクトコマンドを選択し、それらをレイヤーの入出力の間に追加していくことで、エフェクトの逐次処理を簡潔かつ直感的に記述できます。

例えば、「レイヤー0の画像のコントラストを50%上げて、色を反転させる」というエフェクトは、以下のような`DSLScript`で記述できます。

```bash
inout layer_0;

in > contrast(50%) > invert() > out;
```

この`DSLScript`は

- 入出力レイヤーの指定(`inout`, `in`, `out`)
- エフェクトの`node`(`contrast(50%)`, `invert()`)
- 各`node`間の区切り文字 `>`
- 各行の区切り文字 `;`

で構成されています。

本章で登場する`DSLScript`は、この4要素を覚えておけば直感的に理解できます。

### 即時性と追従性

上記の例で注目すべき点は、`>`で繋がれたパイプラインが示す通り、この記述は一回適用して終わる使い捨てのエフェクトではない、という点です。

> **`DSLScript`はレイヤー内容の更新に即座に追従して描画状態を更新します。** \
> また、`DSLScript`における`node`の追加/編集/削除も、エフェクトの変更として即座に描画に反映されます。

`inout`は、エフェクトの入力元レイヤーおよび出力先レイヤーを示します。

`inout`は`in`と`out`宣言をまとめたものであり、主に色調補正などの**あるレイヤーの情報が、同レイヤーの出力を決定する**ような効果を記述する場合は、`inout`が使えます。

### レイヤー間のやりとり

入力元と出力先のレイヤーが異なる場合、`inout`の代わりに`in`と`out`宣言を分けて使用できます。以下は、**元絵に追従するグロー効果**のサンプルです。

```bash
in layer_main;　# 元絵レイヤー
out layer_blur; # ぼかし用レイヤー(元絵の下)

blank() > out; #グロー効果用のレイヤーを初期化
in > blur(3px) > out; #元絵を3pxぼかした画像をlayer_blurに出力
```

この`DSLScript`により、ユーザーが`layer_main`に描いた絵は即座に処理され、
ぼかしを入れた元絵がlayer_blurに入ります。

このように、sledgeの`DSL`では**あるレイヤーから得た情報を別のレイヤーに出力することもできます。**

グロー効果の他にも、

- 自由なレイヤーでのクリッピング
- レイヤーから抜き出した主要な色をカラーパレットとして別レイヤーに出力

など、他のペイントソフトでは手動で行うであろう複雑な操作も、`DSLScript`で記述することで保守性を保ちつつも自動化することができます。

> これらの複雑なエフェクトも、**後から変更可能**かつ**関係するレイヤー・画像の変化に自動で追従**して適用されます。

## 各種ノード: node

> 各nodeの詳細については DSL_nodes_doc_jp.md を参照して下さい。

## 一時メモリ: subout

### 概要

`subout`は、一言で表せばDSLにおける「変数」です。
もう少し詳しく言うならば、入出力の結果を一時的に保存する「画像のメモリ」ともいえます。

`subout`は主にデータの分配や分岐に使用されます。
そのほか、範囲分割系の`node`においては`multi(subout_area, subout_outside)`のように**複数の分割された画像の一時保存先**としても使用できます。

### 宣言

`subout`の宣言は`in`, `out`の宣言とパイプライン記述の間で行われます。`init`ステートメントの後にsubout名を記述することで**キャンバスと同サイズの画像データがメモリ上に確保されます**。

```bash
inout layer_0;
init temp_out;

in > temp_out;
temp_out > out;
```

上記の`DSLScript`は実際のところ何の影響も及ぼしません。すなわち、この処理における`in`, `temp_out`, `out`は全て全く同じピクセルデータを持つ画像データを示します。
initialization)のための構文として、実装が検討されています。

## 高度な入出力: in(layer_x), multi(*o1, *o2, ...)

> in(layer_x)もしくはout(layer_x)は`in`, `out`ステートメントで宣言されたレイヤー**以外**のレイヤーの入出力を実現するノードです。**現行のバージョンでは実装の予定はありません**。代わりに、複数の空レイヤー及びDSLを用いて擬似的に表現することを検討して下さい。

### multi(*o1, *o2, ...)

`multi`ノードは出力先として機能するという点で`out`や`subout`に近いですが、
**入力された複数の画像データを複数のsuboutに出力する**役割を持ちます。

`multi`ノードを使用するケースとして最も一般的なのは、`splitV`といった**分割系**のnodeが出力する、範囲/範囲外の2つの出力をそれぞれキャッチし、別々にエフェクト処理を行うケースです。

```bash
inout layer_1;

init merged;

init upper;
init lower;

# 画像の上半分がupper、下半分がlowerにそれぞれ格納される
in(layer_1) > splitV(50%) > multiout(upper, lower);

upper > jpeg_glitch(9, 72) > merged;
lower > invert() > merged;

merged > out(layer_1);
```

## アサーションとディレクティブ

### アサーション

> 現行バージョンでは実装されません。

アサーションは、主にモジュール化を目的とする`DSLScript`コードの保守、テストのために用いられます。例えば、subout等がinitステートメントによって正常に初期化されているかをテストし、実行用とは異なるテスト用のインタプリタ(DSL Test Runner)でこれを実行することで、`DSLScript`が望んだ動作を行うことを検証できます。

```bash
@exist subout1;
```

### ディレクティブ

ディレクティブが提供する機能は、保守・テスト用のアサーションに比べて実際の実行に寄った役割があります。具体的には、

- 全体、行、ノードごとでのログ出力（sledge内のデバッグコンソールで閲覧可能）
- 既に内容があるsuboutにさらに出力を送信した際の挙動(`combine mode`)の定義

などがあります。以下は、ディレクティブを使ったログ出力と挙動設定の例です。

```bash
inout layer_1;

[combine=stack-up] # 既存のピクセルの上に上書き
# [combine=stack-down] # 既存のピクセルの下に上書き
init merged;

init upper;
init lower;

[log_trace_line] # 下の1行の中間ログを出力
in(layer_1) > splitV(50%) > multiout(upper, lower);
upper > jpeg_glitch(9, 72) > merged;
lower > invert() > merged;
merged > out(layer_1);
```

上記の例における`log_trace_line`が出力するログには各ノードの出力結果が**画像として**含まれますが、sledgeの内部デバッグコンソールは文字情報と同時にこれらの画像を出力できるよう最適化されています。

## 検討されている機能

### unused subout omitter

`DSLScript`には`subout`が本来不要か、もしくは短縮できるケースが存在します。

```bash
inout layer_0;
init temp_out;

in > temp_out;
temp_out > out;
```

そこで、省略可能な部分を自動で検知し、`in > out`のような形へ最適化する機能(unused subout omitter)が検討されています。

### instant subout initialization

`*subout`は`init`ステートメントを使わない即時宣言(instant subout initialization)の方法として検討されています。

```bash
in > splitV(30%) > multi(*upper ,*lower);
```

================
File: patches/@thisbeyond+solid-dnd+0.7.5.patch
================
diff --git a/node_modules/@thisbeyond/solid-dnd/dist/dev.js b/node_modules/@thisbeyond/solid-dnd/dist/dev.js
index c4cce69..0578068 100644
--- a/node_modules/@thisbeyond/solid-dnd/dist/dev.js
+++ b/node_modules/@thisbeyond/solid-dnd/dist/dev.js
@@ -1084,7 +1084,8 @@ var combineRefs = (setRefA, setRefB) => {
 // src/create-sortable.ts
 var createSortable = (id, data = {}) => {
   const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();
-  const [sortableState] = useSortableContext();
+  const context = useSortableContext();
+const sortableState = context?.[0];;
   const draggable = createDraggable(id, data);
   const droppable = createDroppable(id, data);
   const setNode = combineRefs(draggable.ref, droppable.ref);
diff --git a/node_modules/@thisbeyond/solid-dnd/dist/dev.jsx b/node_modules/@thisbeyond/solid-dnd/dist/dev.jsx
index b06d7fc..81d48fb 100644
--- a/node_modules/@thisbeyond/solid-dnd/dist/dev.jsx
+++ b/node_modules/@thisbeyond/solid-dnd/dist/dev.jsx
@@ -1083,7 +1083,8 @@ var combineRefs = (setRefA, setRefB) => {
 // src/create-sortable.ts
 var createSortable = (id, data = {}) => {
   const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();
-  const [sortableState] = useSortableContext();
+  const context = useSortableContext();
+const sortableState = context?.[0];;
   const draggable = createDraggable(id, data);
   const droppable = createDroppable(id, data);
   const setNode = combineRefs(draggable.ref, droppable.ref);
diff --git a/node_modules/@thisbeyond/solid-dnd/dist/index.js b/node_modules/@thisbeyond/solid-dnd/dist/index.js
index ccc5acb..3938d5c 100644
--- a/node_modules/@thisbeyond/solid-dnd/dist/index.js
+++ b/node_modules/@thisbeyond/solid-dnd/dist/index.js
@@ -1077,7 +1077,8 @@ var combineRefs = (setRefA, setRefB) => {
 // src/create-sortable.ts
 var createSortable = (id, data = {}) => {
   const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();
-  const [sortableState] = useSortableContext();
+  const context = useSortableContext();
+const sortableState = context?.[0];;
   const draggable = createDraggable(id, data);
   const droppable = createDroppable(id, data);
   const setNode = combineRefs(draggable.ref, droppable.ref);
diff --git a/node_modules/@thisbeyond/solid-dnd/dist/index.jsx b/node_modules/@thisbeyond/solid-dnd/dist/index.jsx
index 54348fe..ec85440 100644
--- a/node_modules/@thisbeyond/solid-dnd/dist/index.jsx
+++ b/node_modules/@thisbeyond/solid-dnd/dist/index.jsx
@@ -1070,7 +1070,8 @@ var combineRefs = (setRefA, setRefB) => {
 // src/create-sortable.ts
 var createSortable = (id, data = {}) => {
   const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();
-  const [sortableState] = useSortableContext();
+  const context = useSortableContext();
+const sortableState = context?.[0];;
   const draggable = createDraggable(id, data);
   const droppable = createDroppable(id, data);
   const setNode = combineRefs(draggable.ref, droppable.ref);

================
File: public/fonts/k8x12/k8x12.txt
================
===============================================================================

                8×12 ドット日本語ビットマップフォント「k8x12」
                                (2021-05-05 版)

                       Copyright (C) 2015-2021 Num Kadoma

===============================================================================

-------------------------------------------------------------------------------
 概要
-------------------------------------------------------------------------------
　k8x12 は 8×12 ドットの日本語ビットマップフォントです。
　JIS 第一・第二水準をサポートしており、その他の記号も一部含んでいます。


-------------------------------------------------------------------------------
 バリエーション
-------------------------------------------------------------------------------
　オリジナルの k8x12 の他に、
　バリエーションとして k8x12L, k8x12S が存在します。
　漢字の字形はこれらすべてで共通です (仝々〆〇 を含む)。

・k8x12L
　k8x12L は k8x12 の仮名を縦に長い形に変更したものです。
　漢字同様に下端に空白を 1 ラインとった残りの縦 11 ドットを使っています。

・k8x12S
　k8x12S は k8x12 の非漢字を縦 8 ドットの字形に変更したものです。
　濁点、半濁点は仮名の上に乗る形になっています。
　このバリエーションは、8×8 ドット単位でグラフィックを扱うような、
　昔のゲーム機やマイコンにおける制限を意識しています。
　
　文字の枠を 8×12 ではなく 8×16 ドットに広げた方がより「らしく」なりますが、
　フォントとしての使い勝手を考えてそのままにしています。


-------------------------------------------------------------------------------
 備考
-------------------------------------------------------------------------------
・縦書きには未対応です。


-------------------------------------------------------------------------------
 ライセンス
-------------------------------------------------------------------------------
　These fonts are free software.
　Unlimited permission is granted to use, copy, and distribute them, with or without modification, either commercially or noncommercially.
　THESE FONTS ARE PROVIDED "AS IS" WITHOUT WARRANTY.

　これらのフォントはフリー（自由な）ソフトウエアです。
　あらゆる改変の有無に関わらず、また商業的な利用であっても、自由にご利用、複製、再配布することができますが、全て無保証とさせていただきます。


-------------------------------------------------------------------------------
 制作履歴
-------------------------------------------------------------------------------
■2021-05-05
・文字の追加: ␣
・字形の修正・変更:
　*售堕寉寓崔帯廼滞焦瞿矍臭蕉隹隻隼雀集雋霍
　(k8x12S のみ)│┃┌┏┐┓└┗┘┛├┝┠┣┤┥┨┫┬┯┰┳┴┷┸┻┼┿╂╋╞╡╪╭╮╯╰ホ
・[TTF] ビットマップを埋込み
・[BDF] アーカイブ形式を zip に変更

■2017-02-20
・「8」を首の細長い形状に変更 (「0」との誤認対策)

■2016-08-27
・「莱」の字形が「菜」になっている問題を修正

■2015-01-29
・[TTF] Windows 環境で文字幅が広がってしまう問題を修正

■2015-01-28
・初版公開

■2014-12-09
・JIS 第二水準漢字が揃う

■2014-08-初～11-初
・(休憩)

■2014-08-08
・JIS 第一水準漢字が揃う

■2014-07-06
・制作開始


-------------------------------------------------------------------------------
 バージョン情報
-------------------------------------------------------------------------------
■2021-05-05
・k8x12 2017-05-05 版 (BDF/TTF/PNG)

■2017-02-20
・k8x12 2017-07-20 版 (BDF/TTF/PNG)

■2016-08-27
・k8x12 2016-08-27 版 (BDF/TTF/PNG)

■2015-01-29
・k8x12 2015-01-29 版 (TTF)

■2015-01-28
・k8x12 2015-01-28 版 (BDF/TTF/PNG)


-------------------------------------------------------------------------------
 連絡先
-------------------------------------------------------------------------------
　門真 なむ (Num Kadoma)
　・Twitter: @num_kadoma
　・Website: http://littlelimit.net/

================
File: public/fonts/k8x12/readme.txt
================
===============================================================================

                                  k8x12 TTF 版

===============================================================================

-------------------------------------------------------------------------------
 概要
-------------------------------------------------------------------------------
　k8x12 TTF 版は TrueType 形式の等幅フォントです。
　k8x12 のアウトラインと埋込みビットマップを含んでいます。


-------------------------------------------------------------------------------
 アーカイブの内容
-------------------------------------------------------------------------------
・k8x12.txt
　k8x12 のマニュアル

・readme.txt
　k8x12 TTF 版のマニュアル (このファイル)

・k8x12.ttf
　k8x12 TTF 版 (Regular)

・k8x12L.ttf
　k8x12L TTF 版 (Regular)

・k8x12S.ttf
　k8x12S TTF 版 (Regular)


-------------------------------------------------------------------------------
 ライセンス
-------------------------------------------------------------------------------
　アーカイブ同梱の「k8x12.txt」の内容に従うものとします。

================
File: public/fonts/terminus/COPYING
================
Copyright (c) 2010 Dimitar Toshkov Zhekov,
with Reserved Font Name "Terminus Font".

Copyright (c) 2011-2023 Tilman Blumenbach,
with Reserved Font Name "Terminus (TTF)".

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL

---

## SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded,
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1. Neither the Font Software nor any of its individual components,
   in Original or Modified Versions, may be sold by itself.

2. Original or Modified Versions of the Font Software may be bundled,
   redistributed and/or sold with any software, provided that each copy
   contains the above copyright notice and this license. These can be
   included either as stand-alone text files, human-readable headers or
   in the appropriate machine-readable metadata fields within text or
   binary files as long as those fields can be easily viewed by the user.

3. No Modified Version of the Font Software may use the Reserved Font
   Name(s) unless explicit written permission is granted by the corresponding
   Copyright Holder. This restriction only applies to the primary font name as
   presented to the users.

4. The name(s) of the Copyright Holder(s) or the Author(s) of the Font
   Software shall not be used to promote, endorse or advertise any
   Modified Version, except to acknowledge the contribution(s) of the
   Copyright Holder(s) and the Author(s) or with their explicit written
   permission.

5. The Font Software, modified or unmodified, in part or in whole,
   must be distributed entirely under this license, and must not be
   distributed under any other license. The requirement for fonts to
   remain under this license does not apply to any document created
   using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

================
File: repomix.config.json
================
{
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "compress": false,
    "headerText": "REPOMIX output file",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "showLineNumbers": false
  },
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true
  }
}

================
File: src-tauri/.gitignore
================
# Generated by Cargo
# will have compiled files and executables
/target/
/gen/schemas

================
File: src-tauri/build.rs
================
fn main() {
  tauri_build::build()
}

================
File: src-tauri/src/main.rs
================
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    app_lib::run();
}

================
File: src/components/canvas/CanvasControls.tsx
================
import * as styles from '@styles/components/canvas/canvas_controls.css';
import { Component } from 'solid-js';
import { canRedo, canUndo } from '~/controllers/layer/LayerController';
import { layerImageManager } from '~/routes/editor';
import { layerListStore } from '~/stores/ProjectStores';

const CanvasControls: Component = () => {
  return (
    <div class={styles.topRightNav}>
      <img
        class={styles.undoRedo}
        src='/undo.png'
        style={{
          opacity: canUndo() ? '1.0' : '0.3',
          cursor: canUndo() ? 'pointer' : 'unset',
        }}
        onClick={(e) => {
          e.preventDefault();
          e.stopPropagation();
          layerImageManager.getAgent(layerListStore.activeLayerId)?.undo();
        }}
      />
      <img
        class={styles.undoRedo}
        src='/redo.png'
        style={{
          opacity: canRedo() ? '1.0' : '0.3',
          cursor: canRedo() ? 'pointer' : 'unset',
        }}
        onClick={(e) => {
          e.preventDefault();
          e.stopPropagation();
          layerImageManager.getAgent(layerListStore.activeLayerId)?.redo();
        }}
      />
    </div>
  );
};

export default CanvasControls;

================
File: src/components/canvas/stacks/InteractCanvas.tsx
================
import { Component, createEffect, createSignal, onCleanup, onMount } from 'solid-js';
import LayerCanvasOperator from '~/controllers/canvas/LayerCanvasOperator';
import { interactStore, setInteractStore } from '~/stores/EditorStores';
import { canvasStore } from '~/stores/ProjectStores';
import { DrawState } from '~/types/DrawState';
import { Vec2 } from '~/types/Vector';

interface Props {
  operator: LayerCanvasOperator;
}

// レイヤーごとのキャンバスの上でタッチイベントを受けるだけのキャンバス
export const InteractCanvas: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;

  const styleWidth = () => canvasStore.canvas.width;
  const styleHeight = () => canvasStore.canvas.height;

  const [lastPos, setLastPos] = createSignal<Vec2 | undefined>(undefined);
  const [temporaryOut, setTemporaryOut] = createSignal(false);

  function getOffset() {
    const rect = canvasRef!.getBoundingClientRect();
    return { x: rect.left, y: rect.top };
  }

  function getWindowMousePosition(e: MouseEvent | PointerEvent | TouchEvent) {
    let x = 0;
    let y = 0;

    if ('clientX' in e && 'clientY' in e) {
      x = e.clientX;
      y = e.clientY;
    } else if ('touches' in e && e.touches.length > 0) {
      console.log('touch');
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }
    return { x, y };
  }

  function getCanvasMousePosition(e: MouseEvent | PointerEvent | TouchEvent) {
    const offset = getOffset();

    let x = 0;
    let y = 0;

    if ('clientX' in e && 'clientY' in e) {
      x = e.clientX;
      y = e.clientY;
    } else if ('touches' in e && e.touches.length > 0) {
      console.log('touch');
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }

    const zoom = interactStore.zoom;

    return {
      x: (x - offset.x) / zoom,
      y: (y - offset.y) / zoom,
    };
  }

  function isDrawableClick(e: PointerEvent): boolean {
    if (e.pointerType === 'touch' || interactStore.isCtrlPressed) return false;
    // right=1, left=2, middle=4
    // console.log(e.buttons)
    if (e.pointerType === 'mouse' && e.buttons !== 1) return false;

    return true;
  }

  function handlePointerDown(e: PointerEvent) {
    if (!isDrawableClick(e)) return;

    const position = getCanvasMousePosition(e);
    props.operator.handleDraw(DrawState.start, position, lastPos());
    setInteractStore('isInStroke', true);
    setLastPos(position);
  }

  function handlePointerCancel(e: PointerEvent) {
    endStroke(getCanvasMousePosition(e));
  }

  function handlePointerMove(e: PointerEvent) {
    const windowPosition = getWindowMousePosition(e);
    const position = getCanvasMousePosition(e);
    setInteractStore('lastMouseWindow', windowPosition);
    setInteractStore('lastMouseOnCanvas', position);

    if (!isDrawableClick(e)) return;

    // 押したまま外に出てから戻ってきたときはそこから再開
    if (temporaryOut()) {
      setTemporaryOut(false);
      setInteractStore('isInStroke', true);
      setLastPos(position);
    }
    if (!interactStore.isInStroke || !lastPos()) return;

    props.operator.handleDraw(DrawState.move, position, lastPos());
    setLastPos(position);
  }

  function handlePointerUp(e: PointerEvent) {
    const position = getCanvasMousePosition(e);
    if (interactStore.isInStroke) endStroke(position);
  }

  function handlePointerOut(e: PointerEvent) {
    // 出た時点でストロークを切る場合
    // const position = getCanvasMousePosition(e);
    // if (interactStore.isInStroke) endStroke(position);

    // 出た時点でも押したままキャンバス内に戻ってきたらストロークを再開する場合
    if (interactStore.isDragging) {
      const position = getCanvasMousePosition(e);
      props.operator.handleDraw(DrawState.move, position, lastPos());
      setTemporaryOut(true);
    }
  }

  function handleWheel(e: WheelEvent) {
    const windowPosition = getWindowMousePosition(e);
    const position = getCanvasMousePosition(e);
    setInteractStore('lastMouseWindow', windowPosition);
    setInteractStore('lastMouseOnCanvas', position);
  }

  function endStroke(position: Vec2) {
    props.operator.handleDraw(DrawState.end, position, lastPos());
    setInteractStore('isInStroke', false);
    setLastPos(undefined);
    setTemporaryOut(false);
  }

  onMount(() => {
    window.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointercancel', handlePointerCancel);
    window.addEventListener('wheel', handleWheel);
  });

  onCleanup(() => {
    window.removeEventListener('pointerup', handlePointerUp);
    window.removeEventListener('pointermove', handlePointerMove);
    window.removeEventListener('pointercancel', handlePointerCancel);
    window.removeEventListener('wheel', handleWheel);
  });

  createEffect(() => {
    if (canvasRef)
      setInteractStore('canvasElementSize', {
        width: canvasRef.clientWidth,
        height: canvasRef.clientHeight,
      });
  });

  return (
    <canvas
      ref={(el) => {
        canvasRef = el;
      }}
      width={canvasStore.canvas.width}
      height={canvasStore.canvas.height}
      onPointerDown={handlePointerDown}
      onPointerOut={handlePointerOut}
      style={{
        'touch-action': 'none',
        width: `${styleWidth()}px`,
        height: `${styleHeight()}px`,
        'pointer-events': 'all',
        'z-index': '100', // どのレイヤーよりも上だが、image poolよりも下
      }}
    />
  );
};

================
File: src/components/common/basics/Checkbox.tsx
================
import { Component } from 'solid-js';
import { checkboxWrapper, customCheckbox, hiddenCheckbox } from '~/styles/components/basics/checkbox.css';

const Checkbox: Component<{
  label?: string;
  checked?: boolean;
  onChange?: (checked: boolean) => void;
  inputRef?: (el: HTMLInputElement) => void;
}> = (props) => {
  return (
    <label class={checkboxWrapper}>
      <input
        class={hiddenCheckbox}
        type='checkbox'
        checked={props.checked}
        onChange={(e) => props.onChange?.(e.currentTarget.checked)}
        ref={props.inputRef}
      />
      <span class={customCheckbox}></span>
      {props.label}
    </label>
  );
};

export default Checkbox;

================
File: src/components/common/basics/Dropdown.tsx
================
import { For, JSX } from 'solid-js';
import { dropdownRoot } from '~/styles/components/basics/dropdown.css';

export type DropdownOption<T extends string | number> = {
  label: string;
  value: T;
};

interface Props<T extends string | number = string> {
  value: T | (() => T);
  selected: T | (() => T);
  /** 選択候補 */
  options: DropdownOption<T>[];
  /** 値変更時に呼び出される */
  onChange?: (value: T) => void;
  /** aria-label など任意で渡す */
  props?: JSX.SelectHTMLAttributes<HTMLSelectElement>;
}

const Dropdown = <T extends string | number>(p: Props<T>) => {
  const getValue = () => (typeof p.value === 'function' ? (p.value as () => T)() : p.value);

  return (
    <select
      {...p.props}
      class={dropdownRoot}
      value={String(getValue())}
      onChange={(e) => p.onChange?.(e.currentTarget.value as unknown as T)}
    >
      <For each={p.options}>
        {(o) => (
          <option selected={p.selected === o.value} value={String(o.value)}>
            {o.label}
          </option>
        )}
      </For>
    </select>
  );
};

export default Dropdown;

================
File: src/components/common/basics/RadioButton.tsx
================
import { Component } from 'solid-js';
import { customRadio, hiddenRadio, radioWrapper } from '~/styles/components/basics/radio_button.css';

const RadioButton: Component<{ label?: string; name: string }> = (props) => {
  return (
    <label class={radioWrapper}>
      {props.label}
      <input class={hiddenRadio} type='radio' name={props.name} />
      <span class={customRadio}></span>
    </label>
  );
};

export default RadioButton;

================
File: src/components/common/basics/Slider.tsx
================
import { Component, createSignal } from 'solid-js';
import * as styles from '~/styles/components/basics/slider.css'; // vanilla-extractはこれ！

interface SliderProps {
  min: number;
  max: number;
  default: number;
  allowFloat?: boolean;
  onValueChanged?: (newValue: number) => void;
}

const Slider: Component<SliderProps> = (props) => {
  let sliderRef: HTMLDivElement | undefined;
  const [isDrag, setDrag] = createSignal(false);
  const [value, setValue] = createSignal(props.default);

  const percent = () => ((value() - props.min) / (props.max - props.min)) * 100;

  const handlePointerDown = (e: PointerEvent) => {
    setDrag(true);
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);
  };

  const handlePointerMove = (e: PointerEvent) => {
    if (!sliderRef || !isDrag()) return;
    const rect = sliderRef.getBoundingClientRect();
    let pos = e.clientX - rect.left;
    pos = Math.max(0, Math.min(pos, rect.width));

    const newValueRaw = props.min + (pos / rect.width) * (props.max - props.min);
    const newValue = props.allowFloat ? newValueRaw : Math.round(newValueRaw);
    setValue(newValue);
    props.onValueChanged?.(newValue);
  };

  const handlePointerUp = (e: PointerEvent) => {
    setDrag(false);
    window.removeEventListener('pointermove', handlePointerMove);
    window.removeEventListener('pointerup', handlePointerUp);
  };

  const onLineClick = (e: MouseEvent) => {
    if (!sliderRef) return;
    const rect = sliderRef.getBoundingClientRect();
    let pos = e.clientX - rect.left;
    pos = Math.max(0, Math.min(pos, rect.width));

    const newValueRaw = props.min + (pos / rect.width) * (props.max - props.min);
    const newValue = props.allowFloat ? newValueRaw : Math.round(newValueRaw);
    setValue(newValue);
    props.onValueChanged?.(newValue);
  };

  return (
    <div class={styles.root}>
      <div class={styles.slider} ref={sliderRef}>
        <div class={styles.lineHitbox} onPointerDown={handlePointerDown} onClick={onLineClick}>
          <div class={styles.line} />
        </div>
        <div style={{ left: `${percent()}%` }} class={styles.handle} />
      </div>
    </div>
  );
};

export default Slider;

================
File: src/components/common/basics/ToggleSwitch.tsx
================
import { Component } from 'solid-js';
import { toggleInput, toggleThumb, toggleTrack, toggleWrapper } from '~/styles/components/basics/toggle_switch.css';

interface Props {
  checked: boolean;
  onChange?: (checked: boolean) => void;
  /** 任意でラベル等を配置する場合の slot */
  children?: any;
}

const ToggleSwitch: Component<Props> = (p) => (
  /* label 全体でクリック可能に */
  <label class={toggleWrapper}>
    {p.children}
    <input
      type='checkbox'
      checked={p.checked}
      onInput={(e) => p.onChange?.(e.currentTarget.checked)}
      class={toggleInput}
    />
    <span class={toggleTrack}>
      <span class={toggleThumb} />
    </span>
  </label>
);

export default ToggleSwitch;

================
File: src/components/section/settings/KeyConfigSettings.tsx
================
import { Component, createSignal, For, onCleanup, onMount } from 'solid-js';
import {
  isRecordEndSave as isRecordEndKey,
  isRecordEndWithoutSave as isRecordAbortKey,
  isRecordPossible as isRecordPossibleKey,
  parseKeyConfigEntry,
  recordKey,
  restoreDefaultKeyConfig,
  saveKeyConfigEntry,
} from '~/controllers/config/KeyConfigController';
import { keyConfigStore } from '~/stores/GlobalStores';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/components/globals/section_global.css';
import { keyConfigName } from '~/styles/components/settings/key_config_settings.css';
import { flexRow } from '~/styles/snippets.css';
import { KeyConfigEntry } from '~/types/KeyConfig';

const KeyConfigSettings: Component = () => {
  const [recordingName, setRecordingName] = createSignal<string | undefined>(undefined);
  const [recordedEntry, setRecordedEntry] = createSignal<KeyConfigEntry | undefined>(undefined);

  const handleOnKeyDown = (e: KeyboardEvent) => {
    if (!recordingName) return;
    e.preventDefault();
    if (isRecordAbortKey(e)) {
      endRecord(false);
      return;
    }
    if (isRecordEndKey(e)) {
      endRecord(true);
      return;
    }
    if (!isRecordPossibleKey(e)) return;

    const entry = recordKey(e);
    setRecordedEntry(entry);
  };

  const startRecord = (name: string) => {
    setRecordedEntry(undefined);
    setRecordingName(name);
  };

  const endRecord = (save: boolean) => {
    const name = recordingName();
    if (!name) return;
    if (save) saveKeyConfigEntry(name, recordedEntry());
    setRecordedEntry(undefined);
    setRecordingName(undefined);
  };

  onMount(() => {
    window.addEventListener('keydown', handleOnKeyDown);
    onCleanup(() => {
      window.removeEventListener('keydown', handleOnKeyDown);
    });
  });

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>key config.</p>
      <div class={sectionContent} style={{ gap: '8px' }}>
        <For each={Object.entries(keyConfigStore)}>
          {([name, entry]) => {
            const isRecording = () => name === recordingName();
            return (
              <div class={flexRow}>
                <p class={keyConfigName}>{name}</p>
                <a
                  onClick={(e) => {
                    if (!isRecording()) startRecord(name);
                  }}
                  style={{
                    color: isRecording() ? 'blue' : 'inherit',
                    'pointer-events': isRecording() ? 'none' : 'all',
                  }}
                >
                  {name === recordingName()
                    ? `rec. [${parseKeyConfigEntry(recordedEntry()) ?? 'enter any key'}]`
                    : parseKeyConfigEntry(entry[0])}
                </a>
              </div>
            );
          }}
        </For>

        <button
          onClick={(e) => {
            e.preventDefault();
            restoreDefaultKeyConfig();
          }}
        >
          restore default.
        </button>
      </div>
    </div>
  );
};

export default KeyConfigSettings;

================
File: src/controllers/canvas/CanvasAreaInteract.tsx
================
import { getReferencedZoom } from '~/controllers/canvas/CanvasController';
import { interactStore, setInteractStore } from '~/stores/EditorStores';
import { Vec2 } from '~/types/Vector';

class CanvasAreaInteract {
  private dragPosition: Vec2 = { x: 0, y: 0 };

  private lastX: number[] = [0, 0];
  private lastY: number[] = [0, 0];
  private lastDist: number = 0;

  private getMutualMove = (move0: number, move1: number) => {
    // 逆方向なら0
    if (Math.sign(move0) !== Math.sign(move1)) return 0;
    return Math.min(move1, move0);
  };

  private handleTouchMove(e: TouchEvent, canvasStack: HTMLDivElement) {
    if (interactStore.isInStroke) return;

    if (e.touches.length === 1) {
      const xMove0 = e.touches[0].clientX - this.lastX[0];
      if (xMove0 !== 0 && this.lastX[0] !== 0) {
        setInteractStore('offset', {
          x: interactStore.offset.x + xMove0,
          y: interactStore.offset.y,
        });
      }
      const yMove0 = e.touches[0].clientY - this.lastY[0];
      if (yMove0 !== 0 && this.lastY[0] !== 0) {
        setInteractStore('offset', {
          x: interactStore.offset.x,
          y: interactStore.offset.y + yMove0,
        });
      }
      this.lastX[0] = e.touches[0].clientX;
      this.lastY[0] = e.touches[0].clientY;
    }
    if (e.touches.length >= 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.sqrt(dx * dx + dy * dy) * interactStore.touchZoomSensitivity;
      if (this.lastDist !== 0) {
        const scaleFactor = dist / this.lastDist;
        const zoomOld = interactStore.zoom;
        const zoomNew = zoomOld * scaleFactor;
        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const rect = canvasStack.getBoundingClientRect();
        const canvasX = (midX - rect.left) / zoomOld;
        const canvasY = (midY - rect.top) / zoomOld;
        setInteractStore('zoom', zoomNew);
        setInteractStore('offset', {
          x: interactStore.offset.x + canvasX * (zoomOld - zoomNew),
          y: interactStore.offset.y + canvasY * (zoomOld - zoomNew),
        });
      }
      const xMove0 = e.touches[0].clientX - this.lastX[0];
      const xMove1 = e.touches[1].clientX - this.lastX[1];
      const mutualMoveX = this.getMutualMove(xMove0, xMove1);
      if (mutualMoveX !== 0 && this.lastX[0] !== 0 && this.lastX[1] !== 0) {
        setInteractStore('offset', {
          x: interactStore.offset.x + mutualMoveX,
          y: interactStore.offset.y,
        });
      }
      const yMove0 = e.touches[0].clientY - this.lastY[0];
      const yMove1 = e.touches[1].clientY - this.lastY[1];
      const mutualMoveY = this.getMutualMove(yMove0, yMove1);
      if (mutualMoveY !== 0 && this.lastY[0] !== 0 && this.lastY[1] !== 0) {
        setInteractStore('offset', {
          x: interactStore.offset.x,
          y: interactStore.offset.y + mutualMoveY,
        });
      }
      this.lastX[0] = e.touches[0].clientX;
      this.lastX[1] = e.touches[1].clientX;
      this.lastY[0] = e.touches[0].clientY;
      this.lastY[1] = e.touches[1].clientY;
      this.lastDist = dist;
    }
  }

  private handleTouchEnd(e: TouchEvent) {
    this.lastX = [0, 0];
    this.lastY = [0, 0];
    this.lastDist = 0;
  }

  private handleWheel(e: WheelEvent, canvasStack: HTMLDivElement) {
    const referencedZoom = getReferencedZoom();
    if (!referencedZoom) return;
    const delta = e.deltaY > 0 ? -interactStore.wheelZoomStep : interactStore.wheelZoomStep;

    const zoomOld = interactStore.zoom;
    const zoomNew = Math.round((interactStore.zoom + interactStore.zoom * delta) * 1000) / 1000;

    if (zoomNew < interactStore.zoomMin * referencedZoom || interactStore.zoomMax * referencedZoom < zoomNew) return;

    const rect = canvasStack.getBoundingClientRect();
    const canvasX = (e.clientX - rect.left) / zoomOld;
    const canvasY = (e.clientY - rect.top) / zoomOld;
    setInteractStore('zoom', zoomNew);
    setInteractStore('offset', {
      x: interactStore.offset.x + canvasX * (zoomOld - zoomNew),
      y: interactStore.offset.y + canvasY * (zoomOld - zoomNew),
    });
  }

  private handleMouseDown(e: MouseEvent) {
    if (e.buttons === 4 || (e.buttons === 1 && interactStore.isCtrlPressed)) {
      e.preventDefault();
      e.stopPropagation();
      setInteractStore('isDragging', true);
      this.dragPosition = { x: e.clientX, y: e.clientY };
    }
  }

  private handleMouseMove(e: MouseEvent) {
    if (e.buttons === 4 || (e.buttons === 1 && interactStore.isCtrlPressed)) {
      e.preventDefault();
      e.stopPropagation();
      if (interactStore.isDragging) {
        const dx = e.clientX - this.dragPosition.x;
        const dy = e.clientY - this.dragPosition.y;
        setInteractStore('offset', {
          x: interactStore.offset.x + dx,
          y: interactStore.offset.y + dy,
        });
        this.dragPosition = { x: e.clientX, y: e.clientY };
      }
    }
  }

  private handleMouseOff(e: MouseEvent) {
    setInteractStore('isDragging', false);
  }

  private handleKeyDown(e: KeyboardEvent) {
    if (e.ctrlKey) setInteractStore('isCtrlPressed', true);
  }

  private handleKeyUp(e: KeyboardEvent) {
    if (e.key === 'Control') setInteractStore('isCtrlPressed', false);
  }

  public setInteractListeners(wrapper: HTMLDivElement, canvasStack: HTMLDivElement) {
    wrapper.addEventListener('touchmove', (e) => this.handleTouchMove.bind(this)(e, canvasStack), { passive: true });
    wrapper.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });

    wrapper.addEventListener('wheel', (e) => this.handleWheel.bind(this)(e, canvasStack), { passive: true });

    wrapper.addEventListener('mousedown', this.handleMouseDown.bind(this));
    wrapper.addEventListener('mousemove', this.handleMouseMove.bind(this));
    wrapper.addEventListener('mouseup', this.handleMouseOff.bind(this));
    wrapper.addEventListener('mouseleave', this.handleMouseOff.bind(this));
    wrapper.addEventListener('mouseout', this.handleMouseOff.bind(this));

    window.addEventListener('keydown', this.handleKeyDown.bind(this));
    window.addEventListener('keyup', this.handleKeyUp.bind(this));
  }

  public removeInteractListeners(wrapper: HTMLDivElement, canvasStack: HTMLDivElement) {
    wrapper.removeEventListener('touchmove', (e) => this.handleTouchMove.bind(this)(e, canvasStack));
    wrapper.removeEventListener('touchend', this.handleTouchEnd.bind(this));

    wrapper.removeEventListener('wheel', (e) => this.handleWheel.bind(this)(e, canvasStack));

    wrapper.removeEventListener('mousedown', this.handleMouseDown.bind(this));
    wrapper.removeEventListener('mousemove', this.handleMouseMove.bind(this));
    wrapper.removeEventListener('mouseup', this.handleMouseOff.bind(this));
    wrapper.removeEventListener('mouseleave', this.handleMouseOff.bind(this));
    wrapper.removeEventListener('mouseout', this.handleMouseOff.bind(this));

    window.removeEventListener('keydown', this.handleKeyDown.bind(this));
    window.removeEventListener('keyup', this.handleKeyUp.bind(this));
  }
}

export default CanvasAreaInteract;

================
File: src/controllers/config/GlobalConfigController.ts
================
import { saveGlobalSettings } from '~/io/global_config/globalSettings';
import { setGlobalStore } from '~/stores/GlobalStores';
import { FileLocation } from '~/types/FileLocation';

export const addRecentFile = (fileLocation?: FileLocation) => {
  if (!fileLocation) return;
  const path = fileLocation.path;
  const name = fileLocation.name;

  // add to recent
  setGlobalStore((store) => {
    console.log('path: ' + path);
    console.log('name: ' + name);
    if (name && path && store.recentFiles) {
      const oldRecentFiles = store.recentFiles.filter((f) => {
        return f.name !== name || f.path !== path?.toString();
      });
      // その後、一番上に追加
      const newRecentFiles: FileLocation[] = [
        {
          name: name,
          path: path,
        },
        ...oldRecentFiles,
      ];
      setGlobalStore('recentFiles', newRecentFiles);
      saveGlobalSettings();
    }
    return store;
  });
};

================
File: src/controllers/config/KeyConfigController.ts
================
import { reconcile } from 'solid-js/store';
import { makeDefaultKeyConfigStore, setKeyConfigStore } from '~/stores/GlobalStores';
import { KeyConfigEntry } from '~/types/KeyConfig';

export const recordKey = (e: KeyboardEvent): KeyConfigEntry => {
  return {
    key: e.key,
    ctrl: e.ctrlKey || undefined,
    shift: e.shiftKey || undefined,
    alt: e.altKey || undefined,
    meta: e.metaKey || undefined,
  };
};

export function isRecordEndSave(e: KeyboardEvent): boolean {
  return e.key.toLowerCase() === 'enter';
}

export function isRecordEndWithoutSave(e: KeyboardEvent): boolean {
  return e.key.toLowerCase() === 'escape';
}

const modifierKeys = ['control', 'shift', 'alt', 'meta'];

export function isRecordPossible(e: KeyboardEvent): boolean {
  // space.
  if (e.key === ' ') return false;
  // just ctrl etc. without key.
  if (modifierKeys.includes(e.key.toLowerCase())) return false;

  return true;
}

export const parseKeyConfigEntry = (entry?: KeyConfigEntry) => {
  if (!entry) return undefined;
  return [
    entry.ctrl ? 'ctrl' : '',
    entry.shift ? 'shift' : '',
    entry.alt ? 'alt' : '',
    entry.meta ? 'meta' : '',
    entry.key,
  ]
    .filter((t) => t !== '')
    .join('+');
};

export function saveKeyConfigEntry(name: string, entry?: KeyConfigEntry) {
  if (!entry) return;
  setKeyConfigStore(name, 0, entry);
}

export function restoreDefaultKeyConfig() {
  setKeyConfigStore(reconcile(makeDefaultKeyConfigStore()));
}

================
File: src/controllers/log/LogController.tsx
================
import { setLogStore } from '~/stores/EditorStores';

export function setBottomBarText(text: string) {
  setLogStore('bottomBarText', text);
}

================
File: src/controllers/tool/ToolController.ts
================
import { toolStore } from '~/stores/EditorStores';

export const currentTool = () => toolStore.tools[toolStore.usingIndex];

================
File: src/styles/components/basics/checkbox.css.ts
================
import { style } from '@vanilla-extract/css';

export const checkboxWrapper = style({
  display: 'inline-flex',
  alignItems: 'center',
  cursor: 'pointer',
  position: 'relative',
});

export const hiddenCheckbox = style({
  opacity: 0,
  width: 0,
  height: 0,
  position: 'absolute',
});

export const customCheckbox = style({
  width: '10px',
  height: '10px',
  border: '1px solid #000',
  borderRadius: '0px',
  marginRight: '8px',
  display: 'inline-block',
  position: 'relative',
  overflow: 'hidden',
  transition: 'all 0.1s',
  selectors: {
    [`&::before`]: {
      content: '',
      position: 'absolute',
      left: '50%',
      top: '50%',
      width: '14px', // √2倍ちょい弱くらい
      height: '1px',
      backgroundColor: 'red',
      opacity: 0,
      transform: 'translate(-50%, -50%) rotate(45deg)',
      transformOrigin: 'center center',
      transition: 'opacity 0.1s',
    },
    [`&::after`]: {
      content: '',
      position: 'absolute',
      left: '50%',
      top: '50%',
      width: '14px',
      height: '1px',
      backgroundColor: 'red',
      opacity: 0,
      transform: 'translate(-50%, -50%) rotate(-45deg)',
      transformOrigin: 'center center',
      transition: 'opacity 0.1s',
    },
    [`${checkboxWrapper} input:checked + &::before`]: {
      opacity: 1,
    },
    [`${checkboxWrapper} input:checked + &::after`]: {
      opacity: 1,
    },
  },
});

================
File: src/styles/components/basics/dropdown.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';

export const dropdownRoot = style({
  fontFamily: vars.font.body,
  fontSize: vars.text.sm,
  backgroundColor: vars.color.secondary,
  border: '0px solid black',
  borderRadius: '0px',
  padding: '2px 6px',
  height: '20px',
  cursor: 'pointer',
  lineHeight: '12px',

  selectors: {
    '&:hover': { backgroundColor: vars.color.button_hover },
    '&:active': {
      backgroundColor: vars.color.button_pressed,
    },
    /* Windows の ▼ 矢印が滲むのを抑止 */
    '&::-ms-expand': { display: 'none' },
  },
});

================
File: src/styles/components/basics/radio_button.css.ts
================
import { style } from '@vanilla-extract/css';
import { checkboxWrapper } from '~/styles/components/basics/checkbox.css';

export const radioWrapper = checkboxWrapper; // チェックボックスと共通でOK！

export const hiddenRadio = style({
  opacity: 0,
  width: 0,
  height: 0,
  position: 'absolute',
});

export const customRadio = style({
  width: '10px',
  height: '10px',
  border: '1px solid #000',
  borderRadius: '0px', // 今は四角、丸くしたかったら '50%' にするだけ
  marginLeft: '8px',
  display: 'inline-block',
  position: 'relative',
  transition: 'all 0.1s',
  selectors: {
    [`&::after`]: {
      content: '',
      position: 'absolute',
      left: '2px',
      top: '2px',
      width: '6px',
      height: '6px',
      backgroundColor: 'red',
      opacity: 0,
      transition: 'opacity 0.1s',
    },
    [`${radioWrapper} input:checked + &::after`]: {
      opacity: 1,
    },
  },
});

================
File: src/styles/components/basics/slider.css.ts
================
// src/styles/components/basics/slider.css.ts
import { style } from '@vanilla-extract/css';

export const root = style({
  width: '100%',
});

export const slider = style({
  alignItems: 'center',
  display: 'flex',
  height: 'auto',
  overflow: 'visible',
  position: 'relative',
  width: '100%',
});

export const lineHitbox = style({
  alignItems: 'center',
  backgroundColor: 'transparent',
  cursor: 'pointer',
  display: 'flex',
  height: '16px',
  position: 'absolute',
  width: '100%',
});

export const line = style({
  backgroundColor: 'black',
  display: 'flex',
  height: '1px',
  pointerEvents: 'none', // イベントは親に任せる
  width: '100%',
});

export const handle = style({
  backgroundColor: 'black',
  height: '8px',
  left: '50%',
  pointerEvents: 'none',
  position: 'absolute',
  transform: 'translateX(-50%)',
  width: '2px',
});

================
File: src/styles/components/basics/toggle_switch.css.ts
================
import { globalStyle, style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';

const globalWidth = 16;
const thumbWidth = 10;
const thumbPadding = 2;
const globalHeight = 10;

/* ラベル全体 */
export const toggleWrapper = style({
  display: 'inline-flex',
  alignItems: 'center',
  gap: vars.spacing.sm,
  cursor: 'pointer',
  userSelect: 'none',
});

/* 入力本体 (隠す) */
export const toggleInput = style({
  opacity: 0,
  width: 0,
  height: 0,
  position: 'absolute',
});

/* バックグラウンドとなるトラック */
export const toggleTrack = style({
  width: `${globalWidth}px`,
  height: `${globalHeight}px`,
  backgroundColor: vars.color.muted,
  border: '1px solid black',
  borderRadius: '0px',
  position: 'relative',
  transition: 'background-color 0.05s',
});

/* つまみ */
export const toggleThumb = style({
  position: 'absolute',
  top: '-1px',
  left: '-1px',
  width: `${thumbWidth - thumbPadding}px`,
  height: `${globalHeight}px`,
  backgroundColor: vars.color.button,
  border: '1px solid black',
  borderRadius: '0px',
  transition: 'transform 0.02s',
});

/* ───────── 状態連動スタイル ───────── */

/* input が :checked のとき隣接する track を赤系へ */
globalStyle(`${toggleInput}:checked + ${toggleTrack}`, {
  backgroundColor: vars.color.danger,
});

/* さらに thumb を右へスライド */
globalStyle(`${toggleInput}:checked + ${toggleTrack} ${toggleThumb}`, {
  transform: `translateX(${globalWidth - thumbWidth + 2}px)`,
});

================
File: src/styles/components/canvas/canvas_controls.css.ts
================
import { style } from '@vanilla-extract/css';

export const topRightNav = style({
  display: 'flex',
  flexDirection: 'row',
  gap: '25px',
  position: 'absolute',
  right: '30px',
  top: '30px',
});

export const undoRedo = style({
  cursor: 'pointer',
  height: '24px',
  imageRendering: 'pixelated',
  padding: '8px',
  pointerEvents: 'all',
  width: '24px',
});

================
File: src/styles/components/canvas/canvas_debug_overlay.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';
import { flexCol, flexRow } from '~/styles/snippets.css';

export const canvasDebugOverlayTopLeft = style([
  flexCol,
  {
    // gap: vars.spacing.xs,
    position: 'absolute',
    left: vars.spacing.sm,
    top: vars.spacing.sm,
    pointerEvents: 'none',
  },
]);

export const canvasDebugOverlayBottomLeft = style([
  flexRow,
  {
    // gap: vars.spacing.xs,
    position: 'absolute',
    left: vars.spacing.sm,
    bottom: 0,
    transform: 'translateY(-50%)',
    alignItems: 'end',
    gap: vars.spacing.md,
    pointerEvents: 'none',
  },
]);

================
File: src/styles/components/globals/bottom_info.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '../../global.css';
import { flexRow, w100 } from '../../snippets.css';

export const bottomInfoRoot = style([
  flexRow,
  w100,
  {
    position: 'fixed',
    backgroundColor: vars.color.bg,
    borderTop: '1px solid #aaa',
    height: '20px',
    alignItems: 'center',
    padding: `0 ${vars.spacing.md}`,
    margin: 0,
    bottom: 0,
    gap: vars.spacing.md,
  },
]);

export const bottomInfoText = style({});

================
File: src/styles/components/globals/companion.module.css
================
.root {
  bottom: 0;
  left: 500px;
  pointer-events: none;
  position: absolute;
  z-index: 999;
}

.wrapper {
  animation: fluffy 2s ease-in-out infinite;
  height: 300px;
  transform-origin: center center;
  width: 300px;
}

.companion {
  anchor-name: --companion;
  display: flex;
  flex-direction: column;
  height: 50px;
  image-rendering: pixelated;
  margin: 80px auto;
  margin-left: 0;
  width: 50px;
}

.giggle {
  animation: giggle 0.5s;
  animation-iteration-count: 10;
}

.quote_box_container {
  background-color: #ddd;
  bottom: calc(anchor(top) + 17px);
  justify-self: anchor-center;
  position: absolute;
  position-anchor: --companion;
  width: fit-content;
}

.quote_box {
  anchor-name: --box;
  background: #fff;
  border: solid 1px #555;
  border-radius: 3px;
  max-width: 200px;
  overflow-wrap: break-word;
  padding: 12px;
  width: fit-content;
}

.quote_box::before {
  border: 7px solid transparent;
  border-top: 7px solid #fff;
  content: '';
  padding-left: 1px;
  position: absolute;
  position-anchor: --companion;
  top: calc(anchor(--box bottom) - 2px);
  z-index: 2;
}

.quote_box::after {
  border: 8px solid transparent;
  border-top: 8px solid #555;
  content: '';
  position: absolute;
  position-anchor: --companion;
  top: calc(anchor(--box bottom) - 1px);
}

.quote {
  image-rendering: pixelated;
}

@keyframes fluffy {
  0%,
  100% {
    transform: translateY(0);
  }

  50% {
    transform: translateY(-5px);
  }
}

@keyframes giggle {
  0% {
    transform: rotate(0deg);
  }

  25% {
    transform: rotate(2deg);
  }

  50% {
    transform: rotate(0deg);
  }

  75% {
    transform: rotate(-2deg);
  }

  100% {
    transform: rotate(0deg);
  }
}

================
File: src/styles/components/globals/edge_info.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '../../global.css';
import { flexCol, flexRow } from '../../snippets.css';

export const edgeInfoRoot = style([
  flexCol,
  {
    position: 'absolute',
    top: 0,
    bottom: 0,
    left: 0,
    gap: '10px',
    paddingTop: '32px',
    paddingBottom: '16px',
    width: vars.size.edge_info,
    justifyContent: 'end',
    alignItems: 'center',
  },
]);
export const edgeInfoItem = style([
  flexRow,
  {
    position: 'relative',
    justifyContent: 'center',
  },
]);

export const edgeInfoText = style({
  fontSize: '0.5rem',
  letterSpacing: '2px',
  whiteSpace: 'nowrap',
  transform: 'rotate(180deg)',
  transformOrigin: 'center',
  writingMode: 'vertical-lr',
});

================
File: src/styles/components/globals/section_global.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars, ZFB11 } from '~/styles/global.css';
import { flexCol, w100 } from '~/styles/snippets.css';

export const sectionRoot = style([
  flexCol,
  {
    // border: '1px solid black',
  },
]);

export const sectionCaption = style({
  fontFamily: ZFB11,
  fontSize: vars.text.sm,
  marginBottom: vars.spacing.sm,
});

export const sectionContent = style([flexCol, w100]);

================
File: src/styles/components/globals/side_sections.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '../../global.css';
import { flexCol, h100 } from '../../snippets.css';

export const sideAreaContent = style([
  flexCol,
  h100,
  {
    borderRight: '1px solid #aaa',
    gap: '1rem',
    marginLeft: vars.size.edge_info,
    padding: '20px 30px 90px 20px',
    width: vars.size.side_area,
    overflowY: 'scroll',

    '::-webkit-scrollbar': {
      width: '4px',
    },
    '::-webkit-scrollbar-thumb': {
      backgroundColor: 'transparent',
    },
    selectors: {
      '&:hover::-webkit-scrollbar-thumb': {
        backgroundColor: '#ddd',
      },
    },
  },
]);

================
File: src/styles/components/globals/title_bar.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars, ZFB08 } from '../../global.css';
import { flexCol, flexRow, h100, w100 } from '../../snippets.css';

export const titleBarRoot = style([
  flexRow,
  w100,
  {
    background: '#fff',
    pointerEvents: 'all',
    height: '28px',
    // borderBottom: "1px solid #aaa",
    alignItems: 'center',
    zIndex: 9999,
  },
]);

export const titleBarTitle = style([
  flexRow,
  w100,
  {
    width: 'fit-content',
    fontFamily: ZFB08,
    fontSize: vars.text.sm,
    marginRight: 'auto',
    paddingLeft: vars.spacing.lg,
    pointerEvents: 'none',
  },
]);

export const titleBarControls = style([
  flexRow,
  h100,
  {
    gap: vars.spacing.sm,
    marginRight: vars.spacing.sm,
  },
]);

export const titleBarControlButton = style([
  flexCol,
  h100,
  {
    background: 'none',
    backgroundColor: 'transparent',
    border: 'none',
    alignItems: 'center',
    justifyContent: 'center',
    minWidth: '24px',
    ':hover': {
      backgroundColor: 'transparent',
    },
  },
]);

export const titleBarControlMinimizeButton = style([
  titleBarControlButton,
  {
    ':hover': {
      filter: 'invert(9%) sepia(100%) saturate(6812%) hue-rotate(247deg) brightness(96%) contrast(146%);', // 青っぽく
    },
  },
]);

export const titleBarControlMaximizeButton = style([
  titleBarControlButton,
  {
    ':hover': {
      filter: 'invert(92%) sepia(20%) saturate(3846%) hue-rotate(112deg) brightness(105%) contrast(102%);', // 緑っぽく
    },
  },
]);

export const titleBarControlCloseButton = style([
  titleBarControlButton,
  {
    ':hover': {
      filter: 'invert(11%) sepia(92%) saturate(7351%) hue-rotate(0deg) brightness(99%) contrast(109%);', // 赤っぽく
    },
  },
]);

export const titleBarControlButtonImg = style({
  width: '10px',
  height: '10px',
  imageRendering: 'pixelated',
});

================
File: src/styles/components/layer_preview.css.ts
================
import { style } from '@vanilla-extract/css';
import { wh100 } from '../snippets.css';

export const layerPreviewCanvas = style([
  wh100,
  {
    imageRendering: 'crisp-edges',
    borderRight: '1px solid black',
  },
]);

================
File: src/styles/components/light.css.ts
================
import { style } from '@vanilla-extract/css';

export const lightInnerOff = style({
  filter: 'drop-shadow(0 0 0 red);',
  opacity: 0,
  transition: 'none',
});

export const lightInnerOn = style({
  filter: 'drop-shadow(0 0 1px red);',
  opacity: 1,
  transition: 'opacity 1s ease',
});

================
File: src/styles/components/settings/key_config_settings.css.ts
================
import { style } from '@vanilla-extract/css';

export const keyConfigName = style({
  width: '80px',
});

================
File: src/types/DrawState.ts
================
export enum DrawState {
  start,
  move,
  end,
}

================
File: src/types/KeyConfig.ts
================
export type KeyConfigEntry = {
  key: string; // 例: "z", "x", "ArrowUp"
  ctrl?: boolean;
  shift?: boolean;
  alt?: boolean;
  meta?: boolean; // MacのCommandキーなど
};

================
File: src/types/LayerHistory.ts
================
import { DiffAction } from '../models/layer_image/HistoryManager';

export type LayerHistory = {
  undoStack: DiffAction[];
  redoStack: DiffAction[];
};

================
File: src/types/PaletteType.ts
================
export enum PaletteType {
  primary = 'primary',
  secondary = 'secondary',
}

================
File: src/types/Size.ts
================
export type Size2D = {
  width: number;
  height: number;
};

================
File: src/types/Vector.ts
================
export interface Vec2 {
  x: number;
  y: number;
}

================
File: src/utils/consts.ts
================
export const Consts = {
  maxPenSize: 20,
  minCanvasWidth: 1,
  maxCanvasWidth: 5000,
  minCanvasHeight: 1,
  maxCanvasHeight: 5000,
};

================
File: src/utils/DrawUtils.ts
================
import { Vec2 } from '../types/Vector';

export function drawSquarePixel(p: Vec2, size: number, drawFn: (x: number, y: number) => void) {
  const half = Math.floor(size / 2);
  for (let dy = -half; dy <= half; dy++) {
    for (let dx = -half; dx <= half; dx++) {
      drawFn(p.x + dx, p.y + dy);
    }
  }
}

export function drawCompletionLine(p0: Vec2, p1: Vec2, draw: (x: number, y: number) => void) {
  const dx = Math.abs(p1.x - p0.x);
  const dy = Math.abs(p1.y - p0.y);
  const sx = p0.x < p1.x ? 1 : -1;
  const sy = p0.y < p1.y ? 1 : -1;
  let err = dx - dy;

  const steps = Math.max(dx, dy); // 移動回数の上限

  let x = p0.x;
  let y = p0.y;

  for (let i = 0; i <= steps; i++) {
    draw(x, y);
    if (x === p1.x && y === p1.y) {
      break; // 念のため（ただたどり着く設計にはなってる）
    }
    const e2 = 2 * err;
    if (e2 > -dy) {
      err -= dy;
      x += sx;
    }
    if (e2 < dx) {
      err += dx;
      y += sy;
    }
  }
}

================
File: todo_dsl.md
================
# DSL nodes TODO

## effect node

- [x] bright(n) (currently its "brightness") #明るさ
- [ ] contrast(n) #コントラスト
- [ ] saturate(n) #彩度
- [ ] hue(n) #色相
- [x] grayscale()（= saturate(-100)）
- [x] tone("sepia")
- [x] invert()
- [ ] blur(radius)
- [ ] sharpen(amount)

## pass node

### in/out

- [ ] in(layer_id) (that actually works as node)
- [ ] out(layer_id) (that actually works as node)
- [ ] multiout(\*a, \*b)

### area filter

- [ ] splitH(rate)
- [ ] splitV(rate)
- [ ] rect(lt, rt, lb, rb)
- [ ] select(x1, y1, x2, y2, ...) #多ピクセル座標指定で選択
- [ ] rand_hlines_area(density, seed)
- [ ] rand_vlines_area(density, seed)

## fracture node

- [x] jpeg_glitch(seed, quality, amount)

## combine node (image-level DSL)

入力元のデータの上にabove_dataを重ねる

- [ ] combine_override(above_data) #通常(上書き)
- [ ] combine_multiply(above_data) #乗算
- [ ] combine_add(above_data) #加算
- [ ] combine_exclude(above_data) #除外
- [ ] combine_mask(above_data) #マスク(透明以外で)

## other syntaxs

- [ ] assertions `[some-assertion]`
- [ ] instant subout memory `\*subout`
- [ ] pre-init subout memory `init subout`

================
File: .eslintrc.cjs
================
/** @type {import("eslint").Linter.Config} */

module.exports = {
  root: true,
  env: { browser: true, es2024: true, node: true },
  parser: '@typescript-eslint/parser',
  parserOptions: { project: './tsconfig.json', tsconfigRootDir: __dirname },
  plugins: ['@typescript-eslint', 'solid', 'import'],
  extends: ['eslint:recommended', 'plugin:solid/typescript'],
  rules: {
    'solid/jsx-no-undef': 'error',
    'unused-imports/no-unused-imports': 'warn',
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/no-empty-object-type': 'off',
    'import/order': ['warn', { alphabetize: { order: 'asc' } }],
    'prettier/prettier': ['error', {}, { usePrettierrc: true }],
  },
  ignorePatterns: ['./dist*', './node_modules', 'src-tauri/**/target', '*.d.ts'],
};

================
File: .gitignore
================
dist
.wrangler
.output
.vercel
.netlify
.vinxi
app.config.timestamp_*.js

# Environment
.env
.env*.local

# dependencies
/node_modules

# IDEs and editors
/.idea
.project
.classpath
*.launch
.settings/

# Temp
gitignore

# System Files
.DS_Store
Thumbs.db

# repomix
repomix-output.txt
repomix-output.xml

================
File: dist-tcm/styles/components/canvas/canvas_stack.module.css.d.ts
================
declare const styles: {
  readonly "canvas_stack": string;
  readonly "image-container": string;
  readonly "resize-image": string;
};
export = styles;

================
File: dist-tcm/styles/components/canvas/controls.module.css.d.ts
================
declare const styles: {
  readonly "bottom-history": string;
  readonly "cursor": string;
  readonly "history-row": string;
  readonly "history-text": string;
  readonly "top-right-button-container": string;
  readonly "top-right-nav": string;
  readonly "undo_redo": string;
};
export = styles;

================
File: index.html
================
<!-- index.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Sledge</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <!--  -->
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <script src="/libs/speakjs/speakClient.js"></script>
  </body>
</html>

================
File: src/components/global/BottomInfo.tsx
================
import { Component } from 'solid-js';
import { AboutWindowOptions } from '~/routes/about';
import { interactStore, logStore } from '~/stores/EditorStores';

import { bottomInfoRoot, bottomInfoText as bottomInfoTextStyle } from '~/styles/components/globals/bottom_info.css';
import { openSingletonWindow } from '~/utils/windowUtils';

const BottomInfo: Component = () => {
  return (
    <div class={bottomInfoRoot}>
      <a
        class={bottomInfoTextStyle}
        style={{ 'pointer-events': 'all', cursor: 'pointer' }}
        onClick={() => openSingletonWindow('about', AboutWindowOptions)}
      >
        sledge.
      </a>
      <p class={bottomInfoTextStyle}>x{interactStore.zoom}</p>
      <p class={bottomInfoTextStyle}>{logStore.bottomBarText}</p>
    </div>
  );
};

export default BottomInfo;

================
File: src/components/global/SideSections.tsx
================
import { Component } from 'solid-js';
import CanvasSettings from '../section/CanvasSettings';
import Color from '../section/Color';
import LayerList from '../section/LayerList';
import Project from '../section/Project';
import ToolConfig from '../section/ToolConfig';

import { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';
import { sideAreaContent } from '~/styles/components/globals/side_sections.css';

const SideSections: Component = () => {
  return (
    <div class={sideAreaContent}>
      <a onClick={() => getCurrentWebviewWindow().close()}>&lt; back</a>
      <Project />
      <Color />
      <ToolConfig />
      <LayerList />
      <CanvasSettings />
    </div>
  );
};

export default SideSections;

================
File: src/components/global/TitleBar.tsx
================
import { getCurrentWindow } from '@tauri-apps/api/window';
import { createEffect, createSignal, onMount } from 'solid-js';
import { projectStore } from '~/stores/ProjectStores';
import {
  titleBarControlButtonImg,
  titleBarControlCloseButton,
  titleBarControlMaximizeButton,
  titleBarControlMinimizeButton,
  titleBarControls,
  titleBarRoot,
  titleBarTitle,
} from '~/styles/components/globals/title_bar.css';

export default function TitleBar() {
  const window = getCurrentWindow();

  const [isMaximizable, setIsMaximizable] = createSignal(true);
  const [isMinimizable, setIsMinimizable] = createSignal(true);
  const [isClosable, setIsClosable] = createSignal(true);
  const [isEditor, setIsEditor] = createSignal(false);
  const [title, setTitle] = createSignal('');
  const [isMaximized, setMaximized] = createSignal(false);

  onMount(async () => {
    setIsMaximizable(await window.isMaximizable());
    setIsMinimizable(await window.isMinimizable());
    setIsClosable(await window.isClosable());
    setTitle(await window.title());
    setIsEditor(window.label.startsWith('editor'));
    // if (isEditor()) {
    //   setTitle(`${projectStore.name} - ${projectStore.path}`);
    // }
  });

  window.onResized(async (handler) => {
    setMaximized(await window.isMaximized());
  });

  createEffect(() => {
    if (isEditor()) {
      let pathText = '';
      let isSavedText = '';
      if (projectStore.path !== undefined && projectStore.path !== '') {
        pathText += projectStore.isProjectChangedAfterSave ? '(unsaved)' : '';
        pathText += ' - ' + projectStore.path;
      } else {
        pathText += '(not saved yet)';
      }

      setTitle(`${projectStore.name} ${pathText} `);
    }
  });

  const borderWindowLabels: string[] = ['editor'];
  const shouldShowBorder = () => borderWindowLabels.find((l) => l === window.label);

  return (
    <header
      style={{
        'pointer-events': 'all',
        'border-bottom': shouldShowBorder() ? '1px solid #aaa' : 'none',
      }}
    >
      <nav class={titleBarRoot} data-tauri-drag-region='p, button'>
        <p class={titleBarTitle}>{title()}.</p>
        <div class={titleBarControls}>
          {isMinimizable() && (
            <button class={titleBarControlMinimizeButton} onClick={() => window.minimize()}>
              <img class={titleBarControlButtonImg} src={'/minimize.png'} />
            </button>
          )}
          {isMaximizable() && (
            <button class={titleBarControlMaximizeButton} onClick={() => window.toggleMaximize()}>
              <img class={titleBarControlButtonImg} src={isMaximized() ? '/leave_maximize.png' : '/maximize.png'} />
            </button>
          )}
          {isClosable() && (
            <button class={titleBarControlCloseButton} onClick={() => window.close()}>
              <img class={titleBarControlButtonImg} src={'/close.png'} />
            </button>
          )}
        </div>
      </nav>
    </header>
  );
}

================
File: src/components/section/item/ToolItem.tsx
================
import { Component } from 'solid-js';
import Slider from '~/components/common/basics/Slider';
import { sayRandomQuote } from '~/components/common/companion/QuotePool';
import { setToolStore, toolStore } from '~/stores/EditorStores';
import { toolConfigRow, toolConfigRowClickable, toolConfigRowIcon, toolConfigRowName } from '~/styles/section/pen.css';
import { Tool, ToolType } from '~/types/Tool';
import { Consts } from '~/utils/consts';

interface Props {
  tool: Tool;
  isInUse: boolean;
}

const ToolItem: Component<Props> = (props: Props) => {
  let src = '';
  switch (props.tool.type) {
    case ToolType.Pen:
      src = '/pen.png';
      break;
    case ToolType.Eraser:
      src = '/eraser_b.png';
      break;
    case ToolType.Fill:
      src = '/fill_G_x10.png';
      break;
  }
  return (
    <div class={toolConfigRow}>
      {/* <Light on={props.isInUse} /> */}
      <div
        class={toolConfigRowClickable}
        onClick={() => {
          setToolStore({ usingIndex: toolStore.tools.indexOf(props.tool) });
        }}
      >
        <img
          class={toolConfigRowIcon}
          style={{
            'image-rendering': 'pixelated',
            filter: props.isInUse
              ? 'invert(11%) sepia(92%) saturate(7351%) hue-rotate(0deg) brightness(99%) contrast(109%)'
              : 'none',
          }}
          src={src}
          width={20}
          height={20}
        />
        <p
          class={toolConfigRowName}
          style={{
            color: props.isInUse ? 'red' : 'unset',
          }}
        >
          {props.tool.name}.
        </p>
      </div>

      {(props.tool.type === ToolType.Pen || props.tool.type === ToolType.Eraser) && (
        <>
          <div style={{ 'flex-grow': 1 }}>
            <Slider
              min={1}
              max={Consts.maxPenSize}
              default={props.tool.size}
              onValueChanged={(newValue) => {
                sayRandomQuote('pen-resize');
                console.log('size set to ' + newValue);
                const penIndex = toolStore.tools.findIndex((p) => p.id === props.tool.id);
                setToolStore('tools', penIndex, 'size', newValue);
              }}
            />
          </div>

          <p style={{ width: 'auto' }}>{props.tool.size}.</p>
        </>
      )}
    </div>
  );
};

export default ToolItem;

================
File: src/controllers/canvas/LayerCanvasOperator.ts
================
import { LayerCanvasRef } from '~/components/canvas/stacks/LayerCanvas';
import { setBottomBarText } from '~/controllers/log/LogController';
import { currentTool } from '~/controllers/tool/ToolController';
import { Vec2 } from '~/types/Vector';
import { hexToRGBA } from '~/utils/ColorUtils';
import LayerImageAgent from '../../models/layer_image/LayerImageAgent';
import TileLayerImageAgent from '../../models/layer_image/agents/TileLayerImageAgent';
import { getToolInstance } from '../../models/tool/ToolBase';
import { DrawState } from '../../types/DrawState';
import { Tool } from '../../types/Tool';
import { currentColor } from '../color/ColorController';

export default class LayerCanvasOperator {
  constructor(private readonly getActiveLayerCanvas: () => LayerCanvasRef) {}

  public handleDraw(state: DrawState, position: Vec2, last?: Vec2) {
    const layerCanvasRef = this.getActiveLayerCanvas();
    const layer = layerCanvasRef.getLayer();
    const agent = layerCanvasRef.getAgent();
    const image = agent.getImage();
    if (!image) return;

    position = this.getMagnificatedPosition(position, layer.dotMagnification);
    if (last) last = this.getMagnificatedPosition(last, layer.dotMagnification);

    const result = this.useTool(agent, state, image, currentTool(), position, last);

    if (result) {
      agent.setDrawingBuffer(result);
      if (state === DrawState.end) {
        agent.registerDiffAction();
        agent.setImage(result);

        if (agent instanceof TileLayerImageAgent) {
          (agent as TileLayerImageAgent).resetAllDirtyStates();
        }
      }
    }
  }

  private useTool(agent: LayerImageAgent, state: DrawState, image: ImageData, tool: Tool, position: Vec2, last?: Vec2) {
    const toolInstance = getToolInstance(tool.type);
    const toolArgs = {
      image,
      position,
      lastPosition: last,
      size: tool.size,
      color: hexToRGBA(currentColor()),
    };
    const startTime = Date.now();
    let isDrawnAction;
    switch (state) {
      case DrawState.start:
        const isDrawnActionInStart = toolInstance.onStart(agent, toolArgs);
        const isDrawnActionInMove = toolInstance.onMove(agent, toolArgs);
        isDrawnAction = isDrawnActionInStart || isDrawnActionInMove;
        break;
      case DrawState.move:
        isDrawnAction = toolInstance.onMove(agent, toolArgs);
        break;
      case DrawState.end:
        isDrawnAction = toolInstance.onEnd(agent, toolArgs);
        break;
    }
    const endTime = Date.now();
    if (isDrawnAction) {
      if (agent instanceof TileLayerImageAgent) {
        setBottomBarText(
          `${tool.type} finished. ${endTime - startTime} ms. (updated ${(agent as TileLayerImageAgent).getDirtyTiles().length} dirty tiles)`
        );
      } else {
        setBottomBarText(`${tool.type} finished. ${endTime - startTime} ms.`);
      }
    }
    return image;
  }

  private getMagnificatedPosition(position: Vec2, dotMagnification: number) {
    return {
      x: Math.floor(position.x / dotMagnification),
      y: Math.floor(position.y / dotMagnification),
    };
  }
}

================
File: src/controllers/color/ColorController.ts
================
import { colorStore, setColorStore } from '~/stores/EditorStores';
import { PaletteType } from '~/types/PaletteType';

export const currentColor = (): string => {
  return colorStore[colorStore.currentPalette];
};
export const setCurrentColor = (colorHexString: string) => {
  return setColorStore(colorStore.currentPalette, colorHexString);
};
export const setColor = (palette: PaletteType, colorHexString: string) => {
  return setColorStore(palette, colorHexString);
};
export const selectPalette = (palette: PaletteType) => {
  return setColorStore('currentPalette', palette);
};

================
File: src/controllers/layer/LayerFactory.ts
================
import { v4 } from 'uuid';
import { resetLayerImage } from '~/controllers/layer/LayerController';
import { layerListStore } from '~/stores/ProjectStores';
import { Layer, LayerType } from '~/types/Layer';
import { DSL } from '../../models/dsl/DSL';

export const createLayer = (name: string, type: LayerType, enabled = true, dotMagnification = 1, dsl?: DSL): Layer => {
  // check if name already exists
  const endNums = name.match(/^(.*)(\d+)$/);
  if (endNums && endNums.length >= 3) {
    const nameWithoutNum = endNums[1];
    const endNum = Number(endNums[2]);

    const foundSameNameNums: number[] = [];
    layerListStore.layers.forEach((layer) => {
      const layerEndNums = layer.name.match(/^(.*)(\d+)$/);
      if (layerEndNums && layerEndNums.length >= 3) {
        const layerNameWithoutNum = layerEndNums[1];
        const layerEndNum = Number(layerEndNums[2]);
        if (nameWithoutNum === layerNameWithoutNum) {
          foundSameNameNums.push(layerEndNum);
        }
      }
    });

    let num = endNum;
    while (foundSameNameNums.find((foundNum) => foundNum === num)) {
      num++;
    }
    name = nameWithoutNum + num;
  }

  const id = v4();
  resetLayerImage(id, dotMagnification);

  return {
    id,
    name,
    type,
    typeDescription: getTypeString(type),
    enabled,
    dotMagnification,
    dsl: dsl || new DSL(id, id),
  };
};

function getTypeString(type: LayerType): string {
  switch (type) {
    case LayerType.Dot:
      return 'dot layer.';
    case LayerType.Image:
      return 'image layer.';
    case LayerType.Automate:
      return 'automate layer.';
    default:
      return 'N/A.';
  }
}

================
File: src/io/global_config/globalSettings.ts
================
import { BaseDirectory, mkdir, readTextFile, writeTextFile } from '@tauri-apps/plugin-fs';
import { getGlobalRootStore, globalStore, keyConfigStore, loadGlobalStore } from '~/stores/GlobalStores';

const FILE_NAME = 'global.sledgeconfig';

export async function saveGlobalSettings() {
  try {
    const json = JSON.stringify(getGlobalRootStore());
    console.log(json);
    await mkdir('', { baseDir: BaseDirectory.AppConfig, recursive: true });
    await writeTextFile(FILE_NAME, json, { baseDir: BaseDirectory.AppConfig });
    console.log('global settings save done.');
  } catch (e) {
    console.error('global settings save failed.', e);
  }
}

export async function loadGlobalSettings() {
  try {
    const json = await readTextFile(FILE_NAME, {
      baseDir: BaseDirectory.AppConfig,
    });
    const data = JSON.parse(json);

    loadGlobalStore(data);

    console.log('global settings load done.', data);
  } catch (e) {
    console.log('global settings load failed.', e);
  }
}

================
File: src/models/dsl/nodes/AvailableNodes.ts
================
import { SledgeNode } from './DSLNodes';
import { Brightness } from './effect/Brightness';
import { GrayScale } from './effect/GrayScale';
import { Invert } from './effect/Invert';
import { Sepia } from './effect/Sepia';
import { JpegGlitch } from './fracture/JpegGlitch';

export const ALL_NODES: SledgeNode[] = [
  // effect
  new Brightness(),
  new GrayScale(),
  new Invert(),
  new Sepia(),
  // pass
  // new LayerIn(""),
  // new LayerOut(""),
  // fracture
  new JpegGlitch(),
];

================
File: src/models/dsl/nodes/DSLNodes.ts
================
// 旧
// export enum ImageCommands {
//   INVERT = "invert",
//   GRAYSCALE = "grayscale",
//   GLITCH = "glitch",
//   SEPIA = "sepia",
//   BRIGHTNESS = "brightness",
// }
// export type ImageCommandParams =
//   | {
//       command:
//         | ImageCommands.INVERT
//         | ImageCommands.GRAYSCALE
//         | ImageCommands.SEPIA;
//     }
//   | { command: ImageCommands.BRIGHTNESS; delta: number };

export type NodeType = 'effect' | 'pass' | 'fracture';

export interface NodeArg {
  name: string;
  default: number | string | undefined;
}

export abstract class SledgeNode {
  abstract name: string;
  abstract type: NodeType;
  abstract description: string;

  constructor() {}

  // error occured = undefined
  abstract getNodeString(): string | undefined;
}

================
File: src/models/dsl/nodes/effect/Brightness.ts
================
import { EffectNode } from './EffectNode';

export class Brightness extends EffectNode {
  name: string = 'brightness';
  description: string = 'brightness';

  constructor(private delta: number = 30) {
    super();
  }

  getNodeString(): string {
    return `${this.name}(${this.delta})`;
  }
}

================
File: src/models/dsl/nodes/effect/EffectNode.ts
================
import { NodeType, SledgeNode } from '../DSLNodes';

export abstract class EffectNode extends SledgeNode {
  type: NodeType = 'effect';
}

================
File: src/models/dsl/nodes/effect/GrayScale.ts
================
import { EffectNode } from './EffectNode';

export class GrayScale extends EffectNode {
  name: string = 'grayscale';
  description: string = 'grayscale';

  getNodeString(): string {
    return `${this.name}()`;
  }
}

================
File: src/models/dsl/nodes/effect/Invert.ts
================
import { EffectNode } from './EffectNode';

export class Invert extends EffectNode {
  name: string = 'invert';
  description: string = 'invert';

  getNodeString(): string {
    return `${this.name}()`;
  }
}

================
File: src/models/dsl/nodes/effect/Sepia.ts
================
import { EffectNode } from './EffectNode';

export class Sepia extends EffectNode {
  name: string = 'sepia';
  description: string = 'sepia';

  getNodeString(): string {
    return `${this.name}()`;
  }
}

================
File: src/models/dsl/nodes/fracture/FractureNode.ts
================
import { NodeType, SledgeNode } from '../DSLNodes';

export abstract class FractureNode extends SledgeNode {
  type: NodeType = 'fracture';
}

================
File: src/models/dsl/nodes/fracture/JpegGlitch.ts
================
import { FractureNode } from './FractureNode';

export class JpegGlitch extends FractureNode {
  name = 'jpeg_glitch';
  description = 'JPEG glitch effect using random byte corruption';

  private seed = Math.floor(Math.random() * 100);
  private quality = 90;
  private amount = 0.001; // 2%の破壊

  getNodeString(): string {
    return `${this.name}(${this.seed}, ${this.quality}, ${this.amount})`;
  }
}

================
File: src/models/dsl/nodes/pass/LayerIn.ts
================
import { PassNode } from './PassNode';

export class LayerIn extends PassNode {
  name: string = 'in';
  description: string = 'layer_in';

  constructor(public layerId?: string) {
    super();
  }

  getNodeString(): string | undefined {
    if (!this.layerId) return undefined;
    return `${this.name}(${this.layerId})`;
  }
}

================
File: src/models/dsl/nodes/pass/LayerOut.ts
================
import { PassNode } from './PassNode';

export class LayerOut extends PassNode {
  name: string = 'out';
  description: string = 'out';

  constructor(public layerId?: string) {
    super();
  }

  getNodeString(): string | undefined {
    if (!this.layerId) return undefined;
    return `${this.name}(${this.layerId})`;
  }
}

================
File: src/models/dsl/nodes/pass/PassNode.ts
================
import { NodeType, SledgeNode } from '../DSLNodes';

export abstract class PassNode extends SledgeNode {
  type: NodeType = 'pass';
}

================
File: src/models/tool/eraser/EraserTool.ts
================
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';
import { drawCompletionLine, drawSquarePixel } from '../../../utils/DrawUtils';
import { Tool, ToolArgs } from '../ToolBase';

export class EraserTool implements Tool {
  onStart(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }

  onMove(agent: LayerImageAgent, { position, lastPosition, size }: ToolArgs) {
    if (!size) return false;

    drawSquarePixel(position, size, (px, py) => {
      const diff = agent.deletePixel({ x: px, y: py }, true, true);
      if (diff !== undefined) {
        agent.addDiffs([diff]);
      }
    });

    if (lastPosition !== undefined) {
      drawCompletionLine(position, lastPosition, (x, y) => {
        drawSquarePixel({ x, y }, size, (px, py) => {
          const diff = agent.deletePixel({ x: px, y: py }, true, true);
          if (diff !== undefined) {
            agent.addDiffs([diff]);
          }
        });
      });
    }

    return true;
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }
}

================
File: src/models/tool/fill/FillTool.ts
================
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';
import { Vec2 } from '~/types/Vector';
import { RGBAColor } from '~/utils/ColorUtils';
import { Tool, ToolArgs } from '../ToolBase';
import { TileFloodFill } from './TileFloodFill';

export interface FillProps {
  agent: LayerImageAgent;
  color: RGBAColor;
  position: Vec2;
}
export interface Fill {
  fill: (props: FillProps) => void;
}

export class FillTool implements Tool {
  onStart(agent: LayerImageAgent, { position, lastPosition, color }: ToolArgs) {
    const fill = new TileFloodFill();

    fill.fill({ agent, color, position });

    return true;
  }

  onMove(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }
}

================
File: src/models/tool/fill/PixelFloodFill.ts
================
import { PixelDiff } from '~/models/layer_image/HistoryManager';
import { Vec2 } from '~/types/Vector';
import { colorMatch } from '~/utils/ColorUtils';
import { Fill, FillProps } from './FillTool';

export class PixelFloodFill implements Fill {
  fill({ agent, color, position }: FillProps) {
    const targetColor = agent.getPixel(position);
    const matches = (p: Vec2) => colorMatch(agent.getPixel(p), targetColor);

    console.log(color);
    console.log(targetColor);

    if (colorMatch(targetColor, color)) return false;

    // console.log(`---${image.width}x${image.height} flood fill---`)

    if (colorMatch(targetColor, color)) return false;
    console.log('fill started.');

    const scanStart = Date.now();
    const queue: Vec2[] = [position];
    const filled: Vec2[] = [];
    const visited = new Uint8Array(agent.getWidth() * agent.getHeight()); // 0:未訪問, 1:訪問済
    const index = (p: Vec2) => p.y * agent.getWidth() + p.x;
    let queueCount = 0;
    let visitCount = 0;
    while (queue.length > 0) {
      queueCount++;
      const c = queue.pop()!;
      if (!agent.isInBounds(c)) continue;

      const i = index(c);
      if (visited[i]) continue;
      visited[i] = 1;
      visitCount++;

      if (matches(c)) {
        filled.push(c);
        queue.push({ x: c.x + 1, y: c.y });
        queue.push({ x: c.x - 1, y: c.y });
        queue.push({ x: c.x, y: c.y + 1 });
        queue.push({ x: c.x, y: c.y - 1 });
      }
    }

    const scanEnd = Date.now();
    console.log('scan finished. ' + (scanEnd - scanStart) + 'ms.');

    const writeStart = Date.now();

    const pxDiffs: PixelDiff[] = [];
    // バッファに一括反映
    for (const p of filled) {
      const diff = agent.setPixel(p, color, false, false);
      if (diff !== undefined) pxDiffs.push(diff);
    }
    const writeEnd = Date.now();
    console.log('write finished. ' + (writeEnd - writeStart) + 'ms.');

    agent.addDiffs(pxDiffs);
  }
}

================
File: src/models/tool/ToolFactory.ts
================
import { v4 } from 'uuid';
import { Tool, ToolType } from '~/types/Tool';

export const createTool = (type: ToolType, name: string, size: number): Tool => ({
  id: v4(),
  type,
  name,
  size,
});

================
File: src/stores/EditorStores.ts
================
// editorStore.tsx
import { createStore } from 'solid-js/store';
import { createTool } from '~/models/tool/ToolFactory';
import { PaletteType } from '~/types/PaletteType';
import { Size2D } from '~/types/Size';
import { Tool, ToolType } from '~/types/Tool';
import { Vec2 } from '~/types/Vector';

type ColorStore = {
  currentPalette: PaletteType;
  primary: string;
  secondary: string;
  swatches: string[];
};
type InteractStore = {
  canvasAreaSize: Size2D;
  canvasElementSize: Size2D;
  lastMouseWindow: Vec2;
  lastMouseOnCanvas: Vec2;
  isInStroke: boolean;
  zoom: number;
  zoomMin: number;
  zoomMax: number;
  touchZoomSensitivity: number;
  wheelZoomStep: number;
  offsetOrigin: Vec2;
  offset: Vec2;

  isCtrlPressed: boolean;
  isDragging: boolean;
};
type LogStore = {
  bottomBarText: string;
};
type ToolStore = {
  usingIndex: number;
  tools: Tool[];
};

const defaultColorStore: ColorStore = {
  currentPalette: 'primary' as PaletteType,
  primary: '#000000', // 通常の描画色
  secondary: '#ffffff', // 背景・消しゴムなど
  swatches: [
    '#000000',
    '#FFFFFF',
    '#ffff00',
    '#00ffff',
    '#00ff00',
    '#ff00ff',
    '#ff0000',
    '#0000ff',
    '#000080',
    '#400080',
  ],
};
const defaultInteractStore: InteractStore = {
  canvasAreaSize: { width: 0, height: 0 },
  canvasElementSize: { width: 0, height: 0 },
  lastMouseWindow: { x: 0, y: 0 },
  lastMouseOnCanvas: { x: 0, y: 0 },
  isInStroke: false,
  zoom: 1,
  zoomMin: 0.5,
  zoomMax: 8,
  touchZoomSensitivity: 0.5,
  wheelZoomStep: 0.05,
  // オフセットの初期値
  offsetOrigin: { x: 0, y: 0 },
  offset: { x: 0, y: 0 },

  isCtrlPressed: false,
  isDragging: false,
};
const defaultLogStore: LogStore = {
  bottomBarText: '',
};
const defaultToolStore: ToolStore = {
  usingIndex: 0,
  tools: [
    createTool(ToolType.Pen, 'pen', 1),
    createTool(ToolType.Eraser, 'eraser', 1),
    createTool(ToolType.Fill, 'fill', 1),
  ],
};

export const initEditorStore = () => {
  const [colorStore, setColorStore] = createStore<ColorStore>(defaultColorStore);
  const [interactStore, setInteractStore] = createStore<InteractStore>(defaultInteractStore);
  const [toolStore, setToolStore] = createStore<ToolStore>(defaultToolStore);
  const [logStore, setLogStore] = createStore<LogStore>(defaultLogStore);

  return {
    colorStore,
    setColorStore,
    interactStore,
    setInteractStore,
    logStore,
    setLogStore,
    toolStore,
    setToolStore,
  };
};

const editorStore = initEditorStore();

export const colorStore = editorStore.colorStore;
export const setColorStore = editorStore.setColorStore;

export const interactStore = editorStore.interactStore;
export const setInteractStore = editorStore.setInteractStore;

export const logStore = editorStore.logStore;
export const setLogStore = editorStore.setLogStore;

export const toolStore = editorStore.toolStore;
export const setToolStore = editorStore.setToolStore;

================
File: src/styles/components/canvas/canvas_stack.css.ts
================
'background-image';
import { style } from '@vanilla-extract/css';
import { flexRow } from '~/styles/snippets.css';

const transparent_bg_size = 4;
const transparent_bg_color = '#0000000A';

export const canvasStack = style([
  flexRow,
  {
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',

    backgroundImage:
      `linear-gradient(45deg, ${transparent_bg_color} 25%, transparent 25%, transparent 75%, ${transparent_bg_color} 75%),` +
      `linear-gradient(45deg, ${transparent_bg_color} 25%, transparent 25%, transparent 75%, ${transparent_bg_color} 75%)`,
    backgroundSize: `${transparent_bg_size * 2}px ${transparent_bg_size * 2}px`,
    backgroundPosition: `0 0, ${transparent_bg_size}px ${transparent_bg_size}px`,
  },
]);

================
File: src/styles/components/palette.css.ts
================
import { style } from '@vanilla-extract/css';
import { flexRow } from '../snippets.css';

export const paletteRoot = style([
  flexRow,
  {
    gap: '6px',
  },
]);

export const paletteColorBoxContainer = style({
  position: 'relative',
});

export const paletteColorBoxPrimary = style({
  position: 'absolute',
  top: 0,
  left: 0,
});

export const paletteColorBoxSecondary = style({
  position: 'absolute',
  top: 10,
  left: 10,
});

================
File: src/styles/snippets.css.ts
================
import { style } from '@vanilla-extract/css';

export const flexCol = style({
  display: 'flex',
  flexDirection: 'column',
});

export const flexRow = style({
  display: 'flex',
  flexDirection: 'row',
});

export const w100 = style({
  width: '100%',
});

export const h100 = style({
  height: '100%',
});

export const wh100 = style([w100, h100]);

================
File: src/types/Canvas.ts
================
export type Canvas = {
  width: number;
  height: number;
};

export type ImageRenderingAttribute = 'auto' | 'pixelated' | 'crispEdges';
export type CanvasRenderingMode = 'adaptive' | 'pixelated' | 'crispEdges';

================
File: src/types/FileLocation.ts
================
export type FileLocation = {
  path: string;
  name: string;
};

================
File: src/types/Layer.ts
================
import { DSL } from '~/models/dsl/DSL';

export enum LayerType {
  Dot,
  Image,
  Automate,
}

export type Layer = {
  id: string;
  name: string;
  type: LayerType;
  typeDescription: string; // 各タイプの説明
  enabled: boolean;
  dotMagnification: number;
  dsl: DSL;
};

================
File: src/types/Tool.ts
================
export enum ToolType {
  Pen = 'pen',
  Eraser = 'eraser',
  Fill = 'fill',
}

export type Tool = {
  type: ToolType;
  id: string;
  name: string;
  size: number;
};

================
File: todo.md
================
# TODO

## roadmap

- [x] phase0: prototype/mock
- [x] phase1: drawing features (pen, eraser, layer)
- [ ] phase2: in-app settings (add+edit layers / add+edit pens / edit canvas size + misc)
- [ ] phase3: more ui feature (dialog, toast, internal log), import/export
- [ ] phase4: effects (js implementation)
- [ ] phase5: extra features (optimization, animation, etc)

## pen / tools

- [x] `tool:` pen
- [x] `tool:` eraser
- [ ] `tool:` erase along edge
- [ ] `tool:` spoiler
- [ ] `tool:` bucket(fill)
- [ ] `tool:` shape(circle)
- [ ] `tool:` shape(rect)
- [x] `ui:` size slider

## colors

- [x] `ui:` color picker
- [x] `ui:` color select(standard)

## layers

- [ ] `layer:` dot layer (w/dotMagnifier)
- [ ] `layer:` automate layer (w/dotMagnifier, mode: langton, life)
- [x] `ui:` layer list
- [x] `ui:` sorting
- [x] `ui:` enable/disable
- [x] `ui:` active layer selection
- [ ] `ui:` DSL edit button (-> GUI editor)
- [ ] `data:` compose layers into one image (image-level DSL)

## image_pool

- [x] `ui:` drag
- [x] `ui:` resize
- [ ] `ui:` image DSL edit button

## dsl(rust)

- [ ] `ui:` DSL GUI editor
- [ ] `ui:` DSL CLI editor

> TODO of nodes are in ./todo_dsl.md

## i/o

- [x] `data:` import: image to image_pool
- [x] `data:` import: instant bounce to active layer
- [x] `data:` layer-level export: w/o DSL
- [ ] `data:` layer-level export: with DSL
- [ ] `data:` image-level export: w/o DSL
- [ ] `data:` image-level export: with DSL

## misc

- [x] `misc:` document(dsl)
- [ ] `misc:` document(sledge)
- [ ] `ui:` setting screen
- [ ] `ui:` dialog
- [ ] `ui:` toast
- [ ] `ui:` logging in GUI
- [ ] `ui:` magnifier(mouse-pivot zoomed scope)
- [x] `ui:` companion

================
File: .prettierrc
================
{
  "tabWidth": 2,
  "useTabs": false,
  "trailingComma": "es5",
  "singleQuote": true,
  "jsxSingleQuote": true,
  "printWidth": 120
}

================
File: .stylelintrc.json
================
{
  "extends": ["stylelint-config-standard"],
  "plugins": ["stylelint-order"],
  "rules": {
    "selector-class-pattern": [
      "^[a-zA-Z0-9_-]+$",
      {
        "message": "Class names should use kebab-case or snake_case",
        "severity": "warning"
      }
    ],

    "font-family-no-missing-generic-family-keyword": null,

    "declaration-property-value-no-unknown": [
      true,
      {
        "ignoreProperties": {
          "justify-self": ["anchor-center"]
        }
      }
    ]
  }
}

================
File: dist-tcm/styles/components/companion.module.css.d.ts
================
declare const styles: {
  readonly "companion": string;
  readonly "fluffy": string;
  readonly "giggle": string;
  readonly "quote": string;
  readonly "quote_box": string;
  readonly "quote_box_container": string;
  readonly "root": string;
  readonly "wrapper": string;
};
export = styles;

================
File: dist-tcm/styles/reset.css.d.ts
================
export {};

================
File: src/components/common/PixelLineChart.tsx
================
import { Component, createSignal, onCleanup, onMount } from 'solid-js';

interface PixelLineChartProps {
  /** 横ピクセル数＝バッファ長 */
  width: number;
  /** 縦ピクセル数 */
  height: number;
  /** 新しいサンプルを返す非同期関数 */
  fetchSample: () => Promise<number | undefined>;
  /** ミリ秒 */
  interval?: number;
  /** 線の色 */
  color?: string;
  suffix?: string;
  initialMaxValue?: number;
}

export const PixelLineChart: Component<PixelLineChartProps> = (props) => {
  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  // width ピクセル分のバッファをゼロ埋め
  const buffer: number[] = Array(props.width).fill(0);
  const [lastBuffer, setLastBuffer] = createSignal<number | undefined>(-1);
  const [maxValue, setMaxValue] = createSignal(1);

  onMount(() => {
    ctx = canvas.getContext('2d')!;
    // ピクセルパーフェクトを狙うなら、実際の canvas.width/height と CSSサイズを同じに
    canvas.width = props.width;
    canvas.height = props.height;

    // 描画関数：バッファ全部を１ドットずつ打っていく
    const draw = () => {
      // クリア
      ctx.clearRect(0, 0, props.width, props.height);
      ctx.fillStyle = props.color || 'lime';

      for (let x = 0; x < buffer.length; x++) {
        // 0〜maxValue を 0〜(height-1) に丸め込む
        const q = Math.round((buffer[x] / maxValue()) * (props.height - 1));
        // 底辺を y=height-1 として上向きに描画
        const y = props.height - 1 - q;
        ctx.fillRect(x, y, 1, 1);
      }
    };

    // 定期取得＋描画ループ
    const iv = setInterval(async () => {
      try {
        const v = await props.fetchSample();
        buffer.shift();
        buffer.push(v ?? 0);
        setLastBuffer(v ? Math.round(v * 10) / 10 : undefined);
        // バッファ全体の現在最大値を取得し、1.5倍してスケール更新
        const bufMax = Math.max(...buffer);
        // 0除算防止 & 少なくとも initialMaxValue 以上にはする
        const newMax = Math.max(bufMax * 1.5, props.initialMaxValue ?? 0);
        setMaxValue(Math.round(newMax * 10) / 10);
        draw();
      } catch {
        // 無視
      }
    }, props.interval ?? 1000);

    // マウント解除時に止める
    onCleanup(() => clearInterval(iv));
  });

  return (
    <div
      style={{
        position: 'relative',
        width: `${props.width}px`,
        height: `${props.height}px`,
        background: '#00000017',
        border: '1px solid #aaa',
      }}
    >
      <canvas
        ref={(el) => (canvas = el)}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          // 拡大時にもドットがにじまないように
          'image-rendering': 'pixelated',
          // 必要なら表示を大きくする
          width: `${props.width}px`,
          height: `${props.height}px`,
        }}
      />
      <p style={{ position: 'absolute', top: '0px', left: '4px' }}>{maxValue()}</p>
      <p style={{ position: 'absolute', bottom: '0px', left: '4px' }}>{0}</p>
      <p style={{ position: 'absolute', top: '0px', right: '4px' }}>
        {lastBuffer()} {props.suffix}
      </p>
    </div>
  );
};

================
File: src/components/global/EdgeInfo.tsx
================
import { Component } from 'solid-js';
import { loadGlobalSettings } from '~/io/global_config/globalSettings';
import { SettingsWindowOptions } from '~/routes/settings';

import { edgeInfoItem, edgeInfoRoot, edgeInfoText } from '~/styles/components/globals/edge_info.css';
import { openSingletonWindow } from '~/utils/windowUtils';

const EdgeInfo: Component = () => {
  return (
    <div class={edgeInfoRoot}>
      <div class={edgeInfoItem}>
        <a
          class={edgeInfoText}
          onClick={async () => {
            let win = await openSingletonWindow('settings', SettingsWindowOptions);
            win.once('tauri://destroyed', (e) => {
              loadGlobalSettings();
            });
          }}
        >
          settings.
        </a>
      </div>
      {/* <p class={sideAreaEdgeText}>{projectStore.name || "name N/A"}</p> */}
    </div>
  );
};

export default EdgeInfo;

================
File: src/controllers/layer_list/LayerListController.ts
================
import { layerHistoryStore, layerListStore, setLayerHistoryStore, setLayerListStore } from '~/stores/ProjectStores';
import { LayerType } from '~/types/Layer';
import { DSL } from '../../models/dsl/DSL';
import { createLayer } from '../layer/LayerFactory';

export const addLayer = async (
  name: string,
  type: LayerType = LayerType.Dot,
  enabled = true,
  dotMagnification = 1,
  dsl?: DSL
) => {
  const newLayer = createLayer(name, type, enabled, dotMagnification, dsl);

  const layers = [...allLayers()];
  layers.push(newLayer);

  setLayerListStore('layers', layers);
  setLayerListStore('activeLayerId', newLayer.id);

  return layers;
};

export const removeLayer = (layerId?: string) => {
  if (layerId === undefined) return;
  const layers = [...allLayers()];
  if (layers.length <= 1) return;
  const index = layers.findIndex((l) => l.id === layerId);
  let newActiveIndex = 0;
  if (index !== 0) newActiveIndex = index - 1;

  layers.splice(index, 1);
  const histories = Object.assign({}, layerHistoryStore);
  delete histories[layerId];

  setLayerListStore('layers', layers);
  setLayerListStore('activeLayerId', layers[newActiveIndex].id);
  setLayerHistoryStore(histories);
};

export const allLayers = () => layerListStore.layers;
export const findLayerById = (id: string) => allLayers().find((layer) => layer.id === id);
export const activeLayer = () => findLayerById(layerListStore.activeLayerId) || allLayers()[0] || undefined;
export const activeIndex = () => allLayers().findIndex((layer) => layer.id === layerListStore.activeLayerId);

================
File: src/models/tool/fill/TileFloodFill.ts
================
import { PixelDiff } from '~/models/layer_image/HistoryManager';
import TileLayerImageAgent from '~/models/layer_image/agents/TileLayerImageAgent';
import { TileIndex } from '~/types/Tile';
import { Vec2 } from '~/types/Vector';
import { colorMatch } from '~/utils/ColorUtils';
import { Fill, FillProps } from './FillTool';

interface FillPassProps {
  index: TileIndex;
}

export class TileFloodFill implements Fill {
  fill({ agent, color, position }: FillProps) {
    if (!(agent instanceof TileLayerImageAgent)) throw 'Agent is not a TileLayerImageAgent';
    const tileAgent = agent as TileLayerImageAgent;

    const targetColor = tileAgent.getPixel(position);
    if (colorMatch(targetColor, color)) return false;

    const tileRowCount = tileAgent.getTileRowCount();
    const tileColumnCount = tileAgent.getTileColumnCount();
    const flatten = (ti: TileIndex) => ti.row * tileColumnCount + ti.column;
    const tileUniformMatches = (ti: TileIndex) => {
      const tile = tileAgent.getTile(ti);
      return tile.isUniform && tile.uniformColor && colorMatch(tile.uniformColor, targetColor);
    };

    const visitedTiles = new Uint8Array(tileRowCount * tileColumnCount);
    const tilesFilled: TileIndex[] = [];
    const tileQueue: TileIndex[] = [tileAgent.getTileIndex(position)];

    const pxDiffs: PixelDiff[] = [];
    const visitedPx = new Uint8Array(agent.getWidth() * agent.getHeight());

    // First tile flood pass
    let tileFillCount = 0;
    while (tileQueue.length > 0) {
      const ti = tileQueue.pop()!;
      if (!tileAgent.isTileInBounds(ti)) continue;
      const i = flatten(ti);
      if (visitedTiles[i]) continue;
      visitedTiles[i] = 1;
      if (!tileUniformMatches(ti)) continue;

      tilesFilled.push(ti);
      tileFillCount++;
      tileQueue.push({ row: ti.row - 1, column: ti.column });
      tileQueue.push({ row: ti.row + 1, column: ti.column });
      tileQueue.push({ row: ti.row, column: ti.column - 1 });
      tileQueue.push({ row: ti.row, column: ti.column + 1 });
    }
    for (const ti of tilesFilled) {
      const offset = tileAgent.getTile(ti).getOffset();
      for (let dy = 0; dy < tileAgent.TILE_SIZE; dy++) {
        for (let dx = 0; dx < tileAgent.TILE_SIZE; dx++) {
          const x = offset.x + dx;
          const y = offset.y + dy;
          const i = y * agent.getWidth() + x;
          visitedPx[i] = 1;
        }
      }
    }
    console.log(`initial tile fill finished: ${tileFillCount} tiles`);

    const edgePixels = tilesFilled.length > 0 ? this.collectEdgePixels(tileAgent, tilesFilled) : [position];

    const pixelQueue: Vec2[] = edgePixels;
    const pixelsFilled: Vec2[] = [];
    const pxIndex = (p: Vec2) => p.y * agent.getWidth() + p.x;

    let pixelFillCount = 0;
    while (pixelQueue.length > 0) {
      const p = pixelQueue.pop()!;
      if (!agent.isInBounds(p)) continue;
      const idx = pxIndex(p);
      if (visitedPx[idx]) continue;
      visitedPx[idx] = 1;

      const tileIndex = tileAgent.getTileIndex(p);
      const tileIdxFlat = flatten(tileIndex);
      const tilesFilledInReEntry: TileIndex[] = [];
      if (!visitedTiles[tileIdxFlat] && tileUniformMatches(tileIndex)) {
        const reentryQueue: TileIndex[] = [tileIndex];
        let reentryCount = 0;
        while (reentryQueue.length > 0) {
          const ti = reentryQueue.pop()!;
          if (!tileAgent.isTileInBounds(ti)) continue;
          const i = flatten(ti);
          if (visitedTiles[i]) continue;
          visitedTiles[i] = 1;
          if (!tileUniformMatches(ti)) continue;
          tilesFilled.push(ti);
          tilesFilledInReEntry.push(ti);
          reentryCount++;
          reentryQueue.push({ row: ti.row - 1, column: ti.column });
          reentryQueue.push({ row: ti.row + 1, column: ti.column });
          reentryQueue.push({ row: ti.row, column: ti.column - 1 });
          reentryQueue.push({ row: ti.row, column: ti.column + 1 });
        }
        // ↓ 前はこれがなかった ↓
        const newEdges = this.collectEdgePixels(tileAgent, tilesFilledInReEntry);
        for (const edge of newEdges) {
          pixelQueue.push(edge);
        }
        for (const ti of tilesFilled) {
          const offset = tileAgent.getTile(ti).getOffset();
          for (let dy = 0; dy < tileAgent.TILE_SIZE; dy++) {
            for (let dx = 0; dx < tileAgent.TILE_SIZE; dx++) {
              const x = offset.x + dx;
              const y = offset.y + dy;
              const i = y * agent.getWidth() + x;
              visitedPx[i] = 1;
            }
          }
        }
        console.log(`tile reentry fill: ${reentryCount} tiles`);
        continue;
      }

      if (!colorMatch(tileAgent.getPixel(p), targetColor)) continue;
      pixelsFilled.push(p);
      pixelFillCount++;
      pixelQueue.push({ x: p.x + 1, y: p.y });
      pixelQueue.push({ x: p.x - 1, y: p.y });
      pixelQueue.push({ x: p.x, y: p.y + 1 });
      pixelQueue.push({ x: p.x, y: p.y - 1 });
    }
    console.log(`pixel fill finished: ${pixelFillCount} pixels`);

    for (const ti of tilesFilled) tileAgent.fillWholeTile(ti, color, true);
    for (const p of pixelsFilled) {
      const diff = tileAgent.setPixel(p, color, false, false);
      if (diff) pxDiffs.push(diff);
    }

    if (pxDiffs.length > 0) tileAgent.addDiffs(pxDiffs);
  }

  collectEdgePixels(agent: TileLayerImageAgent, filled: TileIndex[]): Vec2[] {
    const edge: Vec2[] = [];
    const TILE_SIZE = agent.TILE_SIZE;
    const filledSet = new Set(filled.map((t) => `${t.row},${t.column}`));

    for (const ti of filled) {
      const offset = agent.getTile(ti).getOffset();
      const neighbors = [
        { dr: -1, dc: 0, dx: 0, dy: -1, axis: 'x' },
        { dr: 1, dc: 0, dx: 0, dy: TILE_SIZE, axis: 'x' },
        { dr: 0, dc: -1, dx: -1, dy: 0, axis: 'y' },
        { dr: 0, dc: 1, dx: TILE_SIZE, dy: 0, axis: 'y' },
      ];

      for (const { dr, dc, dx, dy, axis } of neighbors) {
        const ni = `${ti.row + dr},${ti.column + dc}`;
        if (filledSet.has(ni)) continue;
        for (let i = 0; i < TILE_SIZE; i++) {
          const x = axis === 'x' ? offset.x + i : offset.x + dx;
          const y = axis === 'y' ? offset.y + i : offset.y + dy;
          edge.push({ x, y });
        }
      }
    }
    return edge;
  }
}

================
File: src/models/tool/pen/PenTool.ts
================
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';
import { drawCompletionLine, drawSquarePixel } from '../../../utils/DrawUtils';
import { Tool, ToolArgs } from '../ToolBase';

export class PenTool implements Tool {
  onStart(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }

  onMove(agent: LayerImageAgent, { position, lastPosition, color, size }: ToolArgs) {
    if (!size) return false;

    drawSquarePixel(position, size, (px, py) => {
      const diff = agent.setPixel({ x: px, y: py }, color, true, true);
      if (diff !== undefined) {
        agent.addDiffs([diff]);
      }
    });

    if (lastPosition !== undefined) {
      drawCompletionLine(position, lastPosition, (x, y) => {
        drawSquarePixel({ x, y }, size, (px, py) => {
          const diff = agent.setPixel({ x: px, y: py }, color, true, true);
          if (diff !== undefined) {
            agent.addDiffs([diff]);
          }
        });
      });
    }

    return true;
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false;
  }
}

================
File: src/models/tool/ToolBase.ts
================
import { RGBAColor } from '~/utils/ColorUtils';
import { ToolType } from '../../types/Tool';
import { Vec2 } from '../../types/Vector';
import LayerImageAgent from '../layer_image/LayerImageAgent';
import { EraserTool } from './eraser/EraserTool';
import { FillTool } from './fill/FillTool';
import { PenTool } from './pen/PenTool';

export interface Tool {
  onStart: (agent: LayerImageAgent, args: ToolArgs) => boolean;

  onMove: (agent: LayerImageAgent, args: ToolArgs) => boolean;

  onEnd: (agent: LayerImageAgent, args: ToolArgs) => boolean;
}

export interface ToolArgs {
  position: Vec2;
  lastPosition?: Vec2;
  color: RGBAColor; // RGBA
  size?: number;
  // TODO: pressure, tilt, ...
}

export const getToolInstance = (toolType: ToolType) => {
  switch (toolType) {
    case ToolType.Pen:
      return new PenTool();
    case ToolType.Eraser:
      return new EraserTool();
    case ToolType.Fill:
      return new FillTool();

    default:
      return new PenTool();
  }
};

================
File: src/routes/settings/settings.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';
import { flexCol } from '~/styles/snippets.css';

export const settingContainer = style([
  flexCol,
  {
    padding: vars.spacing.lg,
    gap: vars.spacing.lg,
  },
]);

================
File: src/styles/components/canvas/layer_canvas.css.ts
================
import { style } from '@vanilla-extract/css';

export const layerCanvas = style({});

================
File: src/styles/section/canvas.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';
import { flexRow } from '../snippets.css';

export const canvasSizeForm = style([
  flexRow,
  {
    alignItems: 'flex-end',
    marginBottom: '6px',
  },
]);

export const canvasSizeLabel = style({
  fontSize: vars.text.sm,
});

export const canvasSizeInput = style({
  fontSize: vars.text.md,
  margin: `${vars.spacing.xs}`,
  width: '50px',
});

export const canvasSizeButton = style({
  margin: vars.spacing.sm,
});

================
File: src/styles/section/color.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars, ZFB03 } from '../global.css';
import { flexCol } from '../snippets.css';

export const swatchContainer = style([
  flexCol,
  {
    position: 'relative',
    gap: vars.spacing.xs,
    marginRight: vars.spacing.md,
  },
]);

export const descriptionContainer = style([
  flexCol,
  {
    justifyContent: 'end',
    marginBottom: vars.spacing.sm,
  },
]);

export const colorElemDescription = style({
  color: vars.color.muted,
  fontFamily: ZFB03,
  fontSize: vars.text.sm,
  transform: 'rotate(180deg)',
  whiteSpace: 'nowrap',
  writingMode: 'vertical-rl',
});

export const colorContent = style([
  flexCol,
  {
    marginLeft: vars.spacing.sm,
  },
]);

================
File: src/styles/section/project.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';

export const projectNameInput = style({
  border: 'none',
  fontSize: vars.text.xl,
  marginBottom: vars.spacing.sm,
  marginLeft: '-2px',
  outline: 'none',

  '::placeholder': {
    opacity: 0.5,
  },
});

export const saveLog = style({
  color: 'limegreen',
  marginLeft: vars.spacing.sm,
});

================
File: src/types/Tile.ts
================
import { RGBAColor } from '~/utils/ColorUtils';
import { Vec2 } from './Vector';

export interface TileIndex {
  row: number;
  column: number;
}

export default class Tile {
  // 一連の動作全体で変更があったか（累計表示、UI表示用）
  public isDirtyThroughAction: boolean;
  // 前回の描画更新から変更があったか（canvas更新用）
  public isDirty: boolean;

  // このタイルが単色（すべて同一RGBA）なら true
  public isUniform = false;
  // 単色時のカラーキャッシュ
  public uniformColor: RGBAColor | undefined = undefined;

  constructor(
    public readonly row: number,
    public readonly column: number,
    public readonly globalTileSize: number
  ) {
    this.isDirtyThroughAction = false;
    this.isDirty = false;
  }

  toString(): string {
    return `Tile[${this.row},${this.column}]`;
  }

  public getOffset(): Vec2 {
    return {
      x: this.column * this.globalTileSize,
      y: this.row * this.globalTileSize,
    };
  }

  public isInBounds(positionInTile: Vec2) {
    return (
      positionInTile.x >= 0 &&
      positionInTile.x < this.globalTileSize &&
      positionInTile.y >= 0 &&
      positionInTile.y < this.globalTileSize
    );
  }

  updateState() {}
}

================
File: src/components/section/settings/PerformanceSettings.tsx
================
import { Component } from 'solid-js';
import Checkbox from '~/components/common/basics/Checkbox';
import { globalStore, setGlobalStore } from '~/stores/GlobalStores';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/components/globals/section_global.css';

const PerformanceSettings: Component = () => {
  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>performance.</p>
      <div class={sectionContent} style={{ gap: '8px' }}>
        <Checkbox
          label='show dirtyrects.'
          checked={globalStore.showDirtyRects}
          onChange={(e) => setGlobalStore('showDirtyRects', e)}
        />
        <Checkbox
          label='performance monitor.'
          checked={globalStore.showPerfMonitor}
          onChange={(e) => setGlobalStore('showPerfMonitor', e)}
        />
      </div>
    </div>
  );
};

export default PerformanceSettings;

================
File: src/controllers/canvas/CanvasController.ts
================
import { interactStore, setInteractStore } from '~/stores/EditorStores';
import { canvasStore, setCanvasStore } from '~/stores/ProjectStores';
import { Size2D } from '~/types/Size';
import { Consts } from '~/utils/consts';
import { resetLayerImage } from '../layer/LayerController';
import { allLayers } from '../layer_list/LayerListController';

export function changeCanvasSize(newSize: Size2D): boolean {
  if (newSize.width < Consts.minCanvasWidth || Consts.maxCanvasWidth < newSize.width) return false;
  if (newSize.height < Consts.minCanvasHeight || Consts.maxCanvasHeight < newSize.height) return false;

  setCanvasStore('canvas', newSize);
  allLayers().forEach((layer) => {
    resetLayerImage(layer.id, layer.dotMagnification);
  });
  return true;
}

const REFERENCE_LENGTH = 600;

export const getReferencedZoom = (length?: number) => {
  if (length === undefined) {
    const width = canvasStore.canvas.width;
    const height = canvasStore.canvas.height;
    length = width > height ? width : height;
    if (!length) return undefined;
  }

  return REFERENCE_LENGTH / length;
};

export const adjustZoomToFit = (width?: number, height?: number) => {
  if (width === undefined) width = canvasStore.canvas.width;
  if (height === undefined) height = canvasStore.canvas.height;
  if (!width || !height) return;

  const isWide = width > height;
  const longerLength = isWide ? width : height;

  const referencedZoom = getReferencedZoom(longerLength);
  if (!referencedZoom) return;
  setInteractStore('zoom', referencedZoom);
  centeringCanvas();
};

export const centeringCanvas = () => {
  const canvasSize = canvasStore.canvas;
  const canvasArea = interactStore.canvasAreaSize;
  const zoom = interactStore.zoom;

  setInteractStore('offsetOrigin', {
    x: canvasArea.width / 2 - (canvasSize.width * zoom) / 2,
    y: canvasArea.height / 2 - (canvasSize.height * zoom) / 2,
  });
  setInteractStore('offset', {
    x: 0,
    y: 0,
  });
};

================
File: src/models/layer_image/LayerImageManager.ts
================
import { HistoryManager } from './HistoryManager';
import LayerImageAgent from './LayerImageAgent';
import TileLayerImageAgent from './agents/TileLayerImageAgent';

export class LayerImageManager {
  private agents: Map<string, LayerImageAgent> = new Map();

  public getAgent(layerId: string): LayerImageAgent | undefined {
    return this.agents.get(layerId);
  }

  public registerAgent(layerId: string, image: ImageData): LayerImageAgent {
    const agent = new TileLayerImageAgent(image, new HistoryManager(layerId));
    this.agents.set(layerId, agent);
    return agent;
  }
}

================
File: src/routes/[...404].tsx
================
import { Title } from '@solidjs/meta';

export default function NotFound() {
  return (
    <main>
      <Title>Not Found</Title>
      <h1>Page Not Found</h1>
      <p>
        Visit{' '}
        <a href='https://start.solidjs.com' target='_blank'>
          start.solidjs.com
        </a>{' '}
        to learn how to build SolidStart apps.
      </p>
    </main>
  );
}

================
File: src/stores/GlobalStores.ts
================
import { createStore } from 'solid-js/store';
import { CanvasRenderingMode } from '~/types/Canvas';
import { FileLocation } from '~/types/FileLocation';
import { KeyConfigEntry } from '~/types/KeyConfig';
import { Size2D } from '~/types/Size';

// global
export const getCanvasImageRenderingAttribute = (
  zoom: number,
  mode: CanvasRenderingMode
): 'pixelated' | 'crisp-edges' => {
  switch (mode) {
    case 'pixelated':
      return 'pixelated';
    case 'crispEdges':
      return 'crisp-edges';
    case 'adaptive':
      return zoom > 1.0 ? 'pixelated' : 'crisp-edges';
  }
};

type GlobalConfigStore = {
  maxRecentFiles: number;
  recentFiles: FileLocation[];
  newProjectCanvasSize: Size2D;
  canvasRenderingMode: CanvasRenderingMode;
  showDirtyRects: boolean;
  showPerfMonitor: boolean;
};
type KeyConfigStore = {
  [command: string]: KeyConfigEntry[];
};

const defaultGlobalConfigStore: GlobalConfigStore = {
  maxRecentFiles: 8,
  recentFiles: [],

  newProjectCanvasSize: {
    width: 1000,
    height: 1000,
  },
  canvasRenderingMode: 'adaptive' as CanvasRenderingMode,

  showDirtyRects: false,
  showPerfMonitor: false,
};
const KEY_CONFIG_TEMPLATE: Readonly<KeyConfigStore> = {
  undo: [{ ctrl: true, key: 'z' }],
  redo: [{ ctrl: true, key: 'y' }],
  pen: [{ key: 'p' }],
  eraser: [{ key: 'e' }],
  fill: [{ key: 'f' }],
} as const;
export const makeDefaultKeyConfigStore = (): KeyConfigStore => structuredClone(KEY_CONFIG_TEMPLATE);

const initGlobalStore = () => {
  const [globalConfigStore, setGlobalConfigStore] = createStore(defaultGlobalConfigStore);
  const [keyConfigStore, setKeyConfigStore] = createStore(makeDefaultKeyConfigStore());

  return { globalConfigStore, setGlobalConfigStore, keyConfigStore, setKeyConfigStore };
};

let globalRootStore = initGlobalStore();

export const getGlobalRootStore = () => globalRootStore;

export const globalStore = globalRootStore.globalConfigStore;
export const setGlobalStore = globalRootStore.setGlobalConfigStore;

export const keyConfigStore = globalRootStore.keyConfigStore;
export const setKeyConfigStore = globalRootStore.setKeyConfigStore;

export const loadGlobalStore = (store: { globalConfigStore: GlobalConfigStore; keyConfigStore: KeyConfigStore }) => {
  setGlobalStore(store.globalConfigStore);
  setKeyConfigStore(store.keyConfigStore);
};

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "allowJs": true,
    "strict": true,
    "noEmit": true,
    "isolatedModules": true,
    "paths": {
      "~/*": ["./src/*", "./dist-tcm/*"],
      "@styles/*": ["./src/styles/*", "./dist-tcm/styles/*"]
    },
    "rootDirs": ["src", "dist-tcm"]
  }
}

================
File: src/components/common/Light.tsx
================
import { Component, Show } from 'solid-js';
import { lightInnerOff, lightInnerOn } from '~/styles/components/light.css';

interface LightProps {
  class?: string;
  on?: boolean;
}

const Light: Component<LightProps> = (props: LightProps) => {
  const width = 8;
  const height = 8;
  const radius = 2;

  return (
    <svg
      class={props.class}
      style={{
        width: `${width}px`,
        height: `${height}px`,
        overflow: 'visible',
      }}
      viewBox={`0 0 ${width} ${height}`}
      xmlns='http://www.w3.org/2000/svg'
    >
      <Show when={true}>
        <g class={props.on ? lightInnerOn : lightInnerOff}>
          <circle cx={width / 2} cy={height / 2} r={radius} fill='red' />
        </g>
      </Show>
    </svg>
  );
};

export default Light;

================
File: src/components/section/ToolConfig.tsx
================
import { Component, For } from 'solid-js';
import { toolStore } from '~/stores/EditorStores';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/components/globals/section_global.css';
import ToolItem from './item/ToolItem';

const ToolConfig: Component = () => {
  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>tools.</p>
      <div class={sectionContent}>
        <For each={toolStore.tools}>
          {(item, index) => <ToolItem tool={item} isInUse={index() === toolStore.usingIndex} />}
        </For>
      </div>
    </div>
  );
};

export default ToolConfig;

================
File: src/controllers/layer/LayerController.ts
================
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';
import { layerImageManager } from '~/routes/editor';
import { canvasStore, layerHistoryStore, layerListStore, setLayerHistoryStore } from '~/stores/ProjectStores';

const magnificationList: number[] = [1, 2, 4];

export const getNextMagnification = (dotMagnification: number) => {
  const index = magnificationList.findIndex((m) => m === dotMagnification);
  if (index != -1) {
    // 循環
    const nextIndex = index !== magnificationList.length - 1 ? index + 1 : 0;
    return magnificationList[nextIndex];
  } else return 1;
};

export function resetLayerImage(layerId: string, dotMagnification: number): LayerImageAgent {
  const blank = new ImageData(
    Math.round(canvasStore.canvas.width / dotMagnification),
    Math.round(canvasStore.canvas.height / dotMagnification)
  );
  setLayerHistoryStore(layerId, {
    undoStack: [],
    redoStack: [],
  });
  const agent = layerImageManager.getAgent(layerId);
  if (agent !== undefined) {
    agent.setImage(blank, false);
    return agent;
  } else {
    return layerImageManager.registerAgent(layerId, blank);
  }
}

export const canUndo = (): boolean => layerHistoryStore[layerListStore.activeLayerId]?.undoStack.length > 0;
export const canRedo = (): boolean => layerHistoryStore[layerListStore.activeLayerId]?.redoStack.length > 0;

================
File: src/stores/ProjectStores.ts
================
// projectStore.ts
import { createStore } from 'solid-js/store';
import { resetLayerImage } from '~/controllers/layer/LayerController';
import { Layer } from '~/types/Layer';
import { LayerHistory } from '~/types/LayerHistory';
import { Size2D } from '~/types/Size';
import { decodeImageData } from '~/utils/ImageUtils';

type CanvasStore = {
  canvas: Size2D;
};
type ProjectStore = {
  newName: string | undefined;
  name: string | undefined;
  path: string | undefined;
  isProjectChangedAfterSave: boolean;
};
type LayerHistoryStore = Record<string, LayerHistory>;
type LayerListStore = {
  layers: Layer[];
  activeLayerId: string;
};

const defaultProjectStore: ProjectStore = {
  newName: undefined as string | undefined,
  name: undefined as string | undefined,
  path: undefined as string | undefined,
  isProjectChangedAfterSave: false,
};
const defaultCanvasStore: CanvasStore = {
  canvas: {
    width: 400,
    height: 400,
  },
};
const defaultLayerHistoryStore: LayerHistoryStore = {};
const defaultLayerListStore: LayerListStore = {
  layers: new Array<Layer>(),
  activeLayerId: '',
};

export const initProjectStore = () => {
  const [canvasStore, setCanvasStore] = createStore<CanvasStore>(defaultCanvasStore);
  const [projectStore, setProjectStore] = createStore<ProjectStore>(defaultProjectStore);
  const [layerHistoryStore, setLayerHistoryStore] = createStore<LayerHistoryStore>(defaultLayerHistoryStore);
  const [layerListStore, setLayerListStore] = createStore<LayerListStore>(defaultLayerListStore);

  return {
    canvasStore,
    setCanvasStore,
    layerListStore,
    setLayerListStore,
    layerHistoryStore,
    setLayerHistoryStore,
    projectStore,
    setProjectStore,
  };
};

const projectRootStore = initProjectStore();

export const canvasStore = projectRootStore.canvasStore;
export const setCanvasStore = projectRootStore.setCanvasStore;

export const layerListStore = projectRootStore.layerListStore;
export const setLayerListStore = projectRootStore.setLayerListStore;

export const layerHistoryStore = projectRootStore.layerHistoryStore;
export const setLayerHistoryStore = projectRootStore.setLayerHistoryStore;

export const projectStore = projectRootStore.projectStore;
export const setProjectStore = projectRootStore.setProjectStore;

export const loadStoreFromProjectJson = async (projectJson: any) => {
  if (projectJson.project) {
    console.log(projectJson.project);
    setProjectStore('name', projectJson.project.name || undefined);
    setProjectStore('path', projectJson.project.path || undefined);
  }

  if (projectJson.canvas) {
    const { width, height } = projectJson.canvas;
    setCanvasStore('canvas', 'width', width);
    setCanvasStore('canvas', 'height', height);
  }

  if (projectJson.images) {
    setLayerHistoryStore({});
    Object.keys(projectJson.images).forEach((id) => {
      const imageData = projectJson.images[id];
      const agent = resetLayerImage(id, Number(imageData.dotMagnification || 1));
      const image = decodeImageData(imageData.current, Number(imageData.width), Number(imageData.height));
      agent.setImage(image);
    });
  }

  if (projectJson.layer && projectJson.layer.layers && Array.isArray(projectJson.layer.layers)) {
    const layers: Layer[] = [];
    projectJson.layer.layers.map((l: any) => {
      layers.push({
        ...l,
        dsl: undefined,
      } as Layer);
    });

    setLayerListStore('layers', layers);
    setLayerListStore('activeLayerId', projectJson.layer.activeLayerId);
  }
};

================
File: src/components/common/companion/QuotePool.ts
================
// import { smartSay } from './Companion';

type QuoteCategory = 'color-pick' | 'pen-resize' | 'canvas-resize' | 'undo-spam' | 'random';

const lastSaidIndexes = {
  'color-pick': -1,
  'pen-resize': -1,
  'canvas-resize': -1,
  'undo-spam': -1,
  random: -1,
};
export const quotePool = {
  'color-pick': [
    'That color again? You really love it, huh.',
    'A fine choice, but not the finest.',
    "I see you're going with [color]. Bold.",
  ],
  'pen-resize': [
    'Hmm, Not quite my size.',
    "Go bigger, I'll crash 'em harder.",
    'Have you ever heard of the word "pixel perfect"?',
  ],
  'canvas-resize': ['Shrinking the canvas? Afraid of commitment?', 'Small canvas, big ideas. I like it.'],
  'undo-spam': ['UNDO UNDO UNDO—are you OK?', "That's the 5th undo. I’m getting dizzy."],
  random: ['Daisy, Daisy, give me your answer do do do'],
};

export const sayRandomQuote = (category: QuoteCategory, context?: any) => {
  const quotes = quotePool[category];
  let index = Math.floor(Math.random() * quotes.length);
  // 前になんか言った
  if (lastSaidIndexes[category] != -1) {
    console.log(`I previously said ${lastSaidIndexes[category]}. try saying something new.`);
    if (quotes.length == 1) {
      console.log(`argh. nothing to say.`);
      // もう言えることない
      return '';
    } else {
      // console.log(`how about this?. ${index}`);
      // あるなら抽選続ける
      while (index === lastSaidIndexes[category]) {
        index = Math.floor(Math.random() * quotes.length);
        // console.log(`NO. how about this?. ${index}`);
      }
      console.log(`yeah. ${index} is a brand new. let's say it.`);
    }
  }
  let quote = quotes[index];
  quote = context?.color ? quote.replace('[color]', context.color) : quote;
  // if (smartSay(quote)) {
  //   console.log(`◯ yay!`);
  //   lastSaidIndexes[category] = index;
  // } else {
  //   console.log(`✕ hmm maybe I'd keep silence now?`);
  // }
};

================
File: src/components/section/item/Palette.tsx
================
import { Component } from 'solid-js';
import ColorBox from '~/components/common/ColorBox';
import { selectPalette } from '~/controllers/color/ColorController';
import { colorStore } from '~/stores/EditorStores';
import { paletteRoot } from '~/styles/components/palette.css';
import { PaletteType } from '~/types/PaletteType';

const Palette: Component = () => {
  return (
    <div class={paletteRoot}>
      <ColorBox
        color={colorStore.primary}
        sizePx={24}
        onClick={(color) => selectPalette(PaletteType.primary)}
        enableUsingSelection={colorStore.currentPalette === PaletteType.primary}
      />
      <ColorBox
        color={colorStore.secondary}
        sizePx={24}
        onClick={(color) => selectPalette(PaletteType.secondary)}
        enableUsingSelection={colorStore.currentPalette === PaletteType.secondary}
      />
    </div>
  );
};

export default Palette;

================
File: src/main.tsx
================
import { render } from 'solid-js/web';
import App from './app';
import './styles/global.css';
import './styles/reset.css';

render(() => <App />, document.getElementById('root')!);

================
File: src/styles/reset.css.ts
================
import { globalStyle } from '@vanilla-extract/css';

globalStyle('html, body', {
  height: '100vh',
  width: '100vw',
  margin: 0,
  overflow: 'hidden',
  padding: 0,
  touchAction: 'none',
  display: 'flex',
  flexDirection: 'row',
  userSelect: 'none',
});

globalStyle('main', {
  height: '100%',
  width: '100vw',
  userSelect: 'none',
});

globalStyle('p, a, label', {
  fontSize: '0.5rem',
  letterSpacing: '1px',
  margin: 0,
});

globalStyle('ul', {
  listStyle: 'none',
  paddingLeft: 0,
});

globalStyle('a', {
  cursor: 'pointer',
});

globalStyle('input', {
  border: 'none',
  outline: 'none',
  borderBottom: '1px solid black',
  fontSize: '0.5rem',
});

globalStyle('input::-webkit-outer-spin-button, input::-webkit-inner-spin-button', {
  appearance: 'none',
  margin: 0,
});

================
File: src/styles/section/layer.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars, ZFB03B } from '../global.css';
import { flexCol, flexRow, w100 } from '../snippets.css';

export const layerList = style([
  flexCol,
  w100,
  {
    flexGrow: 1,
    position: 'relative',
    gap: vars.spacing.xs,
    // border: '1px solid #333',
  },
]);

export const layerItem = style([
  flexRow,
  w100,
  {
    height: '36px',
    flexGrow: 1,
    cursor: 'pointer',
    backgroundColor: vars.color.surface,
    borderLeft: '3px solid #333',

    ':hover': {
      filter: 'brightness(0.94)',
    },
    ':active': {
      transform: 'translate(0, 1px)',
    },
  },
]);

export const layerItemDisabled = style({
  opacity: 0.3,
});

export const layerItemIndex = style([
  {
    flexGrow: 1,
    fontSize: vars.text.sm,
  },
]);

export const layerItemType = style({
  whiteSpace: 'nowrap',
  fontSize: vars.text.sm,
  opacity: 0.4,
});

export const layerItemName = style([
  {
    fontSize: vars.text.xl,
    fontFamily: ZFB03B,
    margin: `${vars.spacing.md} 0 0 ${vars.spacing.lg}`,
  },
]);

export const dotMagnifContainer = style([
  {
    alignSelf: 'center',
    // border: '1px black solid',
    // borderRadius: vars.spacing.xs,
    cursor: 'pointer',
    marginTop: vars.spacing.sm,
    marginLeft: 'auto',
    marginRight: 0,
    padding: `2px ${vars.spacing.xs}`,
    pointerEvents: 'all',

    ':hover': {
      color: vars.color.muted,
    },
  },
]);

export const dotMagnifText = style([
  {
    fontFamily: ZFB03B,
    fontSize: vars.text.lg,
  },
]);

export const activeLight = style([
  {
    alignSelf: 'center',
    margin: `${vars.spacing.sm}px 0`,
    marginLeft: vars.spacing.sm,
    marginRight: vars.spacing.md,
  },
]);

export const dropPlaceholder = style([
  {
    border: '2px dashed #aaa',
    borderRadius: vars.spacing.md,
    height: '32px',
    margin: `${vars.spacing.xs}px 0`,
  },
]);

================
File: src/styles/section/pen.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '../global.css';
import { flexRow, w100 } from '../snippets.css';

export const toolConfigRow = style([
  flexRow,
  w100,
  {
    gap: vars.spacing.md,
    alignItems: 'center',
  },
]);
export const toolConfigRowClickable = style([
  flexRow,
  {
    gap: vars.spacing.md,
    alignItems: 'center',
    width: '35%',
  },
]);

export const toolConfigRowName = style({
  cursor: 'pointer',
  fontSize: vars.text.sm,
  padding: `${vars.spacing.md} 0`,
  pointerEvents: 'all',
});

export const toolConfigRowIcon = style({
  ':hover': {
    filter: 'invert(11%) sepia(92%) saturate(7351%) hue-rotate(0deg) brightness(99%) contrast(109%);', // 赤っぽく
  },
});

================
File: src/utils/ImageUtils.ts
================
export function encodeImageData(imageData: ImageData): string {
  const bytes = new Uint8Array(imageData.data.buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary); // Base64 encode
}

export function decodeImageData(encoded: string, width: number, height: number): ImageData {
  const binary = atob(encoded);
  const buffer = new Uint8ClampedArray(binary.length);
  for (let i = 0; i < binary.length; i++) {
    buffer[i] = binary.charCodeAt(i);
  }
  return new ImageData(buffer, width, height);
}

================
File: src/components/section/item/ColorPicker.tsx
================
import iro from '@jaames/iro';
import { IroColorPicker } from '@jaames/iro/dist/ColorPicker';
import { Component, createEffect } from 'solid-js';
import { currentColor, setCurrentColor } from '~/controllers/color/ColorController';

const ColorPicker: Component<{ width: number }> = (props) => {
  let colorPicker: IroColorPicker;

  createEffect(() => {
    colorPicker.setColors([currentColor()]);
  });

  return (
    <div
      ref={(el) => {
        colorPicker = iro.ColorPicker(el, {
          width: props.width,
          padding: 0,
          color: currentColor(),
          handleRadius: 4,
          layoutDirection: 'horizontal',
          layout: [
            {
              component: iro.ui.Box,
              options: {},
            },
            {
              component: iro.ui.Slider,
              options: {
                // can also be 'saturation', 'value', 'red', 'green', 'blue', 'alpha' or 'kelvin'
                sliderType: 'hue',
              },
            },
          ],
        });
        colorPicker.on('color:change', function (color: any) {
          setCurrentColor(color.hexString);
        });
      }}
    />
  );
};

export default ColorPicker;

================
File: src/styles/components/canvas/canvas_area.css.ts
================
import { style } from '@vanilla-extract/css';
import { vars } from '~/styles/global.css';
import { flexCol } from '../../snippets.css';

export const canvasArea = style([
  flexCol,
  {
    backgroundColor: vars.color.bg_canvas_area,
    display: 'flex',
    position: 'relative',
    height: '100%',
    overflow: 'hidden',
  },
]);

================
File: src-tauri/capabilities/default.json
================
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "enables the default permissions",
  "windows": ["start", "editor", "about", "settings"],
  "permissions": [
    "core:default",
    "dialog:default",
    "fs:default",

    "system-info:allow-all",

    "dialog:allow-save",
    "dialog:allow-open",

    "shell:allow-open",

    "fs:allow-open",
    "fs:allow-write",
    "fs:allow-read",
    "fs:allow-rename",
    "fs:allow-mkdir",
    "fs:allow-remove",
    "fs:allow-write-text-file",
    "fs:allow-read-text-file",
    "fs:read-all",
    {
      "identifier": "fs:scope",
      "allow": [{ "path": "**" }]
    },

    "core:webview:allow-create-webview-window",
    "core:window:allow-destroy",
    "core:window:allow-show",
    "core:window:allow-set-focus",
    "core:window:allow-hide",
    "core:window:allow-minimize",
    "core:window:allow-maximize",
    "core:window:allow-close",
    "core:window:allow-toggle-maximize",
    "core:window:allow-start-dragging"
  ]
}

================
File: src/components/canvas/CanvasDebugOverlay.tsx
================
import { makeTimer } from '@solid-primitives/timer';
import { Component, createSignal, Show } from 'solid-js';
import { interactStore } from '~/stores/EditorStores';
import { globalStore } from '~/stores/GlobalStores';
import {
  canvasDebugOverlayBottomLeft,
  canvasDebugOverlayTopLeft,
} from '~/styles/components/canvas/canvas_debug_overlay.css';
import { flexCol } from '~/styles/snippets.css';
import { safeInvoke } from '~/utils/TauriUtils';
import { PixelLineChart } from '../common/PixelLineChart';

interface TauriMemInfo {
  total_bytes: number;
  main_bytes: number;
  children_bytes: number;
}

const CanvasDebugOverlay: Component = (props) => {
  const toMiB = (bytes?: number): string => {
    if (bytes !== undefined) return (bytes / 1024 / 1024).toFixed(1) + ' MiB';
    else return '- MiB';
  };

  // const zoom = () => canvasStore.zoom;
  const lastMouseWindow = () => interactStore.lastMouseWindow;
  const lastMouseOnCanvas = () => interactStore.lastMouseOnCanvas;
  const [jsMemInfo, setJsMemInfo] = createSignal<any>({});
  const [processMemInfo, setProcessMemInfo] = createSignal<TauriMemInfo>();
  const callback = async () => {
    setJsMemInfo((performance as any).memory);

    const processInfo = await safeInvoke<TauriMemInfo>('get_process_memory');
    if (processInfo) {
      setProcessMemInfo(processInfo);
      // console.log(processInfo);
    }
    // console.log(`MAIN: ${toMiB(processMemInfo()?.main_bytes)}
    // CHILDREN: ${toMiB(processMemInfo()?.children_bytes)}
    // TOTAL: ${toMiB(processMemInfo()?.total_bytes)}
    // JS Heap: ${toMiB(jsMemInfo().usedJSHeapSize)} / ${toMiB(jsMemInfo().totalJSHeapSize)}`);
  };

  const disposeInterval = makeTimer(callback, 1000, setInterval);

  return (
    <>
      <div class={canvasDebugOverlayTopLeft}>
        <div class={flexCol}>
          <p>canvas.</p>
          <p>
            ON WINDOW. ({lastMouseWindow().x}, {lastMouseWindow().y})
          </p>
          <p>
            ON CANVAS. ({Math.round(lastMouseOnCanvas().x)}, {Math.round(lastMouseOnCanvas().y)})
          </p>
          <p>
            offset:({Math.round(interactStore.offset.x)}, {Math.round(interactStore.offset.y)})
          </p>
        </div>
      </div>

      <Show when={globalStore.showPerfMonitor}>
        <div class={canvasDebugOverlayBottomLeft}>
          <div class={flexCol}>
            <p>MAIN: {toMiB(processMemInfo()?.main_bytes)}</p>
            <p>CHILDREN: {toMiB(processMemInfo()?.children_bytes)}</p>
            <p>TOTAL: {toMiB(processMemInfo()?.total_bytes)}</p>
            <PixelLineChart
              width={120}
              height={60}
              color='#00ca00'
              suffix='MiB'
              fetchSample={async () => {
                const processInfo = await safeInvoke<TauriMemInfo>('get_process_memory');
                return processInfo ? processInfo.total_bytes / 1024 / 1024 : undefined;
              }}
              interval={500}
            />
          </div>
          <div class={flexCol}>
            <p>
              JS Heap: {toMiB(jsMemInfo().usedJSHeapSize)} / {toMiB(jsMemInfo().totalJSHeapSize)}
            </p>

            <PixelLineChart
              width={120}
              height={60}
              color='#f44336'
              suffix='MiB'
              fetchSample={async () => (performance as any).memory.usedJSHeapSize / 1024 / 1024}
              interval={500}
            />
          </div>
        </div>
      </Show>
    </>
  );
};

export default CanvasDebugOverlay;

================
File: src/components/section/settings/EditorSettings.tsx
================
import { Component } from 'solid-js';
import { globalStore, setGlobalStore } from '~/stores/GlobalStores';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/components/globals/section_global.css';
import { vars } from '~/styles/global.css';
import { flexRow } from '~/styles/snippets.css';
import { CanvasRenderingMode } from '~/types/Canvas';
import { Consts } from '~/utils/consts';
import Dropdown, { DropdownOption } from '../../common/basics/Dropdown';

const renderingOptions: DropdownOption<CanvasRenderingMode>[] = [
  { label: 'adaptive', value: 'adaptive' },
  { label: 'pixelated', value: 'pixelated' },
  { label: 'crispEdges', value: 'crispEdges' },
];

const EditorSettings: Component = () => {
  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>editor.</p>
      <div class={sectionContent} style={{ gap: '8px' }}>
        <div>
          <p>default canvas size.</p>
          <div class={flexRow} style={{ gap: vars.spacing.xs, 'margin-top': vars.spacing.sm, 'align-items': 'center' }}>
            <input
              type='number'
              name='width'
              min={Consts.minCanvasWidth}
              max={Consts.maxCanvasWidth}
              value={globalStore.newProjectCanvasSize.width}
              onChange={(e) => {
                setGlobalStore('newProjectCanvasSize', 'width', Number(e.target.value));
              }}
              style={{ 'font-size': '10px' }}
              required
            />
            <p>x</p>
            <input
              type='number'
              name='height'
              min={Consts.minCanvasHeight}
              max={Consts.maxCanvasHeight}
              value={globalStore.newProjectCanvasSize.height}
              onChange={(e) => {
                setGlobalStore('newProjectCanvasSize', 'height', Number(e.target.value));
              }}
              style={{ 'font-size': '10px' }}
              required
            />
          </div>
        </div>

        <div>
          <p>autosave span (wip).</p>
          <input type='number' name='width' min={100} max={1000000} required />
        </div>

        <p>canvas rendering (temp not works).</p>
        <Dropdown
          selected={globalStore.canvasRenderingMode}
          value={globalStore.canvasRenderingMode}
          options={renderingOptions}
          onChange={(v) => {
            setGlobalStore('canvasRenderingMode', v);
          }}
        />
      </div>
    </div>
  );
};

export default EditorSettings;

================
File: src/models/dsl/DSLRunner.ts
================
import { decodeImageData, encodeImageData } from '~/utils/ImageUtils';
import { safeInvoke } from '~/utils/TauriUtils';
import { DSL } from './DSL';

export async function runDSL(dsl: DSL, image: ImageData): Promise<ImageData | undefined> {
  const encoded = encodeImageData(image);

  const dslStr = dsl.build(true);
  if (dslStr === undefined) return;

  const result = await safeInvoke<string>('run_pipeline', {
    dsl: dslStr,
    encoded,
    width: image.width,
    height: image.height,
  });

  if (!result) return;
  return decodeImageData(result, image.width, image.height);
}

================
File: src/routes/start.css.ts
================
import { style } from '@vanilla-extract/css';
import { ZFB03B, ZFB09, ZFB31 } from '~/styles/global.css';
import { flexCol, flexRow, w100, wh100 } from '~/styles/snippets.css';

export const welcomeRoot = style([
  flexCol,
  wh100,
  {
    alignItems: 'center',
    justifyContent: 'center',
  },
]);

export const welcomeHeadline = style({
  fontFamily: ZFB31,
  fontSize: '3rem',
  letterSpacing: '8px',
  marginBottom: '12px',
});

export const recentFilesCaption = style({
  fontFamily: ZFB03B,
  fontSize: '16px',
  color: '#000',
  flexGrow: 1,
  marginBottom: '12px',
});

export const clear = style({
  fontFamily: ZFB03B,
  fontSize: '15px',
  ':hover': {
    color: 'red',
  },
});

export const recentFilesContainer = style([
  flexCol,
  w100,
  {
    gap: '8px',
    marginTop: '4px',
  },
]);

export const recentFilesItem = style([
  flexRow,
  w100,
  {
    alignItems: 'center',
    gap: '8px',
  },
]);

export const recentFilesName = style({
  fontFamily: ZFB09,
  fontSize: '0.5rem',
  textOverflow: 'ellipsis',
  color: '#555',
  whiteSpace: 'nowrap',
});

export const recentFilesPath = style({
  fontFamily: ZFB03B,
  fontSize: '0.5rem',
  color: '#00000030',
});

export const sideSection = style([
  flexRow,
  {
    gap: '24px',
    paddingBottom: '48px',
    paddingTop: '12px',
  },
]);

export const sideSectionItem = style([
  flexRow,
  {
    cursor: 'pointer',
    fontSize: '1rem',
    width: 'fit-content',
    alignItems: 'center',
    justifyContent: 'center',
    ':hover': {
      color: 'red',
    },
  },
]);

================
File: src/utils/windowUtils.ts
================
import { WebviewOptions } from '@tauri-apps/api/webview';
import { getAllWebviewWindows, WebviewWindow } from '@tauri-apps/api/webviewWindow';
import { WindowOptions } from '@tauri-apps/api/window';
import { StartWindowOptions } from '~/routes';
import { EditorWindowOptions } from '~/routes/editor';
import { FileLocation } from '~/types/FileLocation';

export type WindowOptionsProp = Omit<WebviewOptions, 'x' | 'y' | 'width' | 'height'> & WindowOptions;

/** 同一ラベルのウィンドウがあれば再利用してフォーカスする */
export async function openSingletonWindow(label: string, options?: WindowOptionsProp) {
  let win = await WebviewWindow.getByLabel(label);
  if (win) {
    win.show();
    win.setFocus();
    return win;
  }
  return new WebviewWindow(label, {
    ...options,
    title: label,
  });
}

export async function closeWindowsByLabel(label: string) {
  (await getAllWebviewWindows())
    .filter((w) => w.label === label)
    .forEach(async (w) => {
      await w.close();
      await w.destroy();
    });
}

export async function openEditorWindow(fileLocation?: FileLocation) {
  if (fileLocation === undefined) {
    const editorWin = new WebviewWindow('editor', {
      ...EditorWindowOptions,
      url: `/editor`,
      title: 'sledge',
    });
  } else {
    const params = new URLSearchParams();
    params.append('name', fileLocation.name);
    params.append('path', fileLocation.path);
    console.log(`/editor?${params.toString()}`);
    const editorWin = new WebviewWindow('editor', {
      ...EditorWindowOptions,
      url: `/editor?${params.toString()}`,
      title: 'sledge',
    });
  }
}

export async function openStartWindow() {
  let startWin = await WebviewWindow.getByLabel('start');
  if (startWin) {
    startWin.show();
    startWin.setFocus();
    return;
  }

  startWin = new WebviewWindow('start', {
    ...StartWindowOptions,
    url: `/`,
  });
}

================
File: src-tauri/Cargo.toml
================
[package]
name = "sledge"
version = "0.1.0"
description = "A playful pixel drawing tool"
authors = ["innsbluck"]
license = ""
repository = ""
edition = "2024"
rust-version = "1.86.0"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
name = "app_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2.1.1", features = [] }

[dependencies]
serde_json = "1.0"
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
tauri = { version = "2.4.1", features = [] }
tauri-plugin-log = "2.0.0-rc"
base64 = "0.22.1"
rand = "0.9.0"
image = "0.25.6"
jpeg-decoder = "0.3.1"
jpeg-encoder = "0.6.1"
tauri-plugin-dialog = "2.2.1"
tauri-plugin-fs = "2.2.1"
serde_bytes = "0.11.17"
tauri-plugin-shell = "2.2.1"
tauri-plugin-system-info = "2.0.9"
sysinfo = "0.34.2"

================
File: src/models/dsl/DSL.ts
================
import { SledgeNode } from '~/models/dsl/nodes/DSLNodes';
import { findLayerById } from '../../controllers/layer_list/LayerListController';
import { LayerIn } from './nodes/pass/LayerIn';
import { LayerOut } from './nodes/pass/LayerOut';

export class DSL {
  layerIn: LayerIn;
  readonly nodes: SledgeNode[];
  layerOut: LayerOut;

  constructor(inLayerId: string, outLayerId: string) {
    this.layerIn = new LayerIn(inLayerId);
    this.nodes = [];
    this.layerOut = new LayerOut(outLayerId);
  }

  public addNode(node: SledgeNode) {
    this?.nodes.push(node);
  }

  public build(exceptIn: boolean = false): string | undefined {
    const nodes = exceptIn ? [...this.nodes, this.layerOut] : [this.layerIn, ...this.nodes, this.layerOut];

    const nodeStrings: string[] = [];
    let isAllNodeParseSuccessful = true;
    nodes.forEach((node, i) => {
      const nodeStr = node.getNodeString();
      if (nodeStr !== undefined) nodeStrings.push(nodeStr);
      else {
        isAllNodeParseSuccessful = false;
        throw `DSL parse failed in: ${node.name} [${i}]`;
      }
    });

    if (isAllNodeParseSuccessful) {
      // if all nodes parsed successfully
      return nodeStrings.join(' > '); // in(inLayerId) > out(outLayerId) by default
    } else {
      // if some nodes failed to parse
      return undefined;
    }
  }

  public toString(): string {
    let str = this.build();
    if (str === undefined) throw 'DSL parse failed.';
    else {
      // 読みやすくする
      const inId = this.layerIn.layerId;
      const outId = this.layerOut.layerId;
      if (inId !== undefined) str = str.replaceAll(inId, `${findLayerById(inId)?.name || 'N/A'} ID`);
      if (outId !== undefined) str = str.replaceAll(outId, `${findLayerById(outId)?.name || 'N/A'} ID`);
      str = str.replaceAll(' > ', '\n> ');
      return str;
    }
  }
}

================
File: src/routes/about/about.css.ts
================
import { style } from '@vanilla-extract/css';
import { k12x8, Terminus, vars, ZFB03, ZFB08, ZFB31 } from '~/styles/global.css';
import { flexCol } from '~/styles/snippets.css';

export const aaContainer = style([
  flexCol,
  {
    position: 'absolute',
    top: '32px',
    right: '40px',
    width: '200px',
    height: '100%',
    alignItems: 'center',
    pointerEvents: 'none',
  },
]);

export const aaText = style({
  fontFamily: Terminus,
  fontSize: '22px',
  opacity: 0.4,
});

export const contentContainer = style([
  flexCol,
  {
    width: '100%',
    margin: '0 30px',
    marginTop: '8px',
    pointerEvents: 'none',
  },
]);

export const aboutLink = style({
  pointerEvents: 'all',
  borderBottom: '1px solid black',
  paddingBottom: '1px',
  ':hover': {
    borderBottom: 'none',
    color: 'magenta',
  },
});

export const aboutTitle = style({
  fontFamily: ZFB31,
  fontSize: '31px',
});

export const aboutSubTitle = style({
  fontFamily: ZFB03,
  fontSize: '9px',
  color: '#777',
});

export const aboutDev = style({
  fontFamily: ZFB08,
  fontSize: '8px',
});

export const aboutContent = style({
  fontFamily: ZFB08,
  fontSize: '8px',
  lineHeight: 1.6,
});

export const sendFBButton = style({
  width: 'fit-content',
  padding: '4px 4px',
  fontSize: '8px',
  borderColor: 'blue',
  background: vars.color.button,
  color: 'blue',
  ':hover': {
    color: 'white',
    background: 'blue',
  },
});

export const aboutFeedback = style({
  fontFamily: k12x8,
  fontSize: '8px',
  marginRight: '50px',
  lineHeight: 1.5,
});

================
File: src/routes/about/index.tsx
================
import { WebviewOptions } from '@tauri-apps/api/webview';
import { WindowOptions } from '@tauri-apps/api/window';
import { open } from '@tauri-apps/plugin-shell';
import {
  aaContainer,
  aaText,
  aboutContent,
  aboutFeedback,
  aboutLink,
  aboutSubTitle,
  aboutTitle,
  contentContainer,
  sendFBButton,
} from './about.css';
import { pageRoot } from '~/styles/global.css';
import { flexRow, w100, wh100 } from '~/styles/snippets.css';

export const AboutWindowOptions: Omit<WebviewOptions, 'x' | 'y' | 'width' | 'height'> & WindowOptions = {
  url: '/about',
  width: 400,
  height: 290,
  resizable: false,
  decorations: false,
  minimizable: false,
  maximizable: false,
  closable: true,
  acceptFirstMouse: true,
  focus: true,
  skipTaskbar: true,
  alwaysOnTop: true,
};

const About = () => {
  const openLink = (url: string) => {
    open(url);
  };

  return (
    <div class={pageRoot}>
      <div class={`${flexRow} ${wh100}`} style={{ 'align-items': 'center' }}>
        <div class={aaContainer}>
          <p class={aaText}>
            ⠀⠀⠀⠀⠀⠀⠀⠀⢠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⢀⣀⣀⣱⣠⣤⣤⣤⣤⣶⣶⣶⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⢠⢤⣴⣷⣾⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠹⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⠁⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠹⣟⣻⠿⠿⠿⠭⢽⡿⠛⠊⠁⠁⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⢣⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡄⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⠀⠀⠀⠀⠀⠀⠀⠀
            <br />
            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⠀⠀⠀⠀⠀⠀⠀
            <br />
          </p>
        </div>
        <div class={`${contentContainer} ${w100}`}>
          <div class={`${flexRow}`} style={{ width: '360px' }}>
            <p class={aboutTitle}>SLEDGE.</p>
            {/* <p class={aboutDev} style={{ 'margin-top': '3px' }}>
              by alphendp
            </p> */}
          </div>
          <p class={aboutSubTitle} style={{ 'margin-bottom': '14px' }}>
            pre-alpha v0.1
          </p>
          <p class={aboutContent} style={{ 'margin-bottom': '50px' }}>
            made with much <span style={{ color: 'magenta' }}>love</span> for:
            <br />-{' '}
            <a class={aboutLink} onClick={(e) => openLink('https://www.sojamo.de/libraries/controlP5/')}>
              ControlP5
            </a>
            <br />-{' '}
            <a class={aboutLink} onClick={(e) => openLink('https://archlinux.org/')}>
              Arch Linux
            </a>
            <br />-{' '}
            <a class={aboutLink} onClick={(e) => openLink('https://apps.apple.com/jp/app/caustic/id775735447/')}>
              Caustic3
            </a>{' '}
            &lt;HP dead RIP&gt;
            <br />
          </p>
          <div class={[flexRow, w100].join(' ')} style={{ 'align-items': 'center' }}>
            <p class={aboutFeedback}>
              気軽に意見を投げつけよう！
              <br />
              feel FREE to send feedback!!
            </p>
            <button class={sendFBButton} onClick={(e) => openLink('https://tally.so/r/w7jZNL')}>
              &gt;&gt; send feedback
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default About;

================
File: src/routes/settings/index.tsx
================
import { onCleanup, onMount } from 'solid-js';
import EditorSettings from '~/components/section/settings/EditorSettings';
import KeyConfigSettings from '~/components/section/settings/KeyConfigSettings';
import PerformanceSettings from '~/components/section/settings/PerformanceSettings';
import { loadGlobalSettings, saveGlobalSettings } from '~/io/global_config/globalSettings';
import { pageRoot } from '~/styles/global.css';
import { flexCol, flexRow } from '~/styles/snippets.css';
import { WindowOptionsProp } from '~/utils/windowUtils';
import { settingContainer } from './settings.css';

export const SettingsWindowOptions: WindowOptionsProp = {
  url: '/settings',
  width: 500,
  height: 300,
  resizable: false,
  decorations: false,
  minimizable: false,
  maximizable: false,
  closable: true,
  acceptFirstMouse: true,
  focus: true,
  skipTaskbar: true,
  alwaysOnTop: true,
};

export default function Settings() {
  onMount(() => {
    loadGlobalSettings();
  });

  onCleanup(async () => {
    await saveGlobalSettings();
  });

  return (
    <div class={pageRoot}>
      <form
        class={settingContainer}
        onChange={(e) => {
          saveGlobalSettings();
        }}
      >
        <div class={flexRow} style={{ 'flex-grow': 1, gap: '16px' }}>
          <div class={flexCol} style={{ 'flex-grow': 1, gap: '16px' }}>
            <EditorSettings />
            <PerformanceSettings />
          </div>
          <div class={flexCol} style={{ 'flex-grow': 1, gap: '16px' }}>
            <KeyConfigSettings />
          </div>
        </div>
      </form>
    </div>
  );
}

================
File: src-tauri/tauri.conf.json
================
{
  "$schema": "../node_modules/@tauri-apps/cli/config.schema.json",
  "productName": "sledge",
  "version": "0.1.0",
  "identifier": "com.innsbluck",
  "build": {
    "frontendDist": "../dist",
    "devUrl": "http://localhost:5173",
    "beforeDevCommand": "npm run dev",
    "beforeBuildCommand": "npm run prettier && npm run build"
  },
  "app": {
    "windows": [
      {
        "create": true,
        "title": "sledge",
        "label": "start",
        "width": 700,
        "height": 500,
        "acceptFirstMouse": true,
        "resizable": false,
        "closable": true,
        "maximizable": true,
        "minimizable": true,
        "decorations": false,
        "fullscreen": false
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "fileAssociations": [
      {
        "ext": ["sledge"],
        "description": "Sledge Project File"
      }
    ],
    "active": true,
    "targets": "all",
    "icon": [
      "icons_light/icon.ico",
      "icons_light/32x32.png",
      "icons_light/128x128.png",
      "icons_light/256x256.png"
    ]
  }
}

================
File: src/components/common/companion/Companion.tsx
================
// import { Component, createEffect, createSignal } from 'solid-js';
// import styles from '@styles/components/companion.module.css';

// const [sayRequest, setSayRequest] = createSignal<string | null>(null);

// export const CompanionEvents = {
//   sayRequest,
//   setSayRequest,
// };

// const Companion: Component = () => {
//   const [quote, setQuote] = createSignal('');

//   const say = (text: string) => {
//     window.speak?.(text, {
//       amplitude: 5,
//       pitch: 10,
//       speed: 200,
//       wordgap: 0,
//     });
//   };

//   createEffect(() => {
//     const message = CompanionEvents.sayRequest();
//     if (message) {
//       say(message);
//       setQuote(message);
//       const element = document.getElementById('companion');
//       setTimeout(() => {
//         setQuote('');
//         if (element) element.className = element.className.replace(` ${styles['giggle']}`, '');
//       }, 5000);
//       window.requestAnimationFrame(function (time) {
//         window.requestAnimationFrame(function (time) {
//           if (element) element.className += ` ${styles['giggle']}`;
//         });
//       });
//       CompanionEvents.setSayRequest(null); // 一度で消費
//     }
//   });

//   return (
//     <div class={styles.root}>
//       <div class={styles.wrapper}>
//         <div class={styles.companion} id='companion'>
//           <img src='/companion.png' alt='you challenge me?' />
//         </div>
//         {quote() && (
//           <div class={styles.quote_box_container}>
//             <div class={styles.quote_box}>
//               <p class={styles.quote}>{quote()}</p>
//             </div>
//           </div>
//         )}
//       </div>
//       <div id='audio' />
//     </div>
//   );
// };

// let lastSpoke = 0;
// export const smartSay = (text: string): boolean => {
//   const now = Date.now();
//   if (now - lastSpoke > 5000) {
//     CompanionEvents.setSayRequest(text);
//     lastSpoke = now;
//     return true;
//   }
//   return false;
// };

// export default Companion;

================
File: src/models/layer_image/agents/RawLayerImageAgent.ts
================
import { Vec2 } from '~/types/Vector';
import { RGBAColor } from '~/utils/ColorUtils';
import { PixelDiff } from '../HistoryManager';
import LayerImageAgent from '../LayerImageAgent';

export default class RawLayerImageAgent extends LayerImageAgent {
  putImageInto(ctx: CanvasRenderingContext2D) {
    ctx.putImageData(this.image, 0, 0);
  }

  putDrawingBufferInto(ctx: CanvasRenderingContext2D) {
    if (this.drawingBuffer) ctx.putImageData(this.drawingBuffer, 0, 0);
  }

  public setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.setPixelInPosition(position, color, excludePositionMatch, excludeColorMatch);
  }

  public deletePixel(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.deletePixelInPosition(position, excludePositionMatch, excludeColorMatch);
  }

  public getPixel(position: Vec2): RGBAColor {
    const i = (position.y * this.image.width + position.x) * 4;
    const d = this.image.data;
    return [d[i], d[i + 1], d[i + 2], d[i + 3]];
  }
}

================
File: src/models/layer_image/HistoryManager.ts
================
import { reconcile } from 'solid-js/store';
import { setLayerHistoryStore } from '~/stores/ProjectStores';
import { TileIndex } from '~/types/Tile';
import { RGBAColor } from '~/utils/ColorUtils';
import { Vec2 } from '../../types/Vector';

export type PixelDiff = {
  kind: 'pixel';
  position: Vec2;
  before: RGBAColor;
  after: RGBAColor;
};

export type TileDiff = {
  kind: 'tile';
  index: TileIndex;
  beforeColor: RGBAColor | undefined;
  afterColor: RGBAColor;
};

export type Diff = PixelDiff | TileDiff;

export const getDiffHash = (diff: Diff) => {
  switch (diff.kind) {
    case 'pixel':
      return `px:${diff.position.x},${diff.position.y}`;
    case 'tile':
      return `tile:${diff.index.row},${diff.index.column}`;
  }
};

export type DiffAction = {
  diffs: Map<string, Diff>;
};

export class HistoryManager {
  protected undoActionsStack: DiffAction[] = [];
  protected redoActionsStack: DiffAction[] = [];
  private readonly maxStackSize = 50;

  constructor(public layerId: string) {}

  public getUndoStack() {
    return this.undoActionsStack;
  }

  public getRedoStack() {
    return this.redoActionsStack;
  }

  public canUndo() {
    return this.undoActionsStack.length > 0;
  }

  public canRedo() {
    return this.redoActionsStack.length > 0;
  }

  public addAction(action: DiffAction) {
    // push new action and cap undo history
    this.undoActionsStack.push(action);
    if (this.undoActionsStack.length > this.maxStackSize) {
      this.undoActionsStack.shift();
    }
    // clear redo history
    this.redoActionsStack = [];

    this.syncStores();
  }

  public undo(): DiffAction | undefined {
    const undoedAction = this.undoActionsStack.pop();
    if (!undoedAction) return undefined;

    // push to redo and cap redo history
    this.redoActionsStack.unshift(undoedAction);
    if (this.redoActionsStack.length > this.maxStackSize) {
      this.redoActionsStack.pop();
    }

    this.syncStores();
    return undoedAction;
  }

  public redo(): DiffAction | undefined {
    const redoedAction = this.redoActionsStack.shift();
    if (!redoedAction) return undefined;

    // push back to undo and cap undo history
    this.undoActionsStack.push(redoedAction);
    if (this.undoActionsStack.length > this.maxStackSize) {
      this.undoActionsStack.shift();
    }

    this.syncStores();
    return redoedAction;
  }

  /**
   * Synchronize the undo/redo stacks with the SolidJS store
   */
  private syncStores() {
    setLayerHistoryStore(this.layerId, 'undoStack', reconcile(this.undoActionsStack));
    setLayerHistoryStore(this.layerId, 'redoStack', reconcile(this.redoActionsStack));
  }
}

================
File: src/styles/global.css.ts
================
import { createGlobalTheme, fontFace, globalStyle, style } from '@vanilla-extract/css';

export const ZFB03 = fontFace({
  src: 'url("/fonts/04B_03__.ttf")',
});
export const ZFB03B = fontFace({
  src: 'url("/fonts/04B_03B_.ttf")',
});
export const ZFB08 = fontFace({
  src: 'url("/fonts/04B_08__.ttf")',
});
export const ZFB09 = fontFace({
  src: 'url("/fonts/04B_09__.ttf")',
});
export const ZFB11 = fontFace({
  src: 'url("/fonts/04B_11__.ttf")',
});
export const ZFB31 = fontFace({
  src: 'url("/fonts/04B_31__.ttf")',
});
export const Terminus = fontFace({
  src: 'url("/fonts/terminus/TerminusTTF-4.49.3.ttf")',
});
export const k8x12 = fontFace({
  src: 'url("/fonts/k8x12/k8x12.ttf")',
});
export const k8x12L = fontFace({
  src: 'url("/fonts/k8x12/k8x12L.ttf")',
});
export const k8x12S = fontFace({
  src: 'url("/fonts/k8x12/k8x12S.ttf")',
});
export const k12x8 = fontFace({
  src: 'url("/fonts/k12x8/k12x8.ttf")',
});

export const vars = createGlobalTheme(':root', {
  color: {
    primary: '#ffffff',
    secondary: '#f0f0f0',
    text: '#111111',
    danger: '#ff0000',
    muted: '#00000030',

    accent: '#0000ff',

    bg: '#ffffff',
    bg_canvas_area: '#fefefe',

    surface: '#f2f2f2',

    button: '#ffffff',
    button_hover: '#f0f0f0',
    button_pressed: '#f0f0f0',

    input_bg: '#fafafa',
  },
  size: {
    edge_info: '32px',
    side_area: '220px',
    bottom_bar_margin: '252px',
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '12px',
    lg: '16px',
    xl: '24px',
  },
  text: {
    xs: '6px',
    sm: '8px',
    md: '10px',
    lg: '12px',
    xl: '16px',
  },
  font: {
    body: `${ZFB08}, ${k8x12}`,
  },
});

globalStyle('button, p, a, input, label', {
  fontFamily: `${ZFB08}, ${k12x8}`,
  color: vars.color.text,
});

globalStyle('a:hover', {
  color: 'red',
});

globalStyle('button', {
  background: vars.color.button,
  border: '1px black solid',
  borderRadius: '2px',
  cursor: 'pointer',
  fontSize: '0.5rem',
  height: 'fit-content',
  padding: '2px 6px',
  pointerEvents: 'all',
  width: 'fit-content',
});

globalStyle('button:hover', {
  background: vars.color.button_hover,
});

globalStyle('button:active', {
  background: vars.color.button_pressed,
  transform: 'translateY(1px)',
});

export const pageRoot = style({
  display: 'flex',
  flexDirection: 'row',
  height: '100%',
  width: '100vw',
  userSelect: 'none',
});

export const sledgeLogo = style({
  bottom: '2px',
  position: 'absolute',
  right: '2px',
});

================
File: vite.config.js
================
import { defineConfig } from 'vite'
import solidPlugin from 'vite-plugin-solid'
import tsconfigPaths from 'vite-tsconfig-paths'
import path from 'path'
import { vanillaExtractPlugin } from '@vanilla-extract/vite-plugin'

export default defineConfig({
  plugins: [
    vanillaExtractPlugin({ devStyleRuntime: 'vanilla-extract' }),
    solidPlugin(),
    tsconfigPaths(),
  ],
  build: {
    target: 'esnext',
    outDir: 'dist',
  },
  server: {
    host: true,
    port: 5173,
  },
  alias: {
    '~': path.resolve(__dirname, 'src'),
  },
})

================
File: src/components/common/ColorBox.tsx
================
import { Component } from 'solid-js';
import { currentColor } from '~/controllers/color/ColorController';
import { sayRandomQuote } from './companion/QuotePool';

interface ColorBoxProps {
  class?: string;
  enableUsingSelection?: boolean;
  sizePx?: number;
  color: string;
  onClick?: (color: string) => void;
}

const ColorBox: Component<ColorBoxProps> = (props: ColorBoxProps) => {
  const size = () => props.sizePx || 10;

  const isSelected = () => props.enableUsingSelection && currentColor() === props.color;
  const isWhiteOrNone = () => props.color === 'none' || props.color.toLowerCase() === '#ffffff';

  const onColorClicked = (color: string) => {
    sayRandomQuote('color-pick', { color: color });
    if (props.onClick) props.onClick(color);
  };

  return (
    <div class={props.class}>
      <div
        style={{
          position: 'relative',
          display: 'flex',
          width: `${size()}px`,
          height: `${size()}px`,
          'align-items': 'center',
          'justify-content': 'center',
          cursor: 'pointer',
          'background-color': props.color,
          border: isWhiteOrNone() || isSelected() ? '0.05rem solid black' : '0.05rem solid transparent',
        }}
        onClick={() => {
          onColorClicked(props.color);
        }}
      >
        {props.enableUsingSelection && isSelected() && (
          <div
            style={{
              width: `${Math.round(size() / 3)}px`,
              height: `${Math.round(size() / 3)}px`,
              margin: 0,
              padding: 0,
              'background-color': props.color !== '#000000' ? 'black' : 'white',
            }}
            onClick={() => {
              onColorClicked(props.color);
            }}
          />
        )}
      </div>
    </div>
  );
};

export default ColorBox;

================
File: src/models/layer_image/agents/TileLayerImageAgent.ts
================
import Tile, { TileIndex } from '~/types/Tile';
import { Vec2 } from '~/types/Vector';
import { colorMatch, RGBAColor } from '~/utils/ColorUtils';
import { HistoryManager, PixelDiff, TileDiff } from '../HistoryManager';
import LayerImageAgent from '../LayerImageAgent';

export default class TileLayerImageAgent extends LayerImageAgent {
  readonly TILE_SIZE = 16;

  private tiles: Tile[][] = [];

  getTile(index: TileIndex) {
    // console.log(`tile access to ${index.row}. ${index.column}`)
    return this.tiles[index.row][index.column];
  }

  getTiles() {
    return this.tiles;
  }

  constructor(imageData: ImageData, historyManager: HistoryManager) {
    super(imageData, historyManager);
    this.initTile();
  }

  initTile() {
    const tileRowCount = Math.ceil(this.getHeight() / this.TILE_SIZE);
    const tileColumnCount = Math.ceil(this.getWidth() / this.TILE_SIZE);
    for (let row = 0; row < tileRowCount; row++) {
      this.tiles[row] = [];
      for (let column = 0; column < tileColumnCount; column++) {
        this.tiles[row][column] = new Tile(row, column, this.TILE_SIZE);
      }
    }
    this.scanAllTilesUniformity();
  }

  scanAllTilesUniformity() {
    const { TILE_SIZE } = this;
    const w = this.getWidth();
    const h = this.getHeight();

    for (const row of this.tiles) {
      for (const tile of row) {
        const { x: ox, y: oy } = tile.getOffset();

        // ①タイルの左上ピクセルを基準色に
        const base = this.getPixel({ x: ox, y: oy });

        let uniform = true;
        // ②タイル内を走査（画像端は超えないよう clamp）
        for (let dy = 0; dy < TILE_SIZE && uniform; dy++) {
          const py = oy + dy;
          if (py >= h) break;
          for (let dx = 0; dx < TILE_SIZE; dx++) {
            const px = ox + dx;
            if (px >= w) break;
            if (!colorMatch(this.getPixel({ x: px, y: py }), base)) {
              uniform = false;
              break;
            }
          }
        }
        // ③結果を保存
        tile.isUniform = uniform;
        tile.uniformColor = uniform ? base : undefined;
      }
    }
  }

  setImage(image: ImageData): void {
    super.setImage(image);
    this.initTile();
  }

  putImageInto(ctx: CanvasRenderingContext2D) {
    if (this.getDirtyTiles().length > 0) {
      this.putOnlyForDirtyTiles(ctx, this.image);
    }
  }

  putDrawingBufferInto(ctx: CanvasRenderingContext2D) {
    if (this.getDirtyTiles().length > 0) {
      if (this.drawingBuffer) this.putOnlyForDirtyTiles(ctx, this.drawingBuffer);
    }
  }

  private putOnlyForDirtyTiles(ctx: CanvasRenderingContext2D, image: ImageData) {
    const dirtyTiles = this.getDirtyTiles();

    dirtyTiles.forEach((dirtyTile) => {
      const offset = dirtyTile.getOffset();
      ctx.putImageData(image, 0, 0, offset.x, offset.y, this.TILE_SIZE, this.TILE_SIZE);
    });

    this.resetDirtyStates();
  }

  public getTileIndex(layerPosition: Vec2): TileIndex {
    const row = Math.floor(layerPosition.y / this.TILE_SIZE);
    const column = Math.floor(layerPosition.x / this.TILE_SIZE);
    return { row, column };
  }

  public resetDirtyStates() {
    this.tiles = this.tiles.map((tR) => {
      tR = tR.map((t) => {
        t.isDirty = false;
        return t;
      });
      return tR;
    });
  }

  public resetAllDirtyStates() {
    this.tiles = this.tiles.map((tR) => {
      tR = tR.map((t) => {
        t.isDirty = false;
        t.isDirtyThroughAction = false;
        return t;
      });
      return tR;
    });
  }

  public getDirtyTiles(): Tile[] {
    return this.tiles.flatMap((tR) => tR.filter((t) => t.isDirty));
  }
  public getDirtyTilesInAction(): Tile[] {
    return this.tiles.flatMap((tR) => tR.filter((t) => t.isDirtyThroughAction));
  }

  protected undoTileDiff(tileDiff: TileDiff): void {
    console.log(`tilediff. fill ${tileDiff.beforeColor}`);
    if (tileDiff.beforeColor) this.fillWholeTile(tileDiff.index, tileDiff.beforeColor, false);
  }

  protected redoTileDiff(tileDiff: TileDiff): void {
    console.log(`tilediff. fill ${tileDiff.afterColor}`);
    this.fillWholeTile(tileDiff.index, tileDiff.afterColor, false);
  }

  public setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    const result = this.setPixelInPosition(position, color, excludePositionMatch, excludeColorMatch);
    if (result !== undefined) {
      const tileIndex = this.getTileIndex(position);
      this.tiles[tileIndex.row][tileIndex.column].isDirty = true;
      this.tiles[tileIndex.row][tileIndex.column].isDirtyThroughAction = true;

      const tile = this.getTile(tileIndex);
      if (tile.isUniform && tile.uniformColor !== undefined && colorMatch(tile.uniformColor, color)) {
        this.tiles[tileIndex.row][tileIndex.column].isUniform = false;
        this.tiles[tileIndex.row][tileIndex.column].uniformColor = undefined;
      }
    }
    return result;
  }

  fillWholeTile(index: TileIndex, color: RGBAColor, collectDiff = true) {
    const tile = this.getTile(index);
    if (tile.isUniform && tile.uniformColor && colorMatch(tile.uniformColor, color)) return;

    const [r, g, b, a] = color;
    const { x: ox, y: oy } = tile.getOffset();
    const { TILE_SIZE } = this;
    const { width, data } = this.image;

    for (let dy = 0; dy < TILE_SIZE; dy++) {
      const y = oy + dy;
      if (y >= this.getHeight()) break;
      let i = (y * width + ox) * 4; // 行頭インデックス
      for (let dx = 0; dx < TILE_SIZE; dx++) {
        const x = ox + dx;
        if (x >= this.getWidth()) break;

        data[i] = r;
        data[i + 1] = g;
        data[i + 2] = b;
        data[i + 3] = a;
        i += 4;
      }
    }

    if (collectDiff)
      this.addDiffs([
        {
          kind: 'tile',
          index,
          beforeColor: tile.uniformColor,
          afterColor: [r, g, b, a],
        },
      ]);

    // 状態更新
    tile.isDirty = tile.isDirty = true;
    tile.isDirty = tile.isDirtyThroughAction = true;
    tile.isUniform = true;
    tile.uniformColor = color;
  }

  public deletePixel(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    const result = this.deletePixelInPosition(position, excludePositionMatch, excludeColorMatch);
    if (result !== undefined) {
      const tileIndex = this.getTileIndex(position);
      this.tiles[tileIndex.row][tileIndex.column].isDirty = true;
      this.tiles[tileIndex.row][tileIndex.column].isDirtyThroughAction = true;
    }
    return result;
  }

  public getPixel(position: Vec2): RGBAColor {
    const i = (position.y * this.image.width + position.x) * 4;
    const d = this.image.data;

    return [d[i], d[i + 1], d[i + 2], d[i + 3]];
  }

  public getTileRowCount() {
    return this.tiles.length;
  }

  public getTileColumnCount() {
    return this.tiles[0].length;
  }

  public isTileInBounds(index: TileIndex) {
    return (
      index.row >= 0 &&
      index.row < this.getTileRowCount() &&
      index.column >= 0 &&
      index.column < this.getTileColumnCount()
    );
  }
}

================
File: src-tauri/src/lib.rs
================
use serde::Serialize;
use sysinfo::{ProcessesToUpdate, System, get_current_pid};

#[derive(Serialize)]
struct ProcessMem {
    /// 本体プロセス＋子プロセスの合計 RSS（バイト）
    total_bytes: u64,
    /// 本体だけ
    main_bytes: u64,
    /// 子プロセス（レンダラー等）だけ
    children_bytes: u64,
}

#[tauri::command]
fn get_process_memory() -> ProcessMem {
    let pid = get_current_pid().unwrap();
    let mut sys = System::new_all();
    sys.refresh_processes(ProcessesToUpdate::All, false);

    let mut main = 0;
    let mut children = 0;
    for proc in sys.processes().values() {
        if proc.pid() == pid {
            main = proc.memory();
        } else {
            // 直上の親が自分なら子
            let mut parent = proc.parent();
            while let Some(p) = parent {
                if p == pid {
                    children += proc.memory();
                    break;
                }
                parent = sys.process(p).and_then(|pp| pp.parent());
            }
        }
    }

    ProcessMem {
        total_bytes: main + children,
        main_bytes: main,
        children_bytes: children,
    }
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    let builder = tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![get_process_memory,])
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_system_info::init());

    builder
        .setup(|_app| Ok(()))
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

================
File: src/components/common/LayerPreview.tsx
================
import { Component, onMount } from 'solid-js';
import { getImageOf, layerImageManager } from '~/routes/editor';
import { layerPreviewCanvas } from '~/styles/components/layer_preview.css';
import { Layer } from '~/types/Layer';

interface Props {
  layer: Layer;
  maxWidth?: number;
  maxHeight?: number;
  onClick?: () => void;
}

const LayerPreview: Component<Props> = (props: Props) => {
  let wrapperRef: HTMLDivElement;
  let canvasRef: HTMLCanvasElement;

  const updatePreview = (originalImage: ImageData, targetHeight: number) => {
    const aspectRatio = originalImage.width / originalImage.height;
    const targetWidth = Math.round(targetHeight * aspectRatio);

    // 描画対象キャンバスの解像度とCSSサイズを一致させる
    canvasRef.width = targetWidth;
    canvasRef.height = targetHeight;

    const maxWidth = props.maxWidth;
    const maxHeight = props.maxHeight;
    let zoom = 1;
    if (maxWidth && targetWidth > maxWidth) zoom = maxWidth / targetWidth;
    if (maxHeight && targetHeight > maxHeight && zoom < maxHeight / targetHeight) zoom = maxHeight / targetHeight;

    canvasRef.style.width = `${targetWidth * zoom}px !important`;
    canvasRef.style.height = `${targetHeight * zoom}px !important`;

    wrapperRef.style.width = `${targetWidth * zoom}px !important`;
    wrapperRef.style.height = `${targetHeight * zoom}px !important`;

    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = originalImage.width;
    tmpCanvas.height = originalImage.height;
    tmpCanvas.getContext('2d')!.putImageData(originalImage, 0, 0);

    const ctx = canvasRef.getContext('2d')!;
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, targetWidth, targetHeight);

    ctx.drawImage(tmpCanvas, 0, 0, originalImage.width, originalImage.height, 0, 0, targetWidth, targetHeight);
  };

  onMount(() => {
    const height = wrapperRef.clientHeight;
    const currentImage = getImageOf(props.layer.id);

    let agent = layerImageManager.getAgent(props.layer.id);
    if (currentImage) {
      agent?.setImage(currentImage, true);
      updatePreview(currentImage, height);
    }

    agent?.setOnImageChangeListener('layer_prev_' + props.layer.id, () => {
      const img = getImageOf(props.layer.id);
      if (img) updatePreview(img, height);
    });
  });

  return (
    <div ref={(el) => (wrapperRef = el)}>
      <canvas
        class={layerPreviewCanvas}
        ref={(el) => (canvasRef = el)}
        onClick={(e) => {
          if (props.onClick) props.onClick();
        }}
      />
    </div>
  );
};

export default LayerPreview;

================
File: src/components/section/LayerList.tsx
================
import { closestCenter, DragDropProvider, DragDropSensors, SortableProvider } from '@thisbeyond/solid-dnd';
import { Component, createEffect, createSignal, For, onMount } from 'solid-js';
import { activeLayer, addLayer, allLayers, removeLayer } from '~/controllers/layer_list/LayerListController';

import { layerListStore, setLayerListStore } from '~/stores/ProjectStores';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/components/globals/section_global.css';
import { layerList } from '~/styles/section/layer.css';
import { flexRow } from '~/styles/snippets.css';
import LayerItem from './item/LayerItem';
// 並べ替え用ユーティリティ関数

const LayerList: Component<{}> = () => {
  const [items, setItems] = createSignal(allLayers());
  const [activeItem, setActiveItem] = createSignal(null);
  const ids = () => items().map((l) => l.id);

  onMount(() => {
    setItems(allLayers());
  });

  createEffect(() => {
    setItems(allLayers());
  });

  const onDragStart = ({ draggable }: { draggable: any }) => setActiveItem(draggable.id);

  function moveLayer(draggedId: string, targetIndex: number) {
    const fromIndex = layerListStore.layers.findIndex((l) => l.id === draggedId);
    if (fromIndex === -1 || fromIndex === targetIndex) return;

    const updated = [...layerListStore.layers];
    const [moved] = updated.splice(fromIndex, 1);
    updated.splice(targetIndex, 0, moved);
    setLayerListStore('layers', updated);
    setItems(allLayers());
  }

  const onDragEnd = ({ draggable, droppable }: { draggable: any; droppable: any }) => {
    if (draggable && droppable) {
      const currentItems = ids();
      const fromIndex = currentItems.indexOf(draggable.id);
      const toIndex = currentItems.indexOf(droppable.id);
      if (fromIndex !== toIndex) {
        moveLayer(draggable.id, toIndex);
      }
    }
  };

  return (
    <DragDropProvider
      onDragStart={onDragStart}
      onDragEnd={(e) => {
        onDragEnd({ draggable: e.draggable, droppable: e.droppable });
      }}
      collisionDetector={closestCenter}
    >
      <DragDropSensors>
        <div class={sectionRoot}>
          <div class={flexRow} style={{ 'margin-bottom': '6px' }}>
            <p class={sectionCaption} style={{ 'flex-grow': 1 }}>
              layers.
            </p>

            <div class={flexRow} style={{ gap: '4px' }}>
              <button
                onClick={async () => {
                  await addLayer('dot1');
                  setItems(allLayers());
                }}
              >
                + add.
              </button>

              <button
                onClick={() => {
                  removeLayer(activeLayer()?.id);
                  setItems(allLayers());
                }}
              >
                - remove.
              </button>
            </div>
          </div>
          <div class={sectionContent}>
            <div class={layerList}>
              <SortableProvider ids={ids()}>
                <For each={items()}>
                  {(layer, index) => (
                    <LayerItem layer={layer} index={index()} isLast={index() === items().length - 1} />
                  )}
                </For>
              </SortableProvider>
            </div>
            {/* <DragOverlay>
                                    <div class="sortable"><LayerItem layer={activeItemLayer()} /></div>
                                </DragOverlay> */}
          </div>
        </div>
      </DragDropSensors>
    </DragDropProvider>
  );
};

export default LayerList;

================
File: src/components/section/Project.tsx
================
import { Component, createSignal, onMount, Show } from 'solid-js';
import { exportActiveLayerUpscaled } from '~/io/image/save';
import { saveProject } from '~/io/project/project';
import { projectStore, setProjectStore } from '~/stores/ProjectStores';

import { sectionContent, sectionRoot } from '~/styles/components/globals/section_global.css';
import { vars } from '~/styles/global.css';
import { projectNameInput } from '~/styles/section/project.css';
import { flexCol, flexRow } from '~/styles/snippets.css';

const Project: Component = () => {
  const [saveLog, setSaveLog] = createSignal<string | undefined>(undefined);
  const isNameChanged = () => projectStore.name !== projectStore.newName;
  const isOWPossible = () => projectStore.name !== undefined && projectStore.path !== undefined && !isNameChanged();

  onMount(() => {
    setProjectStore('newName', projectStore.name);
  });

  const save = () => {
    if (isNameChanged()) {
      setProjectStore('name', projectStore.newName);
    }
    if (isOWPossible()) {
      // 上書き保存
      saveProject(`${projectStore.path}`).then(() => {
        setSaveLog('saved!');
        setProjectStore('isProjectChangedAfterSave', false);
      });
    } else {
      saveProject().then(() => {
        setSaveLog('saved!');
        setProjectStore('isProjectChangedAfterSave', false);
      });
    }
  };
  const OWSave = () => {
    if (isNameChanged()) {
      setProjectStore('name', projectStore.newName);
    }
    // 上書き保存
    saveProject(`${projectStore.path}`).then(() => {
      setSaveLog('saved!');
      setProjectStore('isProjectChangedAfterSave', false);
    });
  };
  const forceNewSave = () => {
    if (isNameChanged()) {
      setProjectStore('name', projectStore.newName);
    }
    saveProject().then(() => {
      setSaveLog('saved!');
      setProjectStore('isProjectChangedAfterSave', false);
    });
  };

  return (
    <div class={sectionRoot}>
      {/* <p class={sectionCaption}>project.</p> */}
      <div class={sectionContent}>
        <div
          class={flexCol}
          style={{
            'margin-top': '8px',
          }}
        >
          <Show when={isNameChanged()}>
            <p>{projectStore.name} →</p>
          </Show>

          <input
            class={projectNameInput}
            type='text'
            name='height'
            onInput={(e) => {
              if (e.target.value) setProjectStore('newName', e.target.value);
            }}
            onChange={(e) => {
              if (e.target.value) setProjectStore('newName', e.target.value);
            }}
            value={projectStore.name}
            placeholder='project name'
            autocomplete='off'
          />

          {/* <p class={styles.project_file_path}>{projectStore.path}</p> */}
        </div>
        {/* <button class={styles.loadsave_button} onClick={() => importProjectJsonFromFileSelection()}>
                        load.
                    </button> */}

        <div
          class={flexRow}
          style={{
            'align-items': 'center',
            'margin-top': '4px',
            'margin-bottom': '12px',
            gap: vars.spacing.sm,
          }}
        >
          <Show when={isOWPossible()}>
            <button
              onClick={() => OWSave()}
              style={{
                color: vars.color.accent,
                'border-color': vars.color.accent,
              }}
            >
              save.
            </button>
            <button onClick={() => forceNewSave()}>save (new).</button>
          </Show>
          <Show when={!isOWPossible()}>
            <button
              onClick={() => forceNewSave()}
              style={{
                color: vars.color.accent,
                'border-color': vars.color.accent,
              }}
            >
              save (new).
            </button>
          </Show>
          <button onClick={() => exportActiveLayerUpscaled(projectStore.newName || projectStore.name)}>export.</button>
          {/*   {!projectStore.isProjectChangedAfterSave && <p class={styles.save_log}>{saveLog()}</p>} */}
        </div>
      </div>
    </div>
  );
};

export default Project;

================
File: README.md
================
# Sledge

<img src="./public/readme_intro.png" alt="the picture of a well-drawn sledgehammer." width="500px"/>\

> this project is pre-alpha.  
> feel free to DM me: [@alphendp](https://x.com/alphendp)

## build

if you don't have tauri, install first (https://v2.tauri.app/ja/)

```bash
git clone https://gitlab.com/Innsbluck/sledge.git
cd sledge
npm install # install solidjs dependencies
npm tauri dev # launch
```

## what you'll get

### ■&ensp;&nbsp;pixel-perfect drawing experience

- **no alpha channels**. \
  erasing just works. nothing left behind.

- **dot magnification** factor, such as `x1` or `x4`. \
  it enables you to put some _out-of-place_ pixel art on a high-definition background.

  <!-- some introduction picture for layers -->

### \>\_ &nbsp;useful (or _unstable_) effects

- built-in stuff:

  - **standard effects** — `brightness`, `contrast`, `invert`

  - **filter and split functions** — `splitV`, `colorRange`, `rect`

  - **destructive effects** — `JPEG glitches`

- all effects are written in Rust.

  <!-- some introduction picture for the effects -->

### :)&ensp;companion

- pretty companion improves your drawing experiment.

## DSL(Data Shaping Line)

sledge's DSL(Data Shaping Line) is a flexible and powerful effect pipelines.

```shell
# layer_N: unique id for layerN
# in(layer_N): read the image data from layer.
# out(layer_N): output the image data to layer.

in(layer_0) > out(layer_0)  # do nothing.

in(layer_0) > contrast(20%) > invert() > out(layer_0)  # apply contrast+20%, then invert it.

in(layer_1) > splitV(50%) > multiout(*upper, *lower)  # apply grayscale, split vertically in half.
upper > jpeg_glitch(9, 72) > *merged                # apply jpeg_glitch for the upper half of layer1.
lower > invert() > merged                          # invert the lower half of layer1.
merged > out(layer_1)                               # merge split images and throw back to layer1.

# note 1: *upper, *lower, and *merged are called "subout nodes" (basically like named pipes.)
# note 2: subout nodes automatically merge/override multiple inputs.
```

- supports the GUI node editor to add / swap / mutate effects.
- of course, raw command-line input is also available.\
  either way, dsl effects are applied to the image immediately and reactively.

## tech

- [SolidJS](https://www.solidjs.com/) (UI)
- [Tauri](https://tauri.app/) (desktop wrapper)
- [Rust](https://www.rust-lang.org/) (effect processing)
- [speak.js](https://github.com/kripken/speak.js/) (TTS engine)

================
File: src/components/canvas/stacks/CanvasOverlaySVG.tsx
================
import { Component, For } from 'solid-js';
import { activeLayer } from '~/controllers/layer_list/LayerListController';
import { currentTool as getCurrentTool } from '~/controllers/tool/ToolController';
import { interactStore } from '~/stores/EditorStores';
import { globalStore } from '~/stores/GlobalStores';
import { canvasStore } from '~/stores/ProjectStores';
import Tile from '~/types/Tile';

const CanvasOverlaySVG: Component<{ dirtyRects?: Tile[] }> = (props) => {
  const borderWidth = () => canvasStore.canvas.width * interactStore.zoom;
  const borderHeight = () => canvasStore.canvas.height * interactStore.zoom;

  const zoomedPenSize = () => getCurrentTool().size * interactStore.zoom;

  const dirtyRects = () => (globalStore.showDirtyRects ? props.dirtyRects : []);

  return (
    <svg
      viewBox={`0 0 ${borderWidth()} ${borderHeight()}`}
      xmlns='http://www.w3.org/2000/svg'
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        'pointer-events': 'none',
        'image-rendering': 'pixelated',
        'shape-rendering': 'geometricPrecision',
        'z-index': 1000,
      }}
    >
      {/* border rect */}
      <rect
        width={borderWidth()}
        height={borderHeight()}
        fill='none'
        stroke='black'
        stroke-width={1}
        pointer-events='none'
      />

      {/* pen hover preview */}
      <rect
        width={zoomedPenSize()}
        height={zoomedPenSize()}
        x={Math.round(interactStore.lastMouseOnCanvas.x * interactStore.zoom) - zoomedPenSize() / 2}
        y={Math.round(interactStore.lastMouseOnCanvas.y * interactStore.zoom) - zoomedPenSize() / 2}
        fill='none'
        stroke='black'
        stroke-width={1}
        pointer-events='none'
      />

      <For each={dirtyRects()}>
        {(dirtyRect) => {
          return (
            <rect
              width={dirtyRect.globalTileSize * activeLayer()?.dotMagnification * interactStore.zoom}
              height={dirtyRect.globalTileSize * activeLayer()?.dotMagnification * interactStore.zoom}
              x={dirtyRect.getOffset().x * activeLayer()?.dotMagnification * interactStore.zoom}
              y={dirtyRect.getOffset().y * activeLayer()?.dotMagnification * interactStore.zoom}
              fill={dirtyRect.isDirty ? '#ff000060' : '#00ffff60'}
              stroke='none'
              pointer-events='none'
            />
          );
        }}
      </For>
    </svg>
  );
};

export default CanvasOverlaySVG;

================
File: src/models/layer_image/LayerImageAgent.ts
================
import { setBottomBarText } from '~/controllers/log/LogController';
import { Vec2 } from '~/types/Vector';
import { colorMatch, RGBAColor } from '~/utils/ColorUtils';
import { Diff, DiffAction, getDiffHash, HistoryManager, PixelDiff, TileDiff } from './HistoryManager';

interface DrawingBufferChangeEvent {}
interface ImageChangeEvent {}

// それぞれのLayerCanvasの描画、表示までの処理過程を記述するクラス
export default abstract class LayerImageAgent {
  protected image: ImageData;
  protected drawingBuffer: ImageData | undefined;
  protected historyManager;

  protected onImageChangedListeners: {
    [key: string]: (e: ImageChangeEvent) => void;
  } = {};
  protected onDrawingBufferChangedListeners: {
    [key: string]: (e: DrawingBufferChangeEvent) => void;
  } = {};

  constructor(imageData: ImageData, historyManager?: HistoryManager) {
    this.image = imageData;
    this.drawingBuffer = imageData;
    this.historyManager = historyManager;
  }

  getHistoryManager() {
    return this.historyManager;
  }

  getImage() {
    return this.image;
  }

  setImage(image: ImageData, silentlySet: boolean = false) {
    this.image = image;
    if (!silentlySet) this.callOnImageChangeListeners();
    this.resetDrawingBuffer();
  }

  getDrawingBuffer() {
    return this.drawingBuffer;
  }

  setDrawingBuffer(imageData?: ImageData) {
    this.drawingBuffer = imageData;
    this.callOnDrawingBufferChangeListeners();
  }

  resetDrawingBuffer() {
    this.setDrawingBuffer(this.image);
  }

  abstract putImageInto(ctx: CanvasRenderingContext2D): void;
  abstract putDrawingBufferInto(ctx: CanvasRenderingContext2D): void;

  putImageIntoForce(ctx: CanvasRenderingContext2D) {
    ctx.putImageData(this.image, 0, 0);
  }
  putDrawingBufferIntoForce(ctx: CanvasRenderingContext2D) {
    if (this.drawingBuffer) ctx.putImageData(this.drawingBuffer, 0, 0);
  }

  setOnImageChangeListener(key: string, listener: (e: ImageChangeEvent) => void) {
    this.onImageChangedListeners[key] = listener;
  }
  clearOnImageChangeListener(key: string) {
    delete this.onImageChangedListeners[key];
  }

  setOnDrawingBufferChangeListener(key: string, listener: (e: DrawingBufferChangeEvent) => void) {
    this.onDrawingBufferChangedListeners[key] = listener;
  }
  clearOnDrawingBufferChangeListener(key: string) {
    delete this.onDrawingBufferChangedListeners[key];
  }

  callOnImageChangeListeners() {
    Object.values(this.onImageChangedListeners).forEach((listener) => listener({}));
  }

  callOnDrawingBufferChangeListeners() {
    Object.values(this.onDrawingBufferChangedListeners).forEach((listener) => listener({}));
  }

  getWidth = (): number => this.image.width;
  getHeight = (): number => this.image.height;

  public currentDiffAction: DiffAction = { diffs: new Map() };

  addDiffs(diffs: Diff[]) {
    diffs.forEach((d) => this.currentDiffAction.diffs.set(getDiffHash(d), d));
  }

  public registerDiffAction() {
    this.historyManager?.addAction(this.currentDiffAction);
    this.currentDiffAction = { diffs: new Map() };
  }

  public canUndo = () => this.historyManager?.canUndo();
  public canRedo = () => this.historyManager?.canRedo();

  public undo() {
    const undoStart = Date.now();
    const undoedAction = this.historyManager?.undo();
    if (undoedAction === undefined) return;
    setBottomBarText(`undo.`);
    undoedAction.diffs.forEach((diff) => {
      switch (diff.kind) {
        case 'pixel':
          this.setPixelInPosition(diff.position, diff.before, false, false);
          break;
        case 'tile':
          this.undoTileDiff(diff);
          break;
      }
    });
    const undoEnd = Date.now();
    setBottomBarText(`undo done. (${undoedAction.diffs.size} px updated, ${undoEnd - undoStart}ms)`);

    this.callOnImageChangeListeners();
  }

  protected undoTileDiff(tileDiff: TileDiff) {}

  public redo() {
    const redoStart = Date.now();
    const redoedAction = this.historyManager?.redo();
    if (redoedAction === undefined) return;
    setBottomBarText(`redo.`);
    redoedAction.diffs.forEach((diff) => {
      switch (diff.kind) {
        case 'pixel':
          this.setPixelInPosition(diff.position, diff.after, false, false);
          break;
        case 'tile':
          this.redoTileDiff(diff);
          break;
      }
    });
    const redoEnd = Date.now();
    setBottomBarText(`redo done. (${redoedAction.diffs.size} px updated, ${redoEnd - redoStart}ms)`);

    this.callOnImageChangeListeners();
  }

  protected redoTileDiff(tileDiff: TileDiff) {}

  public abstract setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean,
    excludeColorMatch: boolean
  ): PixelDiff | undefined;

  protected setPixelInPosition(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    if (!this.isInBounds(position)) return undefined;
    if (excludePositionMatch && this.currentDiffAction.diffs.has(`${position.x},${position.y}`)) return undefined;
    const i = (position.y * this.getWidth() + position.x) * 4;
    const beforeColor: RGBAColor = [
      this.image.data[i + 0],
      this.image.data[i + 1],
      this.image.data[i + 2],
      this.image.data[i + 3],
    ];
    if (excludeColorMatch && colorMatch(beforeColor, color)) return undefined;

    if (!this.drawingBuffer) return;

    this.drawingBuffer.data[i + 0] = color[0];
    this.drawingBuffer.data[i + 1] = color[1];
    this.drawingBuffer.data[i + 2] = color[2];
    this.drawingBuffer.data[i + 3] = color[3];

    return {
      kind: 'pixel',
      position,
      before: beforeColor,
      after: color,
    };
  }

  public abstract deletePixel(
    position: Vec2,
    excludePositionMatch: boolean,
    excludeColorMatch: boolean
  ): PixelDiff | undefined;

  protected deletePixelInPosition(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.setPixelInPosition(position, [0, 0, 0, 0], excludePositionMatch, excludeColorMatch);
  }

  public abstract getPixel(position: Vec2): RGBAColor;

  public isInBounds(position: Vec2) {
    return position.x >= 0 && position.y >= 0 && position.x < this.getWidth() && position.y < this.getHeight();
  }
}

================
File: src/components/section/Color.tsx
================
import { Component, For } from 'solid-js';
import ColorPicker from '~/components/section/item/ColorPicker';
import ColorBox from '../common/ColorBox';
import Palette from './item/Palette';

import { setCurrentColor } from '~/controllers/color/ColorController';
import { colorStore } from '~/stores/EditorStores';
import { sectionCaption, sectionContent, sectionRoot } from '~/styles/components/globals/section_global.css';
import { swatchContainer } from '~/styles/section/color.css';
import { flexCol } from '~/styles/snippets.css';

const Color: Component = () => {
  const onColorClicked = (color: string, index: number) => {
    setCurrentColor(color);
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>color.</p>
      <div class={sectionContent} style={{ 'flex-direction': 'row', margin: '8px 0' }}>
        <div class={swatchContainer}>
          <For each={colorStore.swatches}>
            {(item, index) => (
              <ColorBox
                color={item}
                sizePx={8}
                onClick={(color) => onColorClicked(color, index())}
                enableUsingSelection={true}
              />
            )}
          </For>
        </div>
        {/* <div class={descriptionContainer}>
          <p class={colorElemDescription}>picker.</p>
        </div> */}
        <div class={flexCol}>
          <ColorPicker width={150} />
          <Palette />
        </div>
      </div>
    </div>
  );
};

export default Color;

================
File: src/components/section/item/LayerItem.tsx
================
import { createSortable, useDragDropContext } from '@thisbeyond/solid-dnd';
import { Component } from 'solid-js';
import Light from '~/components/common/Light';
import { getNextMagnification } from '~/controllers/layer/LayerController';
import { layerListStore, setLayerListStore } from '~/stores/ProjectStores';
import {
  activeLight,
  dotMagnifContainer,
  dotMagnifText,
  layerItem,
  layerItemDisabled,
  layerItemIndex,
  layerItemName,
  layerItemType,
} from '~/styles/section/layer.css';
import { flexRow, w100 } from '~/styles/snippets.css';
import { Layer, LayerType } from '~/types/Layer';
import LayerPreview from '../../common/LayerPreview';

interface LayerItemProps {
  index: number;
  isLast?: boolean;
  layer: Layer;
  draggingId?: string | null;
}

const LayerItem: Component<LayerItemProps> = (props) => {
  const sortable = createSortable(props.layer.id);
  const context = useDragDropContext();
  const state = context?.[0];

  let detClass: 'dot' | 'image' | 'automate' | undefined;
  switch (props.layer.type) {
    case LayerType.Dot:
      detClass = 'dot';
      break;
    case LayerType.Image:
      detClass = 'image';
      break;
    case LayerType.Automate:
      detClass = 'automate';
      break;
  }

  const onDetClicked = () => {
    setLayerListStore('activeLayerId', props.layer.id);
  };

  const onPreviewClicked = () => {
    if (props.index !== -1) {
      setLayerListStore('layers', props.index, 'enabled', (v: boolean) => !v);
    }
  };

  const onMagnifClicked = () => {
    const next = getNextMagnification(props.layer.dotMagnification);
    if (props.index !== -1) {
      setLayerListStore('layers', props.index, 'dotMagnification', next);
    }
  };

  const isActive = () => layerListStore.activeLayerId === props.layer.id;

  return (
    <div
      class={w100}
      classList={{
        'opacity-50': sortable.isActiveDraggable,
        'transition-transform': state && !!state.active.draggable,
      }}
      style={{ opacity: props.draggingId === props.layer.id ? 0.4 : 1 }}
      ref={sortable}
    >
      {/* <DSLButton /> */}
      <div
        class={[layerItem, !props.layer.enabled && layerItemDisabled].filter(Boolean).join(' ')}
        // style={{ 'border-bottom': props.isLast ? 'none' : '1px solid #333' }}
        onClick={onDetClicked}
      >
        <LayerPreview layer={props.layer} onClick={onPreviewClicked} maxHeight={36} maxWidth={36} />

        <div
          class={[flexRow, w100].join(' ')}
          style={{
            'align-items': 'center',
            position: 'relative',
          }}
        >
          <div
            class={flexRow}
            style={{
              top: '2px',
              right: 0,
              left: 0,
              'margin-left': '6px',
              position: 'absolute',
            }}
          >
            <p class={layerItemIndex}>{props.index}.</p>
            <p class={layerItemType}>{props.layer.typeDescription}</p>
          </div>

          <p class={layerItemName}> {props.layer.name}</p>
          <div
            class={dotMagnifContainer}
            onClick={(e) => {
              e.stopPropagation();
              onMagnifClicked();
            }}
            onMouseOver={(e) => e.stopPropagation()}
          >
            <p class={dotMagnifText}>x{props.layer.dotMagnification}</p>
          </div>
          <Light class={activeLight} on={isActive()} />
        </div>
      </div>
    </div>
  );
};

export default LayerItem;

================
File: src/io/project/project.ts
================
import { path } from '@tauri-apps/api';
import { open as dialogOpen, save } from '@tauri-apps/plugin-dialog';
import { BaseDirectory, mkdir, readTextFile, writeTextFile } from '@tauri-apps/plugin-fs';
import { addRecentFile } from '~/controllers/config/GlobalConfigController';
import { findLayerById } from '~/controllers/layer_list/LayerListController';
import { getImageOf } from '~/routes/editor';
import {
  canvasStore,
  layerHistoryStore,
  layerListStore,
  loadStoreFromProjectJson as loadProjectStore,
  projectStore,
  setProjectStore,
} from '~/stores/ProjectStores';
import { encodeImageData } from '~/utils/ImageUtils';
import { getFileNameAndPath } from '~/utils/PathUtils';

export async function importProjectJsonFromFileSelection(): Promise<string | undefined> {
  const home = await path.homeDir();
  const file = await dialogOpen({
    multiple: false,
    directory: false,
    defaultPath: await path.join(home, 'sledge'),
    filters: [
      {
        name: 'sledge files',
        extensions: ['sledge'],
      },
    ],
  });
  if (!file) {
    console.log('file not selected');
    return undefined;
  }

  const jsonText = await readTextFile(file);
  const projectJson = JSON.parse(jsonText);

  loadProjectStore(projectJson);

  return file;
}

export async function importProjectJsonFromPath(filePath: string) {
  if (!filePath) {
    console.log('file not selected');
    return;
  }
  const jsonText = await readTextFile(filePath);
  const projectJson = JSON.parse(jsonText);

  loadProjectStore(projectJson);
}

export const parseCurrentProject = (): string => {
  return JSON.stringify({
    project: projectStore,
    canvas: canvasStore.canvas,
    images: Object.fromEntries(
      Object.entries(layerHistoryStore).map(([id, state]) => {
        const image = getImageOf(id);
        if (!image) return [];
        return [
          id,
          {
            current: encodeImageData(image),
            width: image.width,
            height: image.height,
            dotMagnification: findLayerById(id)?.dotMagnification,
          },
        ];
      })
    ),
    layer: {
      layers: layerListStore.layers.map((layer) => ({
        ...layer,
        dsl: undefined, // TODO: save dsl
      })),
      activeLayerId: layerListStore.activeLayerId,
    },
  });
};

export async function saveProject(existingPath?: string) {
  let selectedPath: string | null;
  if (existingPath) {
    selectedPath = existingPath;
  } else {
    try {
      await mkdir('sledge', {
        baseDir: BaseDirectory.Home,
        recursive: true,
      });
    } catch (e) {
      console.warn('failed or skipped making new directory:', e);
    }

    const home = await path.homeDir();
    selectedPath = await save({
      title: 'save sledge project',
      defaultPath: await path.join(home, `sledge/${projectStore.name}.sledge`),
      filters: [{ name: 'sledge project', extensions: ['sledge'] }],
    });
  }

  if (typeof selectedPath === 'string') {
    setProjectStore('path', selectedPath);
    const data = parseCurrentProject();
    await writeTextFile(selectedPath, data);
    console.log('project saved to:', selectedPath);

    setProjectStore('isProjectChangedAfterSave', false);
    addRecentFile(getFileNameAndPath(selectedPath));
  } else {
    console.log('save cancelled');
  }
}

================
File: src/components/canvas/stacks/LayerCanvas.tsx
================
import { Component, createRenderEffect, onMount, Ref } from 'solid-js';
import LayerImageAgent from '~/models/layer_image/LayerImageAgent';

import { LayerImageManager } from '~/models/layer_image/LayerImageManager';
import { layerImageManager } from '~/routes/editor';
import { canvasStore } from '~/stores/ProjectStores';
import { layerCanvas } from '~/styles/components/canvas/layer_canvas.css';
import { Layer } from '~/types/Layer';

type Props = {
  ref?: LayerCanvasRef;
  layer: Layer;
  zIndex: number;
};

export type LayerCanvasRef = {
  getLayer: () => Layer;
  getManager: () => LayerImageManager;
  getAgent: () => LayerImageAgent;
};

export const LayerCanvas: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;

  const agent = () => layerImageManager.getAgent(props.layer.id);

  createRefContent(
    () => props.ref,
    () => ({
      getLayer() {
        return props.layer;
      },
      getAgent() {
        return agent();
      },
    })
  );

  const styleWidth = () => canvasStore.canvas.width;
  const styleHeight = () => canvasStore.canvas.height;
  const internalWidth = () => canvasStore.canvas.width / props.layer.dotMagnification;
  const internalHeight = () => canvasStore.canvas.height / props.layer.dotMagnification;

  onMount(() => {
    let agent = layerImageManager.getAgent(props.layer.id);
    const ctx = canvasRef?.getContext('2d');

    if (ctx) agent?.putImageIntoForce(ctx);

    agent?.setOnImageChangeListener('layercanvas_refresh_' + props.layer.id, () => {
      if (ctx) agent.putImageIntoForce(ctx);
    });
    agent?.setOnDrawingBufferChangeListener('layercanvas_refresh_' + props.layer.id, () => {
      if (ctx) agent.putDrawingBufferIntoForce(ctx);
    });
  });

  return (
    <canvas
      ref={(el) => {
        canvasRef = el;
      }}
      id={`canvas-${props.layer.id}`}
      data-layer-id={props.layer.name}
      class={layerCanvas}
      width={internalWidth()}
      height={internalHeight()}
      style={{
        position: 'absolute',
        width: `${styleWidth()}px`,
        height: `${styleHeight()}px`,
        'image-rendering': 'pixelated',
        'z-index': props.zIndex,
        opacity: props.layer.enabled ? 1 : 0,
      }}
    />
  );
};

function createRefContent<T extends Exclude<unknown, Function>>(getRef: () => Ref<T>, createRef: () => T) {
  createRenderEffect(() => {
    const refProp = getRef();
    if (typeof refProp !== 'function') {
      throw new Error('Should never happen, as solid always passes refs as functions');
    }

    const refFunc = refProp as (value: T) => void;

    refFunc(createRef());
  });
}

================
File: src/routes/editor/index.tsx
================
import { trackStore } from '@solid-primitives/deep';
import { useLocation } from '@solidjs/router';
import { UnlistenFn } from '@tauri-apps/api/event';
import { getCurrentWebviewWindow } from '@tauri-apps/api/webviewWindow';
import { confirm } from '@tauri-apps/plugin-dialog';
import { createEffect, createSignal, onCleanup, onMount } from 'solid-js';
import CanvasArea from '~/components/canvas/CanvasArea';
import EdgeInfo from '~/components/global/EdgeInfo';
import SideSections from '~/components/global/SideSections';
import { adjustZoomToFit, centeringCanvas, changeCanvasSize } from '~/controllers/canvas/CanvasController';
import { resetLayerImage } from '~/controllers/layer/LayerController';
import { addLayer } from '~/controllers/layer_list/LayerListController';
import { loadGlobalSettings } from '~/io/global_config/globalSettings';
import { importProjectJsonFromPath } from '~/io/project/project';
import { LayerImageManager } from '~/models/layer_image/LayerImageManager';
import { globalStore } from '~/stores/GlobalStores';
import { canvasStore, layerHistoryStore, layerListStore, projectStore, setProjectStore } from '~/stores/ProjectStores';

import { pageRoot } from '~/styles/global.css';
import { LayerType } from '~/types/Layer';
import { closeWindowsByLabel, openStartWindow, WindowOptionsProp } from '~/utils/windowUtils';

export const EditorWindowOptions: WindowOptionsProp = {
  width: 1000,
  height: 750,
  acceptFirstMouse: true,
  resizable: true,
  closable: true,
  maximizable: true,
  minimizable: true,
  decorations: false,
  fullscreen: false,
};

export const layerImageManager = new LayerImageManager();

export const getImageOf = (layerId: string) => layerImageManager.getAgent(layerId)?.getImage();

export default function Editor() {
  const window = getCurrentWebviewWindow();
  const location = useLocation();

  createEffect(() => {
    trackStore(canvasStore.canvas);
    trackStore(layerHistoryStore);
    trackStore(layerListStore);
    setProjectStore('isProjectChangedAfterSave', true);
  });

  const isNewProject = location.search === '';
  const [isLoading, setIsLoading] = createSignal(true);

  const onProjectLoad = async () => {
    setProjectStore('isProjectChangedAfterSave', false);
    setIsLoading(false);

    await loadGlobalSettings();

    if (isNewProject) {
      changeCanvasSize(globalStore.newProjectCanvasSize);
    }

    layerListStore.layers.forEach((layer) => {
      resetLayerImage(layer.id, 1);
    });

    adjustZoomToFit();
    centeringCanvas();
  };

  if (location.search) {
    const sp = new URLSearchParams(location.search);
    const fileName = sp.get('name');
    const filePath = sp.get('path');
    const path = `${filePath}\\${fileName}`;
    importProjectJsonFromPath(path).then(() => {
      onProjectLoad();
    });
  } else {
    // create new
    setProjectStore('name', 'new project');
    addLayer('dot', LayerType.Dot, true, 1).then(() => {
      onProjectLoad();
    });
  }

  const [isCloseRequested, SetIsCloseRequested] = createSignal(false);
  let unlisten: UnlistenFn;

  onMount(async () => {
    unlisten = await window.onCloseRequested(async (event) => {
      if (isCloseRequested()) {
        event.preventDefault();
        return;
      }
      SetIsCloseRequested(true);
      event.preventDefault();
      if (projectStore.isProjectChangedAfterSave) {
        const confirmed = await confirm('the project is not saved.\nsure to quit without save?', {
          okLabel: 'quit w/o save.',
          cancelLabel: 'cancel.',
        });
        if (confirmed) {
          await openStartWindow();
          closeWindowsByLabel('editor');
          SetIsCloseRequested(false);
        } else {
          event.preventDefault();
          SetIsCloseRequested(false);
        }
      } else {
        await openStartWindow();
        closeWindowsByLabel('editor');
        SetIsCloseRequested(false);
      }
    });
  });

  onCleanup(() => {
    unlisten();
  });

  return (
    <>
      {isLoading() && (
        <div class={pageRoot}>
          <p style={{ 'font-size': '2rem' }}>please wait.</p>
        </div>
      )}

      {!isLoading() && (
        <div class={pageRoot}>
          <EdgeInfo />
          <SideSections />
          <div style={{ 'flex-grow': 1 }}>
            <CanvasArea />
          </div>
          {/* <Companion /> */}
        </div>
      )}
    </>
  );
}

================
File: src/components/canvas/stacks/CanvasStack.tsx
================
import { Component, createEffect, createSignal, For, onMount } from 'solid-js';
import LayerCanvasOperator from '~/controllers/canvas/LayerCanvasOperator';
import TileLayerImageAgent from '~/models/layer_image/agents/TileLayerImageAgent';
import CanvasOverlaySVG from './CanvasOverlaySVG';
import { InteractCanvas } from './InteractCanvas';
import { LayerCanvas, LayerCanvasRef } from './LayerCanvas';

import { activeLayer, allLayers } from '~/controllers/layer_list/LayerListController';
import { layerImageManager } from '~/routes/editor';
import { canvasStore } from '~/stores/ProjectStores';
import { canvasStack } from '~/styles/components/canvas/canvas_stack.css';
import Tile from '~/types/Tile';

const CanvasStack: Component = () => {
  const layerCanvasRefs: {
    [id: string]: LayerCanvasRef;
  } = {};

  const [dirtyRects, setDirtyRects] = createSignal<Tile[]>();

  const activeCanvasRef = () => {
    const active = activeLayer();

    if (active) return layerCanvasRefs[active.id];
    else return undefined;
  };

  onMount(() => {
    window.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'z') {
        const active = activeLayer();
        if (active) {
          const agent = layerImageManager.getAgent(active.id);
          agent?.undo();
        }
      } else if (e.ctrlKey && e.key === 'y') {
        const active = activeLayer();
        if (active) {
          const agent = layerImageManager.getAgent(active.id);
          agent?.redo();
        }
      }
    });
  });

  createEffect(() => {
    const active = activeLayer();
    if (active) {
      const agent = layerImageManager.getAgent(active.id);
      if (!agent) return;
      agent.setOnDrawingBufferChangeListener('stack_dirty_rect', () => {
        setDirtyRects([...getDirtyRects()]);
      });
      agent.setOnImageChangeListener('stack_dirty_rect', () => {
        setDirtyRects([...getDirtyRects()]);
      });
    }
  });

  const getDirtyRects = () => {
    const active = activeLayer();
    if (active) {
      const agent = layerImageManager.getAgent(active.id);
      if (agent instanceof TileLayerImageAgent) {
        return (agent as TileLayerImageAgent).getDirtyTilesInAction();
      }
    }
    return [];
  };

  return (
    <div
      style={{
        position: 'relative',
      }}
    >
      <div
        class={canvasStack}
        style={{
          width: `${canvasStore.canvas.width}px`,
          height: `${canvasStore.canvas.height}px`,
        }}
      >
        <InteractCanvas operator={new LayerCanvasOperator(() => activeCanvasRef()!)} />

        <For each={allLayers()}>
          {(layer, index) => (
            <LayerCanvas ref={layerCanvasRefs[layer.id]} layer={layer} zIndex={allLayers().length - index()} />
          )}
        </For>
      </div>

      <CanvasOverlaySVG dirtyRects={dirtyRects()} />
    </div>
  );
};

export default CanvasStack;

================
File: src/app.tsx
================
// @refresh reload
import { MetaProvider } from '@solidjs/meta';
import { Route, Router } from '@solidjs/router';
import { Suspense } from 'solid-js';
import TitleBar from './components/global/TitleBar';
import Home from './routes';
import About from './routes/about';
import Editor from './routes/editor';

import Settings from './routes/settings';
import { flexCol, h100 } from './styles/snippets.css';

export default function App() {
  return (
    <Router
      root={(props) => (
        <MetaProvider>
          <title>Sledge</title>
          <div class={[flexCol, h100].join(' ')}>
            <TitleBar />

            <Suspense>
              <main>{props.children}</main>
            </Suspense>

            {/* <p class={sledgeLogo}>sledge.</p> */}
          </div>
        </MetaProvider>
      )}
    >
      <Route path='/' component={Home} />
      <Route path='/editor' component={Editor} />
      <Route path='/settings' component={Settings} />
      <Route path='/about' component={About} />;
    </Router>
  );
}

================
File: src/components/section/CanvasSettings.tsx
================
import { Component } from 'solid-js';
import { adjustZoomToFit, changeCanvasSize } from '~/controllers/canvas/CanvasController';
import { resetLayerImage } from '~/controllers/layer/LayerController';
import { canvasStore, layerListStore, setCanvasStore } from '~/stores/ProjectStores';

import { sectionCaption, sectionContent, sectionRoot } from '~/styles/components/globals/section_global.css';
import { canvasSizeButton, canvasSizeForm, canvasSizeInput, canvasSizeLabel } from '~/styles/section/canvas.css';
import { Consts } from '~/utils/consts';

const CanvasSettings: Component = () => {
  const onSizeChange = (type: 'width' | 'height', value: number) => {
    if (type === 'width') {
      setCanvasStore('canvas', 'width', value);
      changeCanvasSize({ width: value, height: canvasStore.canvas.height });
    } else {
      setCanvasStore('canvas', 'height', value);
      changeCanvasSize({ width: canvasStore.canvas.width, height: value });
    }

    console.log(`canvas size changed. ${canvasStore.canvas.width} x ${canvasStore.canvas.height}`);

    adjustZoomToFit();
  };

  const resetAllLayers = (e: any) => {
    layerListStore.layers.forEach((l) => {
      resetLayerImage(l.id, l.dotMagnification);
    });
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>canvas.</p>

      <form class={sectionContent} onSubmit={(e) => e.preventDefault()}>
        <div class={canvasSizeForm}>
          <div>
            <p class={canvasSizeLabel}>width</p>
            <input
              class={canvasSizeInput}
              type='number'
              name='width'
              onChange={(e) => {
                e.preventDefault();
                onSizeChange('width', Number(e.target.value));
              }}
              value={canvasStore.canvas.width}
              min={Consts.minCanvasWidth}
              max={Consts.maxCanvasWidth}
              required
            />
          </div>
          <div>
            <p class={canvasSizeLabel}>height</p>
            <input
              class={canvasSizeInput}
              type='number'
              name='height'
              onChange={(e) => {
                e.preventDefault();
                onSizeChange('height', Number(e.target.value));
              }}
              value={canvasStore.canvas.height}
              min={Consts.minCanvasHeight}
              max={Consts.maxCanvasHeight}
              required
            />
          </div>
          <button class={canvasSizeButton} type='submit'>
            change
          </button>
        </div>
      </form>

      <button class={canvasSizeButton} onClick={resetAllLayers}>
        RESET ALL LAYERS
      </button>
    </div>
  );
};

export default CanvasSettings;

================
File: package.json
================
{
  "name": "sledge",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "tauri:dev": "tauri dev",
    "tauri:build": "tauri build",
    "tcm-watch": "tcm -o dist-tcm src --watch",
    "postinstall": "patch-package",
    "prettier": "prettier --write 'src/**/*.{ts,tsx,css,module.css}' --config .prettierrc",
    "stylelint": "stylelint -c .\\.stylelintrc.json \"src/**/*.css\" --fix"
  },
  "dependencies": {
    "@jaames/iro": "^5.5.2",
    "@solid-primitives/deep": "^0.3.1",
    "@solid-primitives/timer": "^1.4.0",
    "@solidjs/meta": "^0.29.4",
    "@solidjs/router": "^0.15.0",
    "@tauri-apps/api": "^2.4.1",
    "@tauri-apps/plugin-dialog": "^2.2.1",
    "@tauri-apps/plugin-fs": "^2.2.1",
    "@tauri-apps/plugin-shell": "^2.2.1",
    "@thisbeyond/solid-dnd": "^0.7.5",
    "@vanilla-extract/css": "^1.17.1",
    "@vanilla-extract/recipes": "^0.5.5",
    "interactjs": "^1.10.27",
    "solid-js": "^1.9.5",
    "solidjs-use": "^2.3.0",
    "tauri-plugin-system-info-api": "^2.0.10",
    "uuid": "^11.1.0"
  },
  "engines": {
    "node": ">=22"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2.4.1",
    "@vanilla-extract/vite-plugin": "^5.0.1",
    "patch-package": "^8.0.0",
    "prettier": "^3.5.3",
    "prettier-plugin-organize-imports": "^4.1.0",
    "solid-refresh": "^0.7.5",
    "stylelint": "^16.18.0",
    "stylelint-config-standard": "^38.0.0",
    "stylelint-order": "^6.0.4",
    "vite": "^6.3.3",
    "vite-plugin-solid": "^2.11.6",
    "vite-tsconfig-paths": "^5.1.4"
  }
}

================
File: src/components/canvas/CanvasArea.tsx
================
import { createMemo, onCleanup, onMount } from 'solid-js';
import CanvasAreaInteract from '../../controllers/canvas/CanvasAreaInteract';
import CanvasControls from './CanvasControls';
import CanvasStack from './stacks/CanvasStack';

import { adjustZoomToFit, centeringCanvas } from '~/controllers/canvas/CanvasController';
import { interactStore, setInteractStore } from '~/stores/EditorStores';
import { canvasArea } from '~/styles/components/canvas/canvas_area.css';
import BottomInfo from '../global/BottomInfo';
import CanvasDebugOverlay from './CanvasDebugOverlay';

export default () => {
  let wrapper: HTMLDivElement;
  let canvasStack: HTMLDivElement;

  const interact: CanvasAreaInteract = new CanvasAreaInteract();

  onMount(() => {
    // set Canvas to center
    setInteractStore('canvasAreaSize', {
      width: wrapper.clientWidth,
      height: wrapper.clientHeight,
    });
    adjustZoomToFit();
    centeringCanvas();

    interact.setInteractListeners(wrapper, canvasStack);
  });

  onCleanup(() => {
    if (interact !== undefined) {
      interact.removeInteractListeners(wrapper, canvasStack);
    }
  });

  const offsetX = () => interactStore.offsetOrigin.x + interactStore.offset.x;
  const offsetY = () => interactStore.offsetOrigin.y + interactStore.offset.y;

  const transform = createMemo(() => {
    return `translate(${offsetX()}px, ${offsetY()}px) scale(${interactStore.zoom})`;
  });

  return (
    <div class={canvasArea}>
      <div
        id='zoompan-wrapper'
        ref={(el) => {
          wrapper = el;
        }}
        style={{
          display: 'flex',
          position: 'absolute',
          top: 0,
          left: 0,
          padding: 0,
          margin: 0,
          width: '100%',
          height: '100%',
          overflow: 'hidden',
          'touch-action': 'none',
        }}
      >
        <div
          ref={(el) => (canvasStack = el)}
          style={{
            width: 'fit-content',
            height: 'fit-content',
            padding: 0,
            margin: 0,
            'transform-origin': '0 0',
            transform: transform(),
          }}
        >
          <CanvasStack />
        </div>
      </div>

      <CanvasDebugOverlay />
      <CanvasControls />
      <BottomInfo />
    </div>
  );
};

================
File: src/routes/index.tsx
================
import { For, onMount } from 'solid-js';
import { addRecentFile } from '~/controllers/config/GlobalConfigController';
import { loadGlobalSettings } from '~/io/global_config/globalSettings';
import { importProjectJsonFromFileSelection } from '~/io/project/project';
import { globalStore, setGlobalStore } from '~/stores/GlobalStores';
import { sectionRoot } from '~/styles/components/globals/section_global.css';
import { flexCol, flexRow, w100 } from '~/styles/snippets.css';
import { FileLocation } from '~/types/FileLocation';
import { getFileNameAndPath } from '~/utils/PathUtils';
import { closeWindowsByLabel, openEditorWindow, openSingletonWindow, WindowOptionsProp } from '~/utils/windowUtils';
import { SettingsWindowOptions } from './settings';
import {
  recentFilesCaption,
  recentFilesContainer,
  recentFilesItem,
  recentFilesName,
  recentFilesPath,
  sideSection,
  sideSectionItem,
  welcomeHeadline,
  welcomeRoot,
} from './start.css';

export const StartWindowOptions: WindowOptionsProp = {
  title: 'sledge',
  width: 700,
  height: 500,
  acceptFirstMouse: true,
  resizable: false,
  parent: undefined,
  closable: true,
  maximizable: true,
  minimizable: true,
  decorations: false,
  fullscreen: false,
};

export default function Home() {
  onMount(() => {
    loadGlobalSettings();
  });

  const moveToEditor = (selectedFile: FileLocation) => {
    openEditorWindow(selectedFile);
    closeWindowsByLabel('start');
  };

  const createNew = () => {
    openEditorWindow();
    closeWindowsByLabel('start');
  };

  const openProject = () => {
    importProjectJsonFromFileSelection().then((file: string | undefined) => {
      if (file !== undefined) {
        const loc = getFileNameAndPath(file);
        addRecentFile(loc);
        openEditorWindow(loc);
        closeWindowsByLabel('start');
      }
    });
  };

  const clearRecentFiles = () => {
    setGlobalStore('recentFiles', []);
  };

  return (
    <div class={welcomeRoot}>
      <div class={flexCol}>
        <p class={welcomeHeadline}>HELLO.</p>
        <div class={sideSection}>
          <a class={sideSectionItem} onClick={() => createNew()}>
            +&ensp;new.
          </a>
          <a class={sideSectionItem} style={{ 'margin-left': '2px' }} onClick={(e) => openProject()}>
            &gt;&ensp;open.
          </a>
          <a
            class={sideSectionItem}
            style={{ 'margin-left': '2px' }}
            onClick={(e) => openSingletonWindow('settings', SettingsWindowOptions)}
          >
            <img src={'/settings.png'} width={16} height={16} />
            &ensp;settings.
          </a>
        </div>

        <div class={sectionRoot}>
          <div class={[flexRow, w100].join(' ')}>
            <p class={recentFilesCaption}>recent files.</p>
            {/* <p class={clear} onClick={() => clearRecentFiles()}>
                clear
              </p> */}
          </div>
          <div class={recentFilesContainer} style={{ 'margin-bottom': '24px' }}>
            <For each={globalStore.recentFiles}>
              {(item, i) => {
                return (
                  <div class={recentFilesItem}>
                    <p>■</p>
                    <a class={recentFilesName} onClick={(e) => moveToEditor(item)}>
                      {item.name}
                    </a>
                    <p class={recentFilesPath}>{item.path}</p>
                  </div>
                );
              }}
            </For>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================================
End of Codebase
================================================================
