This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------
User Provided Header:
-----------------------
REPOMIX output file

================================================================
Directory Structure
================================================================
.gitignore
.repomix/bundles.json
.repomixignore
.stylelintrc.json
dist-tcm/styles/canvas/canvas_stack.module.css.d.ts
dist-tcm/styles/canvas/controls.module.css.d.ts
dist-tcm/styles/components/canvas/canvas_stack.module.css.d.ts
dist-tcm/styles/components/canvas/controls.module.css.d.ts
dist-tcm/styles/components/canvas/image_pool.module.css.d.ts
dist-tcm/styles/components/canvas/layer_canvas.module.css.d.ts
dist-tcm/styles/components/companion.module.css.d.ts
dist-tcm/styles/components/dsl_button.module.css.d.ts
dist-tcm/styles/components/edge_info.module.css.d.ts
dist-tcm/styles/components/layer_preview.module.css.d.ts
dist-tcm/styles/components/light.module.css.d.ts
dist-tcm/styles/components/side_sections.module.css.d.ts
dist-tcm/styles/components/slider.module.css.d.ts
dist-tcm/styles/components/toast.module.css.d.ts
dist-tcm/styles/reset.css.d.ts
dist-tcm/styles/section.css.d.ts
dist-tcm/styles/utils.css.d.ts
dist-tcm/styles/ve/canvas/canvas_stack.module.css.d.ts
dist-tcm/styles/ve/canvas/controls.module.css.d.ts
DSL_doc_jp.md
index.html
package.json
patches/@thisbeyond+solid-dnd+0.7.5.patch
public/fonts/k8x12/k8x12.txt
public/fonts/k8x12/readme.txt
public/fonts/terminus/COPYING
README.md
repomix.config.json
src-tauri/.gitignore
src-tauri/build.rs
src-tauri/capabilities/default.json
src-tauri/Cargo.toml
src-tauri/src/commands/base64_utils.rs
src-tauri/src/commands/brightness.rs
src-tauri/src/commands/grayscale.rs
src-tauri/src/commands/invert.rs
src-tauri/src/commands/jpeg_glitch.rs
src-tauri/src/commands/mod.rs
src-tauri/src/commands/sepia.rs
src-tauri/src/lib.rs
src-tauri/src/main.rs
src-tauri/src/pipeline/mod.rs
src-tauri/src/pipeline/parser.rs
src-tauri/src/pipeline/runner.rs
src-tauri/src/standalone/flood_fill_raw.rs
src-tauri/src/standalone/flood_fill.rs
src-tauri/src/standalone/mod.rs
src-tauri/tauri.conf.json
src/app.tsx
src/components/BottomInfo.tsx
src/components/canvas/CanvasArea.tsx
src/components/canvas/CanvasAreaInteract.tsx
src/components/canvas/Controls.tsx
src/components/canvas/stacks/CanvasOverlaySVG.tsx
src/components/canvas/stacks/CanvasStack.tsx
src/components/canvas/stacks/ImagePool.tsx
src/components/canvas/stacks/LayerCanvas.tsx
src/components/canvas/stacks/TouchableCanvas.tsx
src/components/common/ColorBox.tsx
src/components/common/companion/Companion.tsx
src/components/common/companion/QuotePool.ts
src/components/common/Dropdown.tsx
src/components/common/DSLButton.tsx
src/components/common/DSLEditor.tsx
src/components/common/ImportImageButton.tsx
src/components/common/LayerPreview.tsx
src/components/common/Light.tsx
src/components/common/Slider.tsx
src/components/common/ToggleSwitch.tsx
src/components/EdgeInfo.tsx
src/components/section/CanvasSettings.tsx
src/components/section/Color.tsx
src/components/section/GlobalSettings.tsx
src/components/section/item/ColorPicker.tsx
src/components/section/item/LayerItem.tsx
src/components/section/item/PenItem.tsx
src/components/section/LayerList.tsx
src/components/section/PenConfig.tsx
src/components/section/Project.tsx
src/components/SideSections.tsx
src/components/TitleBar.tsx
src/components/ToastContainer.tsx
src/io/global/globalIO.ts
src/io/internal/export.ts
src/io/internal/import.ts
src/io/project/project.ts
src/main.tsx
src/models/dsl/DSL.ts
src/models/dsl/DSLRunner.ts
src/models/dsl/nodes/AvailableNodes.ts
src/models/dsl/nodes/DSLNodes.ts
src/models/dsl/nodes/effect/Brightness.ts
src/models/dsl/nodes/effect/EffectNode.ts
src/models/dsl/nodes/effect/GrayScale.ts
src/models/dsl/nodes/effect/Invert.ts
src/models/dsl/nodes/effect/Sepia.ts
src/models/dsl/nodes/fracture/FractureNode.ts
src/models/dsl/nodes/fracture/JpegGlitch.ts
src/models/dsl/nodes/pass/LayerIn.ts
src/models/dsl/nodes/pass/LayerOut.ts
src/models/dsl/nodes/pass/PassNode.ts
src/models/factories/addLayer.ts
src/models/factories/canvasPreview.ts
src/models/factories/createLayer.ts
src/models/factories/createPen.ts
src/models/factories/removeLayer.ts
src/models/factories/utils.ts
src/models/layer_canvas/DrawState.ts
src/models/layer_canvas/LayerCanvasOperator.ts
src/models/layer_image/agents/RawLayerImageAgent.ts
src/models/layer_image/agents/TileLayerImageAgent.ts
src/models/layer_image/HistoryManager.ts
src/models/layer_image/LayerImageAgent.ts
src/models/layer_image/LayerImageManager.ts
src/models/layer_image/Tile.ts
src/models/layer/layerImage.ts
src/models/tools/DrawUtils.ts
src/models/tools/eraser/EraserTool.ts
src/models/tools/fill/FillTool.ts
src/models/tools/fill/LegacyFills.ts
src/models/tools/fill/PixelFloodFill.ts
src/models/tools/fill/TileFloodFill.ts
src/models/tools/pen/PenTool.ts
src/models/tools/ToolBase.ts
src/models/types/Canvas.ts
src/models/types/Layer.ts
src/models/types/LayerImage.ts
src/models/types/Tool.ts
src/models/types/Vector.ts
src/routes/[...404].tsx
src/routes/editor/index.tsx
src/routes/index.tsx
src/routes/start.css.ts
src/stores/global/globalStore.ts
src/stores/internal/colorStore.ts
src/stores/internal/toastStore.ts
src/stores/internal/toolsStore.ts
src/stores/project/canvasStore.ts
src/stores/project/layerImageStore.ts
src/stores/project/layerStore.ts
src/stores/project/projectStore.ts
src/styles/components/bottom_info.css.ts
src/styles/components/canvas/canvas_area.css.ts
src/styles/components/canvas/canvas_stack.module.css
src/styles/components/canvas/controls.module.css
src/styles/components/canvas/image_pool.module.css
src/styles/components/canvas/layer_canvas.css.ts
src/styles/components/companion.module.css
src/styles/components/dropdown.css.ts
src/styles/components/dsl_button.module.css
src/styles/components/edge_info.module.css
src/styles/components/layer_preview.module.css
src/styles/components/light.module.css
src/styles/components/side_sections.module.css
src/styles/components/slider.module.css
src/styles/components/title_bar.css.ts
src/styles/components/toast.module.css
src/styles/components/toggle_switch.css.ts
src/styles/global.css.ts
src/styles/reset.css.ts
src/styles/section_global.css.ts
src/styles/section/canvas.css.ts
src/styles/section/color.css.ts
src/styles/section/layer.css.ts
src/styles/section/pen.css.ts
src/styles/section/project.css.ts
src/styles/snippets.css.ts
src/utils/colorUtils.ts
src/utils/DSLUtils.ts
src/utils/ImageUtils.ts
src/utils/pathUtils.ts
src/utils/tauriUtils.ts
todo_dsl.md
todo.md
tsconfig.json
tslint.json
vite.config.js

================================================================
Files
================================================================

================
File: public/fonts/k8x12/k8x12.txt
================
===============================================================================

                8×12 ドット日本語ビットマップフォント「k8x12」
                                (2021-05-05 版)

                       Copyright (C) 2015-2021 Num Kadoma

===============================================================================

-------------------------------------------------------------------------------
 概要
-------------------------------------------------------------------------------
　k8x12 は 8×12 ドットの日本語ビットマップフォントです。
　JIS 第一・第二水準をサポートしており、その他の記号も一部含んでいます。


-------------------------------------------------------------------------------
 バリエーション
-------------------------------------------------------------------------------
　オリジナルの k8x12 の他に、
　バリエーションとして k8x12L, k8x12S が存在します。
　漢字の字形はこれらすべてで共通です (仝々〆〇 を含む)。

・k8x12L
　k8x12L は k8x12 の仮名を縦に長い形に変更したものです。
　漢字同様に下端に空白を 1 ラインとった残りの縦 11 ドットを使っています。

・k8x12S
　k8x12S は k8x12 の非漢字を縦 8 ドットの字形に変更したものです。
　濁点、半濁点は仮名の上に乗る形になっています。
　このバリエーションは、8×8 ドット単位でグラフィックを扱うような、
　昔のゲーム機やマイコンにおける制限を意識しています。
　
　文字の枠を 8×12 ではなく 8×16 ドットに広げた方がより「らしく」なりますが、
　フォントとしての使い勝手を考えてそのままにしています。


-------------------------------------------------------------------------------
 備考
-------------------------------------------------------------------------------
・縦書きには未対応です。


-------------------------------------------------------------------------------
 ライセンス
-------------------------------------------------------------------------------
　These fonts are free software.
　Unlimited permission is granted to use, copy, and distribute them, with or without modification, either commercially or noncommercially.
　THESE FONTS ARE PROVIDED "AS IS" WITHOUT WARRANTY.

　これらのフォントはフリー（自由な）ソフトウエアです。
　あらゆる改変の有無に関わらず、また商業的な利用であっても、自由にご利用、複製、再配布することができますが、全て無保証とさせていただきます。


-------------------------------------------------------------------------------
 制作履歴
-------------------------------------------------------------------------------
■2021-05-05
・文字の追加: ␣
・字形の修正・変更:
　*售堕寉寓崔帯廼滞焦瞿矍臭蕉隹隻隼雀集雋霍
　(k8x12S のみ)│┃┌┏┐┓└┗┘┛├┝┠┣┤┥┨┫┬┯┰┳┴┷┸┻┼┿╂╋╞╡╪╭╮╯╰ホ
・[TTF] ビットマップを埋込み
・[BDF] アーカイブ形式を zip に変更

■2017-02-20
・「8」を首の細長い形状に変更 (「0」との誤認対策)

■2016-08-27
・「莱」の字形が「菜」になっている問題を修正

■2015-01-29
・[TTF] Windows 環境で文字幅が広がってしまう問題を修正

■2015-01-28
・初版公開

■2014-12-09
・JIS 第二水準漢字が揃う

■2014-08-初～11-初
・(休憩)

■2014-08-08
・JIS 第一水準漢字が揃う

■2014-07-06
・制作開始


-------------------------------------------------------------------------------
 バージョン情報
-------------------------------------------------------------------------------
■2021-05-05
・k8x12 2017-05-05 版 (BDF/TTF/PNG)

■2017-02-20
・k8x12 2017-07-20 版 (BDF/TTF/PNG)

■2016-08-27
・k8x12 2016-08-27 版 (BDF/TTF/PNG)

■2015-01-29
・k8x12 2015-01-29 版 (TTF)

■2015-01-28
・k8x12 2015-01-28 版 (BDF/TTF/PNG)


-------------------------------------------------------------------------------
 連絡先
-------------------------------------------------------------------------------
　門真 なむ (Num Kadoma)
　・Twitter: @num_kadoma
　・Website: http://littlelimit.net/

================
File: public/fonts/k8x12/readme.txt
================
===============================================================================

                                  k8x12 TTF 版

===============================================================================

-------------------------------------------------------------------------------
 概要
-------------------------------------------------------------------------------
　k8x12 TTF 版は TrueType 形式の等幅フォントです。
　k8x12 のアウトラインと埋込みビットマップを含んでいます。


-------------------------------------------------------------------------------
 アーカイブの内容
-------------------------------------------------------------------------------
・k8x12.txt
　k8x12 のマニュアル

・readme.txt
　k8x12 TTF 版のマニュアル (このファイル)

・k8x12.ttf
　k8x12 TTF 版 (Regular)

・k8x12L.ttf
　k8x12L TTF 版 (Regular)

・k8x12S.ttf
　k8x12S TTF 版 (Regular)


-------------------------------------------------------------------------------
 ライセンス
-------------------------------------------------------------------------------
　アーカイブ同梱の「k8x12.txt」の内容に従うものとします。

================
File: src/components/common/Dropdown.tsx
================
import { Component, JSX } from "solid-js";
import { dropdownRoot } from "~/styles/components/dropdown.css";

export type DropdownOption<T extends string | number> = {
    label: string;
    value: T;
};

interface Props<T extends string | number = string> {
    /** 現在選択中の値 */
    value: T;
    /** 選択候補 */
    options: DropdownOption<T>[];
    /** 値変更時に呼び出される */
    onChange?: (value: T) => void;
    /** aria-label など任意で渡す */
    props?: JSX.SelectHTMLAttributes<HTMLSelectElement>;
}

const Dropdown = <T extends string | number>(p: Props<T>) => (
    /* コンポーネント外でも使うので export default */
    <select
        {...p.props}
        class={dropdownRoot}
        value={String(p.value)}
        onChange={(e) => p.onChange?.(e.currentTarget.value as unknown as T)}
    >
        {p.options.map((o) => (
            <option value={String(o.value)}>{o.label}</option>
        ))}
    </select>
);

export default Dropdown;

================
File: src/components/common/ToggleSwitch.tsx
================
import { Component } from "solid-js";
import {
    toggleWrapper,
    toggleTrack,
    toggleThumb,
    toggleInput,
} from "~/styles/components/toggle_switch.css";

interface Props {
    checked: boolean;
    onChange?: (checked: boolean) => void;
    /** 任意でラベル等を配置する場合の slot */
    children?: any;
}

const ToggleSwitch: Component<Props> = (p) => (
    /* label 全体でクリック可能に */
    <label class={toggleWrapper}>
        <input
            type="checkbox"
            checked={p.checked}
            onInput={(e) => p.onChange?.(e.currentTarget.checked)}
            class={toggleInput}
        />
        <span class={toggleTrack}>
            <span class={toggleThumb} />
        </span>
        {p.children}
    </label>
);

export default ToggleSwitch;

================
File: src/components/section/GlobalSettings.tsx
================
import { Component, createSignal } from "solid-js";
import { setCurrentToolColor } from "~/models/types/Tool";
import {
    sectionCaption,
    sectionRoot,
} from "~/styles/section_global.css";
import Dropdown, { DropdownOption } from "../common/Dropdown";
import ToggleSwitch from "../common/ToggleSwitch";
import { CanvasRenderingMode, globalStore, setGlobalStore } from "~/stores/global/globalStore";

const renderingOptions: DropdownOption<CanvasRenderingMode>[] = [
    { label: "auto", value: "auto" },
    { label: "pixelated", value: 'pixelated' },
    { label: "crispEdges", value: 'crispEdges' },
];

const [autoSave, setAutoSave] = createSignal(true);

const GlobalSettings: Component<{}> = (props) => {


    return (
        <div class={sectionRoot}>
            <p class={sectionCaption}>settings.</p>
            <Dropdown
                value={globalStore.canvasRenderingMode}
                options={renderingOptions}
                onChange={(v) => setGlobalStore("canvasRenderingMode", v)}
            />

            <ToggleSwitch checked={autoSave()} onChange={setAutoSave}>
                <p style={{ "font-size": "0.5rem" }}>autosave.</p>
            </ToggleSwitch>
        </div>
    );
};

export default GlobalSettings;

================
File: src/models/tools/pen/PenTool.ts
================
import { Tool, ToolArgs } from '../ToolBase'
import { drawCompletionLine, drawSquarePixel } from '../DrawUtils'
import LayerImageAgent from '~/models/layer_image/LayerImageAgent'
import { PixelDiff } from '~/models/layer_image/HistoryManager'
import { Vec2 } from '~/models/types/Vector'

export class PenTool implements Tool {
  onStart(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }

  onMove(
    agent: LayerImageAgent,
    { position, lastPosition, color, size }: ToolArgs
  ) {
    if (!size) return false

    drawSquarePixel(position, size, (px, py) => {
      const diff = agent.setPixel({ x: px, y: py }, color, true, true)
      if (diff !== undefined) {
        agent.addDiffs([diff])
      }
    })

    if (lastPosition !== undefined) {
      drawCompletionLine(position, lastPosition, (x, y) => {
        drawSquarePixel({ x, y }, size, (px, py) => {
          const diff = agent.setPixel({ x: px, y: py }, color, true, true)
          if (diff !== undefined) {
            agent.addDiffs([diff])
          }
        })
      })
    }

    return true
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }
}

================
File: src/styles/components/canvas/layer_canvas.css.ts
================
import { recipe } from '@vanilla-extract/recipes'

export const layerCanvas = recipe({
  base: {
    pointerEvents: 'none',
    position: 'absolute',
  },

  variants: {
    rendering: {
      auto: {
        imageRendering: 'auto',
      },
      pixelated: {
        imageRendering: 'pixelated',
      },
      crispEdges: {
        imageRendering: 'crisp-edges',
      },
    },
    hidden: {
      true: {
        opacity: 0,
        pointerEvents: 'auto',
      },
    },
  },

  defaultVariants: {
    rendering: 'auto',
    hidden: false,
  },
})

================
File: src/styles/components/dropdown.css.ts
================
import { style } from '@vanilla-extract/css'
import { vars } from '~/styles/global.css'

export const dropdownRoot = style({
  fontFamily: vars.font.body,
  fontSize: vars.text.lg,
  backgroundColor: vars.color.secondary,
  border: '0px solid black',
  borderRadius: '0px',
  padding: '2px 6px',
  height: '20px',
  cursor: 'pointer',
  lineHeight: '12px',
  selectors: {
    '&:hover': { backgroundColor: vars.color.button_hover },
    '&:active': {
      backgroundColor: vars.color.button_pressed,
    },
    /* Windows の ▼ 矢印が滲むのを抑止 */
    '&::-ms-expand': { display: 'none' },
  },
})

================
File: src/styles/components/toggle_switch.css.ts
================
import { style, globalStyle } from '@vanilla-extract/css'
import { vars } from '~/styles/global.css'

const globalWidth = 16
const thumbWidth = 8
const thumbPadding = 2
const globalHeight = 12

/* ラベル全体 */
export const toggleWrapper = style({
  display: 'inline-flex',
  alignItems: 'center',
  gap: vars.spacing.sm,
  cursor: 'pointer',
  userSelect: 'none',
})

/* 入力本体 (隠す) */
export const toggleInput = style({
  opacity: 0,
  width: 0,
  height: 0,
  position: 'absolute',
})

/* バックグラウンドとなるトラック */
export const toggleTrack = style({
  width: `${globalWidth}px`,
  height: `${globalHeight}px`,
  backgroundColor: vars.color.muted,
  border: '1px solid black',
  borderRadius: '0px',
  position: 'relative',
  transition: 'background-color 0.05s',
})

/* つまみ */
export const toggleThumb = style({
  position: 'absolute',
  top: '-1px',
  left: '0px',
  width: `${thumbWidth - thumbPadding}px`,
  height: `${globalHeight}px`,
  backgroundColor: vars.color.button,
  border: '1px solid black',
  borderRadius: '0px',
  transition: 'transform 0.05s',
})

/* ───────── 状態連動スタイル ───────── */

/* input が :checked のとき隣接する track を赤系へ */
globalStyle(`${toggleInput}:checked + ${toggleTrack}`, {
  backgroundColor: vars.color.danger,
})

/* さらに thumb を右へスライド */
globalStyle(`${toggleInput}:checked + ${toggleTrack} ${toggleThumb}`, {
  transform: `translateX(${globalWidth - thumbWidth}px)`,
})

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: .repomixignore
================
node_modules
public/libs

================
File: dist-tcm/styles/canvas/canvas_stack.module.css.d.ts
================
declare const styles: {
  readonly "canvas_stack": string;
  readonly "image-container": string;
  readonly "resize-image": string;
};
export = styles;

================
File: dist-tcm/styles/canvas/controls.module.css.d.ts
================
declare const styles: {
  readonly "bottom-history": string;
  readonly "cursor": string;
  readonly "history-row": string;
  readonly "history-text": string;
  readonly "top-right-button-container": string;
  readonly "top-right-nav": string;
  readonly "undo_redo": string;
};
export = styles;

================
File: dist-tcm/styles/components/canvas/image_pool.module.css.d.ts
================
declare const styles: {
  readonly "image-container": string;
  readonly "resize-drag-container": string;
};
export = styles;

================
File: dist-tcm/styles/components/canvas/layer_canvas.module.css.d.ts
================
declare const styles: {
  readonly "dev-hint": string;
  readonly "hidden": string;
  readonly "layer-canvas": string;
};
export = styles;

================
File: dist-tcm/styles/components/dsl_button.module.css.d.ts
================
declare const styles: {
  readonly "root": string;
};
export = styles;

================
File: dist-tcm/styles/components/edge_info.module.css.d.ts
================
declare const styles: {
  readonly "root": string;
  readonly "text": string;
};
export = styles;

================
File: dist-tcm/styles/components/layer_preview.module.css.d.ts
================
declare const styles: {
  readonly "canvas": string;
  readonly "wrapper": string;
};
export = styles;

================
File: dist-tcm/styles/components/light.module.css.d.ts
================
declare const styles: {
  readonly "light-inner": string;
  readonly "on": string;
};
export = styles;

================
File: dist-tcm/styles/components/side_sections.module.css.d.ts
================
declare const styles: {
  readonly "content": string;
};
export = styles;

================
File: dist-tcm/styles/components/slider.module.css.d.ts
================
declare const styles: {
  readonly "handle": string;
  readonly "handle-hitbox": string;
  readonly "line": string;
  readonly "line-hitbox": string;
  readonly "root": string;
  readonly "slider": string;
};
export = styles;

================
File: dist-tcm/styles/components/toast.module.css.d.ts
================
declare const styles: {
  readonly "close_persistent_button": string;
  readonly "error": string;
  readonly "fade-in-out-bottom": string;
  readonly "fade-in-out-top": string;
  readonly "info": string;
  readonly "success": string;
  readonly "toast": string;
  readonly "toastContainer": string;
  readonly "toast_root": string;
  readonly "warn": string;
};
export = styles;

================
File: dist-tcm/styles/section.css.d.ts
================
declare const styles: {
  readonly "section_caption": string;
  readonly "section_content": string;
  readonly "section_root": string;
};
export = styles;

================
File: dist-tcm/styles/utils.css.d.ts
================
declare const styles: {
  readonly "fl-col": string;
  readonly "fl-row": string;
};
export = styles;

================
File: dist-tcm/styles/ve/canvas/canvas_stack.module.css.d.ts
================
declare const styles: {
  readonly "canvas_stack": string;
  readonly "image-container": string;
  readonly "resize-image": string;
};
export = styles;

================
File: dist-tcm/styles/ve/canvas/controls.module.css.d.ts
================
declare const styles: {
  readonly "bottom-history": string;
  readonly "cursor": string;
  readonly "history-row": string;
  readonly "history-text": string;
  readonly "top-right-button-container": string;
  readonly "top-right-nav": string;
  readonly "undo_redo": string;
};
export = styles;

================
File: DSL_doc_jp.md
================
# DSL (Data Shaping Lines)

`version:` v.pre-alpha-0.1\
`author:` innsbluck

## 定義

DSL (Data Shaping Lines) とは、2次元の画像データを高速かつフレキシブルに処理するためのsledge独自の言語および記法です。

主に以下のような用途で使用されます。

1. 各レイヤーの色調補正・エフェクト追加。
2. インポートした画像の色調補正・エフェクト追加。
3. 別のレイヤーから参照した情報(side-chain)を用いたエフェクト処理。
4. 各レイヤーを合成し、１枚の画像にまとめる。

1、2，3 のような要素ごとに対するエフェクト処理のほか、4のようなペイントソフトの根幹とも言える**レイヤー合成と出力画像の生成処理**であっても、DSLを用いて記述できます。

> 1、2，3 のような各レイヤーや要素のみに機能するDSLを`Layer-level DSL (LDSL)`と呼びます。\
> 4 のように、レイヤー等を取りまとめて一枚の画像に集約するDSLを`Image-level DSL (IDSL)`と呼びます。

## 記法

> ここでは、DSL＝`Layer-level DSL`であるものとして解説します。

### 概念

DSLは、一言で表すなら **「2次元画像データのストリーム」** です。

```bash
in
> contrast(50%)
> invert()
> brightness(-40%)
> jpeg_glitch(40, 90, 0.001) > out;
```

入力ポート(`in`)から入力された画像データは様々なエフェクトを通過し、
最終的にエフェクトが適用された画像データが出力ポート(`out`)に送信されます。

この`in`と`out`にあたる入力元と送信先は、画像データでさえあれば**なんでも**指定できます。

例えばレイヤーの加工においては、\
入力ポート(`in`)はエフェクト適用前のレイヤーの画像データであり、\
出力ポート(`out`)はプレビューやエクスポートに使用されるレイヤーの「表示先」を意味します。

> DSLの思想や構文は、以下の概念に大きく影響を受けています。
>
> - Linuxのshellにおけるパイプライン
> - DAW(digital audio workstation)におけるFXチェーン、サイドチェイン

### 基本構造

DSLの記法には、関数・クラスの定義やブロック、スコープといった概念は存在しません。

ユーザーは`node`と呼ばれるエフェクトコマンドを選択し、それらをレイヤーの入出力の間に追加していくことで、エフェクトの逐次処理を簡潔かつ直感的に記述できます。

例えば、「レイヤー0の画像のコントラストを50%上げて、色を反転させる」というエフェクトは、以下のような`DSLScript`で記述できます。

```bash
inout layer_0;

in > contrast(50%) > invert() > out;
```

この`DSLScript`は

- 入出力レイヤーの指定(`inout`, `in`, `out`)
- エフェクトの`node`(`contrast(50%)`, `invert()`)
- 各`node`間の区切り文字 `>`
- 各行の区切り文字 `;`

で構成されています。

本章で登場する`DSLScript`は、この4要素を覚えておけば直感的に理解できます。

### 即時性と追従性

上記の例で注目すべき点は、`>`で繋がれたパイプラインが示す通り、この記述は一回適用して終わる使い捨てのエフェクトではない、という点です。

> **`DSLScript`はレイヤー内容の更新に即座に追従して描画状態を更新します。** \
> また、`DSLScript`における`node`の追加/編集/削除も、エフェクトの変更として即座に描画に反映されます。

`inout`は、エフェクトの入力元レイヤーおよび出力先レイヤーを示します。

`inout`は`in`と`out`宣言をまとめたものであり、主に色調補正などの**あるレイヤーの情報が、同レイヤーの出力を決定する**ような効果を記述する場合は、`inout`が使えます。

### レイヤー間のやりとり

入力元と出力先のレイヤーが異なる場合、`inout`の代わりに`in`と`out`宣言を分けて使用できます。以下は、**元絵に追従するグロー効果**のサンプルです。

```bash
in layer_main;　# 元絵レイヤー
out layer_blur; # ぼかし用レイヤー(元絵の下)

blank() > out; #グロー効果用のレイヤーを初期化
in > blur(3px) > out; #元絵を3pxぼかした画像をlayer_blurに出力
```

この`DSLScript`により、ユーザーが`layer_main`に描いた絵は即座に処理され、
ぼかしを入れた元絵がlayer_blurに入ります。

このように、sledgeの`DSL`では**あるレイヤーから得た情報を別のレイヤーに出力することもできます。**

グロー効果の他にも、

- 自由なレイヤーでのクリッピング
- レイヤーから抜き出した主要な色をカラーパレットとして別レイヤーに出力

など、他のペイントソフトでは手動で行うであろう複雑な操作も、`DSLScript`で記述することで保守性を保ちつつも自動化することができます。

> これらの複雑なエフェクトも、**後から変更可能**かつ**関係するレイヤー・画像の変化に自動で追従**して適用されます。

## 各種ノード: node

> 各nodeの詳細については DSL_nodes_doc_jp.md を参照して下さい。

## 一時メモリ: subout

### 概要

`subout`は、一言で表せばDSLにおける「変数」です。
もう少し詳しく言うならば、入出力の結果を一時的に保存する「画像のメモリ」ともいえます。

`subout`は主にデータの分配や分岐に使用されます。
そのほか、範囲分割系の`node`においては`multi(subout_area, subout_outside)`のように**複数の分割された画像の一時保存先**としても使用できます。

### 宣言

`subout`の宣言は`in`, `out`の宣言とパイプライン記述の間で行われます。`init`ステートメントの後にsubout名を記述することで**キャンバスと同サイズの画像データがメモリ上に確保されます**。

```bash
inout layer_0;
init temp_out;

in > temp_out;
temp_out > out;
```

上記の`DSLScript`は実際のところ何の影響も及ぼしません。すなわち、この処理における`in`, `temp_out`, `out`は全て全く同じピクセルデータを持つ画像データを示します。
initialization)のための構文として、実装が検討されています。

## 高度な入出力: in(layer_x), multi(*o1, *o2, ...)

> in(layer_x)もしくはout(layer_x)は`in`, `out`ステートメントで宣言されたレイヤー**以外**のレイヤーの入出力を実現するノードです。**現行のバージョンでは実装の予定はありません**。代わりに、複数の空レイヤー及びDSLを用いて擬似的に表現することを検討して下さい。

### multi(*o1, *o2, ...)

`multi`ノードは出力先として機能するという点で`out`や`subout`に近いですが、
**入力された複数の画像データを複数のsuboutに出力する**役割を持ちます。

`multi`ノードを使用するケースとして最も一般的なのは、`splitV`といった**分割系**のnodeが出力する、範囲/範囲外の2つの出力をそれぞれキャッチし、別々にエフェクト処理を行うケースです。

```bash
inout layer_1;

init merged;

init upper;
init lower;

# 画像の上半分がupper、下半分がlowerにそれぞれ格納される
in(layer_1) > splitV(50%) > multiout(upper, lower);

upper > jpeg_glitch(9, 72) > merged;
lower > invert() > merged;

merged > out(layer_1);
```

## アサーションとディレクティブ

### アサーション

> 現行バージョンでは実装されません。

アサーションは、主にモジュール化を目的とする`DSLScript`コードの保守、テストのために用いられます。例えば、subout等がinitステートメントによって正常に初期化されているかをテストし、実行用とは異なるテスト用のインタプリタ(DSL Test Runner)でこれを実行することで、`DSLScript`が望んだ動作を行うことを検証できます。

```bash
@exist subout1;
```

### ディレクティブ

ディレクティブが提供する機能は、保守・テスト用のアサーションに比べて実際の実行に寄った役割があります。具体的には、

- 全体、行、ノードごとでのログ出力（sledge内のデバッグコンソールで閲覧可能）
- 既に内容があるsuboutにさらに出力を送信した際の挙動(`combine mode`)の定義

などがあります。以下は、ディレクティブを使ったログ出力と挙動設定の例です。

```bash
inout layer_1;

[combine=stack-up] # 既存のピクセルの上に上書き
# [combine=stack-down] # 既存のピクセルの下に上書き
init merged;

init upper;
init lower;

[log_trace_line] # 下の1行の中間ログを出力
in(layer_1) > splitV(50%) > multiout(upper, lower);
upper > jpeg_glitch(9, 72) > merged;
lower > invert() > merged;
merged > out(layer_1);
```

上記の例における`log_trace_line`が出力するログには各ノードの出力結果が**画像として**含まれますが、sledgeの内部デバッグコンソールは文字情報と同時にこれらの画像を出力できるよう最適化されています。

## 検討されている機能

### unused subout omitter

`DSLScript`には`subout`が本来不要か、もしくは短縮できるケースが存在します。

```bash
inout layer_0;
init temp_out;

in > temp_out;
temp_out > out;
```

そこで、省略可能な部分を自動で検知し、`in > out`のような形へ最適化する機能(unused subout omitter)が検討されています。

### instant subout initialization

`*subout`は`init`ステートメントを使わない即時宣言(instant subout initialization)の方法として検討されています。

```bash
in > splitV(30%) > multi(*upper ,*lower);
```

================
File: patches/@thisbeyond+solid-dnd+0.7.5.patch
================
diff --git a/node_modules/@thisbeyond/solid-dnd/dist/dev.js b/node_modules/@thisbeyond/solid-dnd/dist/dev.js
index c4cce69..0578068 100644
--- a/node_modules/@thisbeyond/solid-dnd/dist/dev.js
+++ b/node_modules/@thisbeyond/solid-dnd/dist/dev.js
@@ -1084,7 +1084,8 @@ var combineRefs = (setRefA, setRefB) => {
 // src/create-sortable.ts
 var createSortable = (id, data = {}) => {
   const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();
-  const [sortableState] = useSortableContext();
+  const context = useSortableContext();
+const sortableState = context?.[0];;
   const draggable = createDraggable(id, data);
   const droppable = createDroppable(id, data);
   const setNode = combineRefs(draggable.ref, droppable.ref);
diff --git a/node_modules/@thisbeyond/solid-dnd/dist/dev.jsx b/node_modules/@thisbeyond/solid-dnd/dist/dev.jsx
index b06d7fc..81d48fb 100644
--- a/node_modules/@thisbeyond/solid-dnd/dist/dev.jsx
+++ b/node_modules/@thisbeyond/solid-dnd/dist/dev.jsx
@@ -1083,7 +1083,8 @@ var combineRefs = (setRefA, setRefB) => {
 // src/create-sortable.ts
 var createSortable = (id, data = {}) => {
   const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();
-  const [sortableState] = useSortableContext();
+  const context = useSortableContext();
+const sortableState = context?.[0];;
   const draggable = createDraggable(id, data);
   const droppable = createDroppable(id, data);
   const setNode = combineRefs(draggable.ref, droppable.ref);
diff --git a/node_modules/@thisbeyond/solid-dnd/dist/index.js b/node_modules/@thisbeyond/solid-dnd/dist/index.js
index ccc5acb..3938d5c 100644
--- a/node_modules/@thisbeyond/solid-dnd/dist/index.js
+++ b/node_modules/@thisbeyond/solid-dnd/dist/index.js
@@ -1077,7 +1077,8 @@ var combineRefs = (setRefA, setRefB) => {
 // src/create-sortable.ts
 var createSortable = (id, data = {}) => {
   const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();
-  const [sortableState] = useSortableContext();
+  const context = useSortableContext();
+const sortableState = context?.[0];;
   const draggable = createDraggable(id, data);
   const droppable = createDroppable(id, data);
   const setNode = combineRefs(draggable.ref, droppable.ref);
diff --git a/node_modules/@thisbeyond/solid-dnd/dist/index.jsx b/node_modules/@thisbeyond/solid-dnd/dist/index.jsx
index 54348fe..ec85440 100644
--- a/node_modules/@thisbeyond/solid-dnd/dist/index.jsx
+++ b/node_modules/@thisbeyond/solid-dnd/dist/index.jsx
@@ -1070,7 +1070,8 @@ var combineRefs = (setRefA, setRefB) => {
 // src/create-sortable.ts
 var createSortable = (id, data = {}) => {
   const [dndState, { addTransformer, removeTransformer }] = useDragDropContext();
-  const [sortableState] = useSortableContext();
+  const context = useSortableContext();
+const sortableState = context?.[0];;
   const draggable = createDraggable(id, data);
   const droppable = createDroppable(id, data);
   const setNode = combineRefs(draggable.ref, droppable.ref);

================
File: public/fonts/terminus/COPYING
================
Copyright (c) 2010 Dimitar Toshkov Zhekov,
with Reserved Font Name "Terminus Font".

Copyright (c) 2011-2023 Tilman Blumenbach,
with Reserved Font Name "Terminus (TTF)".

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL

---

## SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded,
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1. Neither the Font Software nor any of its individual components,
   in Original or Modified Versions, may be sold by itself.

2. Original or Modified Versions of the Font Software may be bundled,
   redistributed and/or sold with any software, provided that each copy
   contains the above copyright notice and this license. These can be
   included either as stand-alone text files, human-readable headers or
   in the appropriate machine-readable metadata fields within text or
   binary files as long as those fields can be easily viewed by the user.

3. No Modified Version of the Font Software may use the Reserved Font
   Name(s) unless explicit written permission is granted by the corresponding
   Copyright Holder. This restriction only applies to the primary font name as
   presented to the users.

4. The name(s) of the Copyright Holder(s) or the Author(s) of the Font
   Software shall not be used to promote, endorse or advertise any
   Modified Version, except to acknowledge the contribution(s) of the
   Copyright Holder(s) and the Author(s) or with their explicit written
   permission.

5. The Font Software, modified or unmodified, in part or in whole,
   must be distributed entirely under this license, and must not be
   distributed under any other license. The requirement for fonts to
   remain under this license does not apply to any document created
   using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

================
File: repomix.config.json
================
{
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "compress": false,
    "headerText": "REPOMIX output file",
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "showLineNumbers": false
  },
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true
  }
}

================
File: src-tauri/.gitignore
================
# Generated by Cargo
# will have compiled files and executables
/target/
/gen/schemas

================
File: src-tauri/build.rs
================
fn main() {
  tauri_build::build()
}

================
File: src-tauri/src/commands/base64_utils.rs
================
use base64::engine::general_purpose::STANDARD;
use base64::prelude::*;

pub fn decode_image_base64(encoded: &str) -> Result<Vec<u8>, String> {
    STANDARD.decode(encoded).map_err(|e| e.to_string())
}

pub fn encode_image_base64(data: &[u8]) -> Result<String, String> {
    Ok(STANDARD.encode(data))
}

================
File: src-tauri/src/main.rs
================
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    app_lib::run();
}

================
File: src-tauri/src/pipeline/mod.rs
================
pub mod parser;
pub mod runner;

pub use parser::*;
pub use runner::*;

================
File: src-tauri/src/standalone/flood_fill_raw.rs
================
use serde_bytes::ByteBuf;

#[tauri::command]
pub fn flood_fill_raw(
    image: ByteBuf,
    width: usize,
    height: usize,
    x: usize,
    y: usize,
    new_color: [u8; 4],
) -> Result<ByteBuf, String> {
    let mut image = image.into_vec();
    let mut visited = vec![false; width * height];
    let mut stack = Vec::with_capacity(4096);

    let idx = |x, y| (y * width + x) * 4;

    if x >= width || y >= height {
        return Err("start point out of bounds".to_string());
    }

    let ti = idx(x, y);
    let target = [image[ti], image[ti + 1], image[ti + 2], image[ti + 3]];

    if target == new_color {
        return Ok(ByteBuf::from(image));
    }

    stack.push((x, y));
    while let Some((cx, cy)) = stack.pop() {
        if cx >= width || cy >= height {
            continue;
        }
        let i = idx(cx, cy);
        if visited[cy * width + cx] {
            continue;
        }
        if image[i..i + 4] != target {
            continue;
        }

        image[i..i + 4].copy_from_slice(&new_color);
        visited[cy * width + cx] = true;

        if cx > 0 {
            stack.push((cx - 1, cy));
        }
        if cx + 1 < width {
            stack.push((cx + 1, cy));
        }
        if cy > 0 {
            stack.push((cx, cy - 1));
        }
        if cy + 1 < height {
            stack.push((cx, cy + 1));
        }
    }

    Ok(ByteBuf::from(image))
}

================
File: src-tauri/src/standalone/flood_fill.rs
================
use crate::commands::{decode_image_base64, encode_image_base64};

#[tauri::command]
pub fn flood_fill(
    encoded: String,
    width: usize,
    height: usize,
    x: usize,
    y: usize,
    new_color: [u8; 4],
) -> Result<String, String> {
    let mut image = decode_image_base64(&encoded)?;

    let mut visited = vec![false; width * height];
    let mut stack = Vec::with_capacity(4096);

    let idx = |x, y| (y * width + x) * 4;

    // ここで事前にターゲット色をコピー（借用を解決）
    let ti = idx(x, y);
    let target = [image[ti], image[ti + 1], image[ti + 2], image[ti + 3]];

    if target == new_color {
        return encode_image_base64(&image);
    }

    stack.push((x, y));
    while let Some((cx, cy)) = stack.pop() {
        if cx >= width || cy >= height {
            continue;
        }
        let i = idx(cx, cy);
        if visited[cy * width + cx] {
            continue;
        }
        if image[i..i + 4] != target {
            continue;
        }

        image[i..i + 4].copy_from_slice(&new_color);
        visited[cy * width + cx] = true;

        if cx + 1 < width {
            stack.push((cx + 1, cy));
        }
        if cx >= 1 {
            stack.push((cx - 1, cy));
        }
        if cy + 1 < height {
            stack.push((cx, cy + 1));
        }
        if cy >= 1 {
            stack.push((cx, cy - 1));
        }
    }

    encode_image_base64(&image)
}

================
File: src-tauri/src/standalone/mod.rs
================
pub mod flood_fill;
pub mod flood_fill_raw;

pub use flood_fill::flood_fill;
pub use flood_fill_raw::flood_fill_raw;

================
File: src/components/BottomInfo.tsx
================
import { Component, createSignal } from "solid-js";

import {
  bottomInfoRoot,
  bottomInfoText as bottomInfoTextStyle,
} from "~/styles/components/bottom_info.css";

const [bottomInfoText, setBottomInfoText] = createSignal("");

const BottomInfo: Component<{}> = (props) => {
  return (
    <div class={bottomInfoRoot}>
      <p class={bottomInfoTextStyle}>sledge.</p>
      &nbsp;
      <p class={bottomInfoTextStyle}>{bottomInfoText()}</p>
      {/* <p class={sideAreaEdgeText}>{projectStore.name || "name N/A"}</p> */}
    </div>
  );
};

export const setBottomInfo = (text: string) => {
  setBottomInfoText(text);
};

export default BottomInfo;

================
File: src/components/common/LayerPreview.tsx
================
import { Component, createEffect, onMount } from "solid-js";
import { Layer } from "~/models/types/Layer";

import styles from "@styles/components/layer_preview.module.css";
import { layerImageStore } from "~/stores/project/layerImageStore";
import { layerImageManager } from "../canvas/stacks/CanvasStack";
import { v4 as uuidv4 } from "uuid";

interface Props {
  layer: Layer;
  maxWidth?: number;
  maxHeight?: number;
  onClick?: () => void;
}

const LayerPreview: Component<Props> = (props: Props) => {
  const id = uuidv4();
  let wrapperRef: HTMLDivElement;
  let canvasRef: HTMLCanvasElement;

  const updatePreview = (originalImage: ImageData, targetHeight: number) => {
    const aspectRatio = originalImage.width / originalImage.height;
    const targetWidth = Math.round(targetHeight * aspectRatio);

    // 描画対象キャンバスの解像度とCSSサイズを一致させる
    canvasRef.width = targetWidth;
    canvasRef.height = targetHeight;

    const maxWidth = props.maxWidth
    const maxHeight = props.maxHeight
    let zoom = 1;
    // if (maxWidth && targetWidth > maxWidth) zoom = maxWidth / targetWidth;
    // if (maxHeight && targetHeight > maxHeight && zoom < maxHeight / targetHeight) zoom = maxHeight / targetHeight;

    canvasRef.style.width = `${targetWidth * zoom}px !important`;
    canvasRef.style.height = `${targetHeight * zoom}px !important`;

    wrapperRef.style.width = `${targetWidth * zoom}px !important`;
    wrapperRef.style.height = `${targetHeight * zoom}px !important`;

    const tmpCanvas = document.createElement("canvas");
    tmpCanvas.width = originalImage.width;
    tmpCanvas.height = originalImage.height;
    tmpCanvas.getContext("2d")!.putImageData(originalImage, 0, 0);

    const ctx = canvasRef.getContext("2d")!;
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, targetWidth, targetHeight);

    ctx.drawImage(
      tmpCanvas,
      0,
      0,
      originalImage.width,
      originalImage.height,
      0,
      0,
      targetWidth,
      targetHeight,
    );
  };

  onMount(() => {
    const agent = layerImageManager.getAgent(props.layer.id)
    agent?.setOnImageChangeListener("layer_preview_" + id, () => {
      const height = wrapperRef.clientHeight;
      updatePreview(agent.getImage(), height);
    })
  })

  return (
    <div ref={(el) => (wrapperRef = el)}>
      <canvas
        class={styles.canvas}
        ref={(el) => (canvasRef = el)}
        onClick={(e) => {
          if (props.onClick) props.onClick()
        }
        } />
    </div>
  );
};

export default LayerPreview;

================
File: src/models/dsl/nodes/AvailableNodes.ts
================
import { SledgeNode } from "./DSLNodes";
import { Brightness } from "./effect/Brightness";
import { GrayScale } from "./effect/GrayScale";
import { Invert } from "./effect/Invert";
import { Sepia } from "./effect/Sepia";
import { JpegGlitch } from "./fracture/JpegGlitch";

export const ALL_NODES: SledgeNode[] = [
  // effect
  new Brightness(),
  new GrayScale(),
  new Invert(),
  new Sepia(),
  // pass
  // new LayerIn(""),
  // new LayerOut(""),
  // fracture
  new JpegGlitch(),
];

================
File: src/models/dsl/nodes/DSLNodes.ts
================
// 旧
// export enum ImageCommands {
//   INVERT = "invert",
//   GRAYSCALE = "grayscale",
//   GLITCH = "glitch",
//   SEPIA = "sepia",
//   BRIGHTNESS = "brightness",
// }
// export type ImageCommandParams =
//   | {
//       command:
//         | ImageCommands.INVERT
//         | ImageCommands.GRAYSCALE
//         | ImageCommands.SEPIA;
//     }
//   | { command: ImageCommands.BRIGHTNESS; delta: number };

export type NodeType = "effect" | "pass" | "fracture";

export interface NodeArg {
  name: string;
  default: number | string | undefined;
}

export abstract class SledgeNode {
  abstract name: string;
  abstract type: NodeType;
  abstract description: string;

  constructor() {}

  // error occured = undefined
  abstract getNodeString(): string | undefined;
}

================
File: src/models/dsl/nodes/effect/Brightness.ts
================
import { EffectNode } from "./EffectNode";

export class Brightness extends EffectNode {
  name: string = "brightness";
  description: string = "brightness";

  constructor(private delta: number = 30) {
    super();
  }

  getNodeString(): string {
    return `${this.name}(${this.delta})`;
  }
}

================
File: src/models/dsl/nodes/effect/EffectNode.ts
================
import { NodeType, SledgeNode } from "../DSLNodes";

export abstract class EffectNode extends SledgeNode {
  type: NodeType = "effect";
}

================
File: src/models/dsl/nodes/effect/GrayScale.ts
================
import { EffectNode } from "./EffectNode";

export class GrayScale extends EffectNode {
  name: string = "grayscale";
  description: string = "grayscale";

  getNodeString(): string {
    return `${this.name}()`;
  }
}

================
File: src/models/dsl/nodes/effect/Invert.ts
================
import { EffectNode } from "./EffectNode";

export class Invert extends EffectNode {
  name: string = "invert";
  description: string = "invert";

  getNodeString(): string {
    return `${this.name}()`;
  }
}

================
File: src/models/dsl/nodes/effect/Sepia.ts
================
import { EffectNode } from "./EffectNode";

export class Sepia extends EffectNode {
  name: string = "sepia";
  description: string = "sepia";

  getNodeString(): string {
    return `${this.name}()`;
  }
}

================
File: src/models/dsl/nodes/fracture/FractureNode.ts
================
import { NodeType, SledgeNode } from "../DSLNodes";

export abstract class FractureNode extends SledgeNode {
  type: NodeType = "fracture";
}

================
File: src/models/dsl/nodes/fracture/JpegGlitch.ts
================
import { FractureNode } from "./FractureNode";

export class JpegGlitch extends FractureNode {
  name = "jpeg_glitch";
  description = "JPEG glitch effect using random byte corruption";

  private seed = Math.floor(Math.random() * 100);
  private quality = 90;
  private amount = 0.001; // 2%の破壊

  getNodeString(): string {
    return `${this.name}(${this.seed}, ${this.quality}, ${this.amount})`;
  }
}

================
File: src/models/dsl/nodes/pass/LayerIn.ts
================
import { PassNode } from "./PassNode";

export class LayerIn extends PassNode {
  name: string = "in";
  description: string = "layer_in";

  constructor(public layerId?: string) {
    super();
  }

  getNodeString(): string | undefined {
    if (!this.layerId) return undefined;
    return `${this.name}(${this.layerId})`;
  }
}

================
File: src/models/dsl/nodes/pass/LayerOut.ts
================
import { PassNode } from "./PassNode";

export class LayerOut extends PassNode {
  name: string = "out";
  description: string = "out";

  constructor(public layerId?: string) {
    super();
  }

  getNodeString(): string | undefined {
    if (!this.layerId) return undefined;
    return `${this.name}(${this.layerId})`;
  }
}

================
File: src/models/dsl/nodes/pass/PassNode.ts
================
import { NodeType, SledgeNode } from "../DSLNodes";

export abstract class PassNode extends SledgeNode {
  type: NodeType = "pass";
}

================
File: src/models/layer_canvas/DrawState.ts
================
export enum DrawState {
  start,
  move,
  end,
}

================
File: src/models/tools/DrawUtils.ts
================
import { Vec2 } from '../types/Vector'

export function drawSquarePixel(
  p: Vec2,
  size: number,
  drawFn: (x: number, y: number) => void
) {
  const half = Math.floor(size / 2)
  for (let dy = -half; dy <= half; dy++) {
    for (let dx = -half; dx <= half; dx++) {
      drawFn(p.x + dx, p.y + dy)
    }
  }
}

export function drawCompletionLine(
  p0: Vec2,
  p1: Vec2,
  draw: (x: number, y: number) => void
) {
  const dx = Math.abs(p1.x - p0.x)
  const dy = Math.abs(p1.y - p0.y)
  const sx = p0.x < p1.x ? 1 : -1
  const sy = p0.y < p1.y ? 1 : -1
  let err = dx - dy

  while (true) {
    draw(p0.x, p0.y)
    if (p0.x === p1.x && p0.y === p1.y) break
    const e2 = 2 * err
    if (e2 > -dy) {
      err -= dy
      p0.x += sx
    }
    if (e2 < dx) {
      err += dx
      p0.y += sy
    }
  }
}

================
File: src/models/tools/fill/LegacyFills.ts
================
import { safeInvoke } from '~/utils/tauriUtils'
import { ToolArgs } from '../ToolBase'
import { colorMatch, getPixel, isInBounds } from './FillTool'
import { decodeImageData, encodeImageData, setPixel } from '~/utils/ImageUtils'

function legacyFloodFillJS({ image, position, lastPosition, color }: ToolArgs) {
  const targetColor = getPixel(image, position.x, position.y)
  const matches = (p: [number, number]) =>
    colorMatch(getPixel(image, p[0], p[1]), targetColor)

  const startTimeLegacy = Date.now()
  const queueLegacy: [number, number][] = [[position.x, position.y]]
  const filledLegacy: [number, number][] = []
  const visitedLegacy = new Set<string>()

  while (queueLegacy.length > 0) {
    const [cx, cy] = queueLegacy.pop()!
    const key = `${cx},${cy}`
    if (visitedLegacy.has(key) || !isInBounds(image, cx, cy)) continue
    visitedLegacy.add(key)
    if (matches([cx, cy])) {
      filledLegacy.push([cx, cy])
      queueLegacy.push([cx + 1, cy])
      queueLegacy.push([cx - 1, cy])
      queueLegacy.push([cx, cy + 1])
      queueLegacy.push([cx, cy - 1])
    }
  }
  const endTimeLegacy = Date.now()
  console.log('legacy: ' + (endTimeLegacy - startTimeLegacy))

  // バッファに一括反映
  for (const [px, py] of filledLegacy) {
    setPixel(image, px, py, color[0], color[1], color[2], color[3])
  }
}

function legacyBase64Rust({ image, position, lastPosition, color }: ToolArgs) {
  const targetColor = getPixel(image, position.x, position.y)
  const matches = (p: [number, number]) =>
    colorMatch(getPixel(image, p[0], p[1]), targetColor)
  ;(async () => {
    const startTime = Date.now()
    const result = await safeInvoke('flood_fill', {
      encoded: encodeImageData(image),
      width: image.width,
      height: image.height,
      x: position.x,
      y: position.y,
      newColor: color,
    })

    // 結果を ImageData に復元
    const resultImage = decodeImageData(
      result as string,
      image.width,
      image.height
    )
    // image = resultImage
    const endTime = Date.now()
    console.log('rust(old, base64): ' + (endTime - startTime))
  })()
}

function legacyByteBufRust({ image, position, lastPosition, color }: ToolArgs) {
  const targetColor = getPixel(image, position.x, position.y)
  const matches = (p: [number, number]) =>
    colorMatch(getPixel(image, p[0], p[1]), targetColor)
  ;(async () => {
    const startTime = Date.now()
    const result = await safeInvoke('flood_fill_raw', {
      image: Array.from(image.data),
      width: image.width,
      height: image.height,
      x: position.x,
      y: position.y,
      newColor: color,
    })

    // 結果（Uint8Array）を ImageData に復元
    const resultImage = new ImageData(
      new Uint8ClampedArray(result as number[]),
      image.width,
      image.height
    )
    // image = resultImage
    const endTime = Date.now()
    console.log('rust(raw, ByteBuf): ' + (endTime - startTime))
  })()
}

================
File: src/models/tools/fill/PixelFloodFill.ts
================
import { PixelDiff } from '~/models/layer_image/HistoryManager'
import { Vec2 } from '~/models/types/Vector'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'
import { Fill, FillProps } from './FillTool'

export class PixelFloodFill implements Fill {
  fill({ agent, color, position }: FillProps) {
    const targetColor = agent.getPixel(position)
    const matches = (p: Vec2) => colorMatch(agent.getPixel(p), targetColor)

    console.log(color)
    console.log(targetColor)

    if (colorMatch(targetColor, color)) return false

    // console.log(`---${image.width}x${image.height} flood fill---`)

    if (colorMatch(targetColor, color)) return false
    console.log('fill started.')

    const scanStart = Date.now()
    const queue: Vec2[] = [position]
    const filled: Vec2[] = []
    const visited = new Uint8Array(agent.getWidth() * agent.getHeight()) // 0:未訪問, 1:訪問済
    const index = (p: Vec2) => p.y * agent.getWidth() + p.x
    let queueCount = 0
    let visitCount = 0
    while (queue.length > 0) {
      queueCount++
      const c = queue.pop()!
      if (!agent.isInBounds(c)) continue

      const i = index(c)
      if (visited[i]) continue
      visited[i] = 1
      visitCount++

      if (matches(c)) {
        filled.push(c)
        queue.push({ x: c.x + 1, y: c.y })
        queue.push({ x: c.x - 1, y: c.y })
        queue.push({ x: c.x, y: c.y + 1 })
        queue.push({ x: c.x, y: c.y - 1 })
      }
    }

    const scanEnd = Date.now()
    console.log('scan finished. ' + (scanEnd - scanStart) + 'ms.')

    const writeStart = Date.now()

    const pxDiffs: PixelDiff[] = []
    // バッファに一括反映
    for (const p of filled) {
      const diff = agent.setPixel(p, color, false, false)
      if (diff !== undefined) pxDiffs.push(diff)
    }
    const writeEnd = Date.now()
    console.log('write finished. ' + (writeEnd - writeStart) + 'ms.')

    agent.addDiffs(pxDiffs)
  }
}

================
File: src/models/tools/fill/TileFloodFill.ts
================
import { PixelDiff } from '~/models/layer_image/HistoryManager'
import { Vec2 } from '~/models/types/Vector'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'
import { Fill, FillProps } from './FillTool'
import TileLayerImageAgent from '~/models/layer_image/agents/TileLayerImageAgent'
import Tile, { TileIndex } from '~/models/layer_image/Tile'

interface FillPassProps {
  index: TileIndex
}

export class TileFloodFill implements Fill {
  fill({ agent, color, position }: FillProps) {
    if (!(agent instanceof TileLayerImageAgent))
      throw 'Agent is not a TileLayerImageAgent'
    const tileAgent = agent as TileLayerImageAgent

    const targetColor = tileAgent.getPixel(position)
    if (colorMatch(targetColor, color)) return false

    const tileRowCount = tileAgent.getTileRowCount()
    const tileColumnCount = tileAgent.getTileColumnCount()
    const flatten = (ti: TileIndex) => ti.row * tileColumnCount + ti.column
    const tileUniformMatches = (ti: TileIndex) => {
      const tile = tileAgent.getTile(ti)
      return (
        tile.isUniform &&
        tile.uniformColor &&
        colorMatch(tile.uniformColor, targetColor)
      )
    }

    const visitedTiles = new Uint8Array(tileRowCount * tileColumnCount)
    const tilesFilled: TileIndex[] = []
    const tileQueue: TileIndex[] = [tileAgent.getTileIndex(position)]

    const pxDiffs: PixelDiff[] = []
    const visitedPx = new Uint8Array(agent.getWidth() * agent.getHeight())

    // First tile flood pass
    let tileFillCount = 0
    while (tileQueue.length > 0) {
      const ti = tileQueue.pop()!
      if (!tileAgent.isTileInBounds(ti)) continue
      const i = flatten(ti)
      if (visitedTiles[i]) continue
      visitedTiles[i] = 1
      if (!tileUniformMatches(ti)) continue

      tilesFilled.push(ti)
      tileFillCount++
      tileQueue.push({ row: ti.row - 1, column: ti.column })
      tileQueue.push({ row: ti.row + 1, column: ti.column })
      tileQueue.push({ row: ti.row, column: ti.column - 1 })
      tileQueue.push({ row: ti.row, column: ti.column + 1 })
    }
    for (const ti of tilesFilled) {
      const offset = tileAgent.getTile(ti).getOffset()
      for (let dy = 0; dy < tileAgent.TILE_SIZE; dy++) {
        for (let dx = 0; dx < tileAgent.TILE_SIZE; dx++) {
          const x = offset.x + dx
          const y = offset.y + dy
          const i = y * agent.getWidth() + x
          visitedPx[i] = 1
        }
      }
    }
    console.log(`initial tile fill finished: ${tileFillCount} tiles`)

    const edgePixels =
      tilesFilled.length > 0 ?
        this.collectEdgePixels(tileAgent, tilesFilled)
      : [position]

    const pixelQueue: Vec2[] = edgePixels
    const pixelsFilled: Vec2[] = []
    const pxIndex = (p: Vec2) => p.y * agent.getWidth() + p.x

    let pixelFillCount = 0
    while (pixelQueue.length > 0) {
      const p = pixelQueue.pop()!
      if (!agent.isInBounds(p)) continue
      const idx = pxIndex(p)
      if (visitedPx[idx]) continue
      visitedPx[idx] = 1

      const tileIndex = tileAgent.getTileIndex(p)
      const tileIdxFlat = flatten(tileIndex)
      const tilesFilledInReEntry: TileIndex[] = []
      if (!visitedTiles[tileIdxFlat] && tileUniformMatches(tileIndex)) {
        const reentryQueue: TileIndex[] = [tileIndex]
        let reentryCount = 0
        while (reentryQueue.length > 0) {
          const ti = reentryQueue.pop()!
          if (!tileAgent.isTileInBounds(ti)) continue
          const i = flatten(ti)
          if (visitedTiles[i]) continue
          visitedTiles[i] = 1
          if (!tileUniformMatches(ti)) continue
          tilesFilled.push(ti)
          tilesFilledInReEntry.push(ti)
          reentryCount++
          reentryQueue.push({ row: ti.row - 1, column: ti.column })
          reentryQueue.push({ row: ti.row + 1, column: ti.column })
          reentryQueue.push({ row: ti.row, column: ti.column - 1 })
          reentryQueue.push({ row: ti.row, column: ti.column + 1 })
        }
        // ↓ 前はこれがなかった ↓
        const newEdges = this.collectEdgePixels(tileAgent, tilesFilledInReEntry)
        for (const edge of newEdges) {
          pixelQueue.push(edge)
        }
        for (const ti of tilesFilled) {
          const offset = tileAgent.getTile(ti).getOffset()
          for (let dy = 0; dy < tileAgent.TILE_SIZE; dy++) {
            for (let dx = 0; dx < tileAgent.TILE_SIZE; dx++) {
              const x = offset.x + dx
              const y = offset.y + dy
              const i = y * agent.getWidth() + x
              visitedPx[i] = 1
            }
          }
        }
        console.log(`tile reentry fill: ${reentryCount} tiles`)
        continue
      }

      if (!colorMatch(tileAgent.getPixel(p), targetColor)) continue
      pixelsFilled.push(p)
      pixelFillCount++
      pixelQueue.push({ x: p.x + 1, y: p.y })
      pixelQueue.push({ x: p.x - 1, y: p.y })
      pixelQueue.push({ x: p.x, y: p.y + 1 })
      pixelQueue.push({ x: p.x, y: p.y - 1 })
    }
    console.log(`pixel fill finished: ${pixelFillCount} pixels`)

    for (const ti of tilesFilled) tileAgent.fillWholeTile(ti, color, true)
    for (const p of pixelsFilled) {
      const diff = tileAgent.setPixel(p, color, false, false)
      if (diff) pxDiffs.push(diff)
    }

    if (pxDiffs.length > 0) tileAgent.addDiffs(pxDiffs)
  }

  collectEdgePixels(agent: TileLayerImageAgent, filled: TileIndex[]): Vec2[] {
    const edge: Vec2[] = []
    const TILE_SIZE = agent.TILE_SIZE
    const filledSet = new Set(filled.map((t) => `${t.row},${t.column}`))

    for (const ti of filled) {
      const offset = agent.getTile(ti).getOffset()
      const neighbors = [
        { dr: -1, dc: 0, dx: 0, dy: -1, axis: 'x' },
        { dr: 1, dc: 0, dx: 0, dy: TILE_SIZE, axis: 'x' },
        { dr: 0, dc: -1, dx: -1, dy: 0, axis: 'y' },
        { dr: 0, dc: 1, dx: TILE_SIZE, dy: 0, axis: 'y' },
      ]

      for (const { dr, dc, dx, dy, axis } of neighbors) {
        const ni = `${ti.row + dr},${ti.column + dc}`
        if (filledSet.has(ni)) continue
        for (let i = 0; i < TILE_SIZE; i++) {
          const x = axis === 'x' ? offset.x + i : offset.x + dx
          const y = axis === 'y' ? offset.y + i : offset.y + dy
          edge.push({ x, y })
        }
      }
    }
    return edge
  }
}

================
File: src/models/types/Tool.ts
================
import {
  toolStore,
  setToolStore as setToolStore,
} from '~/stores/internal/toolsStore'

export enum ToolType {
  Pen = 'pen',
  Eraser = 'eraser',
  Fill = 'fill',
}

export type Tool = {
  type: ToolType
  id: string
  name: string
  size: number
  color: string
}

export const setCurrentToolColor = (colorHexString: string) => {
  return setToolStore('tools', toolStore.usingIndex, 'color', colorHexString)
}

================
File: src/models/types/Vector.ts
================
export interface Vec2 {
  x: number
  y: number
}

================
File: src/stores/internal/colorStore.ts
================
import { createStore } from "solid-js/store";

// color

export const [colorStore, setColorStore] = createStore({
  swatches: [
    "#000000",
    "#FFFFFF",
    "#ffff00",
    "#00ffff",
    "#00ff00",
    "#ff00ff",
    "#ff0000",
    "#0000ff",
    "#000080",
    "#400080",
  ],
});

================
File: src/stores/internal/toolsStore.ts
================
import { createStore } from 'solid-js/store'
import { createTool } from '~/models/factories/createPen'
import { ToolType } from '~/models/types/Tool'

export const [toolStore, setToolStore] = createStore({
  usingIndex: 0,
  tools: [
    createTool(ToolType.Pen, 'pen', 1, '#000000'),
    createTool(ToolType.Eraser, 'eraser', 4, 'none'),
    createTool(ToolType.Fill, 'fill', 4, '#FF0000'),
  ],
})
export const currentTool = () => toolStore.tools[toolStore.usingIndex]

================
File: src/stores/project/layerImageStore.ts
================
import { createStore } from 'solid-js/store'
import { runDSL } from '~/models/dsl/DSLRunner'
import { findLayerById, layerStore } from './layerStore'
import { LayerImage } from '~/models/types/LayerImage'

// image

export const [layerImageStore, setLayerImageStore] = createStore<
  Record<string, LayerImage>
>({})

export const activeLayerImage = (): LayerImage =>
  layerImageStore[layerStore.activeLayerId]

export const canUndo = (): boolean =>
  layerImageStore[layerStore.activeLayerId]?.undoStack.length > 0
export const canRedo = (): boolean =>
  layerImageStore[layerStore.activeLayerId]?.redoStack.length > 0

================
File: src/styles/components/bottom_info.css.ts
================
import { style } from "@vanilla-extract/css";
import { vars } from "../global.css";
import { flexRow, w100 } from "../snippets.css";

export const bottomInfoRoot = style([
  flexRow,
  w100,
  {
    borderTop: "1px solid #aaa",
    height: "20px",
    alignItems: "center",
    padding: `0 ${vars.spacing.md}`,
    gap: vars.spacing.md,
  },
]);

export const bottomInfoText = style({});

================
File: src/styles/components/canvas/image_pool.module.css
================
.resize-drag-container {
  /* This makes things *much* easier */
  box-sizing: border-box;
  font-family: sans-serif;
  left: 0;
  padding: 0;
  position: absolute;
  top: 0;
  touch-action: none;
  width: 120px;
  z-index: 100;
}

.image-container {
  height: 100%;
  width: 100%;
}

================
File: src/styles/components/light.module.css
================
.light-inner {
  filter: drop-shadow(0 0 0 red);
  opacity: 0;
  transition: none;
}

.light-inner.on {
  filter: drop-shadow(0 0 1px red);
  opacity: 1;
  transition: opacity 01s ease;
}

================
File: src/styles/components/side_sections.module.css
================
.content {
  border-right: 1px solid #aaa;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  height: 100%;
  padding: var(--window-top-padding) 40px 10px 35px;
  width: 230px;
}

================
File: src/styles/components/slider.module.css
================
.root {
  width: 100%;
}

.slider {
  align-items: center;
  display: flex;
  height: auto;
  overflow: visible;
  position: relative;
  width: 100%;
}

.line-hitbox {
  align-items: center;
  background-color: transparent;
  cursor: pointer;
  display: flex;
  height: 16px;
  position: absolute;
  width: 100%;
}

.line {
  background-color: black;
  display: flex;
  height: 1px;
  pointer-events: none; /* イベントは親に任せる */
  width: 100%;
}

.handle-hitbox {
  align-items: center;

  /* ユーザーには見えないけどクリックできる */
  background-color: transparent;
  cursor: pointer;
  display: flex;
  height: 24px;
  position: absolute;
  transform: translateX(-50%);
  width: 20px;
}

.handle {
  background-color: black;
  height: 8px;
  left: 50%;
  pointer-events: none; /* イベントは親に任せる */
  position: absolute;
  transform: translateX(-50%);
  width: 2px;
}

================
File: src/styles/snippets.css.ts
================
import { style } from "@vanilla-extract/css";

export const flexCol = style({
  display: "flex",
  flexDirection: "column",
});

export const flexRow = style({
  display: "flex",
  flexDirection: "row",
});

export const w100 = style({
  width: "100%",
});

export const h100 = style({
  height: "100%",
});

export const wh100 = style([w100, h100]);

================
File: src/utils/pathUtils.ts
================
import { FileLocation } from "~/stores/global/globalStore";

export const getFileNameAndPath = (
  fullPath: string,
): FileLocation | undefined => {
  var filePath = fullPath.substring(0, fullPath.lastIndexOf("\\"));
  var fileName = fullPath.split("\\").pop()?.split("/").pop();

  if (filePath === undefined || fileName === undefined) return undefined;
  else {
    return {
      path: filePath,
      name: fileName,
    };
  }
};

================
File: src/utils/tauriUtils.ts
================
import { getTauriVersion } from "@tauri-apps/api/app";
import { invoke as tauriInvoke } from "@tauri-apps/api/core";

let _isTauri: boolean | null = null;

export async function isTauri(): Promise<boolean> {
  if (_isTauri !== null) return _isTauri;
  try {
    await getTauriVersion();
    _isTauri = true;
  } catch {
    _isTauri = false;
  }
  return _isTauri;
}

export async function safeInvoke<T>(
  cmd: string,
  args?: Record<string, unknown>,
): Promise<T | undefined> {
  if (!(await isTauri())) {
    console.warn(`[safeInvoke] '${cmd}' skipped (not in Tauri environment)`);
    return undefined;
  }

  try {
    const result = await tauriInvoke<T>(cmd, args);
    return result;
  } catch (e) {
    console.error(`[safeInvoke] '${cmd}' failed:`, e);
    return undefined;
  }
}

================
File: todo_dsl.md
================
# DSL nodes TODO

## effect node

- [x] bright(n) (currently its "brightness") #明るさ
- [ ] contrast(n) #コントラスト
- [ ] saturate(n) #彩度
- [ ] hue(n) #色相
- [x] grayscale()（= saturate(-100)）
- [x] tone("sepia")
- [x] invert()
- [ ] blur(radius)
- [ ] sharpen(amount)

## pass node

### in/out

- [ ] in(layer_id) (that actually works as node)
- [ ] out(layer_id) (that actually works as node)
- [ ] multiout(\*a, \*b)

### area filter

- [ ] splitH(rate)
- [ ] splitV(rate)
- [ ] rect(lt, rt, lb, rb)
- [ ] select(x1, y1, x2, y2, ...) #多ピクセル座標指定で選択
- [ ] rand_hlines_area(density, seed)
- [ ] rand_vlines_area(density, seed)

## fracture node

- [x] jpeg_glitch(seed, quality, amount)

## combine node (image-level DSL)

入力元のデータの上にabove_dataを重ねる

- [ ] combine_override(above_data) #通常(上書き)
- [ ] combine_multiply(above_data) #乗算
- [ ] combine_add(above_data) #加算
- [ ] combine_exclude(above_data) #除外
- [ ] combine_mask(above_data) #マスク(透明以外で)

## other syntaxs

- [ ] assertions `[some-assertion]`
- [ ] instant subout memory `\*subout`
- [ ] pre-init subout memory `init subout`

================
File: tslint.json
================
{
    "defaultSeverity": "error",
    "extends": [
        "tslint:recommended"
    ],
    "jsRules": {},
    "rules": {},
    "rulesDirectory": []
}

================
File: .gitignore
================
dist
.wrangler
.output
.vercel
.netlify
.vinxi
app.config.timestamp_*.js

# Environment
.env
.env*.local

# dependencies
/node_modules

# IDEs and editors
/.idea
.project
.classpath
*.launch
.settings/

# Temp
gitignore

# System Files
.DS_Store
Thumbs.db

# repomix
repomix-output.txt
repomix-output.xml

================
File: dist-tcm/styles/components/canvas/canvas_stack.module.css.d.ts
================
declare const styles: {
  readonly "canvas_stack": string;
  readonly "image-container": string;
  readonly "resize-image": string;
};
export = styles;

================
File: dist-tcm/styles/components/canvas/controls.module.css.d.ts
================
declare const styles: {
  readonly "bottom-history": string;
  readonly "cursor": string;
  readonly "history-row": string;
  readonly "history-text": string;
  readonly "top-right-button-container": string;
  readonly "top-right-nav": string;
  readonly "undo_redo": string;
};
export = styles;

================
File: index.html
================
<!-- index.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Sledge</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <!--  -->
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <script src="/libs/speakjs/speakClient.js"></script>
  </body>
</html>

================
File: src-tauri/src/commands/brightness.rs
================
pub fn brightness(mut data: Vec<u8>, delta: i8) -> Result<Vec<u8>, String> {
    for i in (0..data.len()).step_by(4) {
        data[i] = data[i].saturating_add_signed(delta);
        data[i + 1] = data[i + 1].saturating_add_signed(delta);
        data[i + 2] = data[i + 2].saturating_add_signed(delta);
    }
    Ok(data)
}

================
File: src-tauri/src/commands/grayscale.rs
================
pub fn grayscale(mut data: Vec<u8>) -> Result<Vec<u8>, String> {
    for i in (0..data.len()).step_by(4) {
        let r = data[i] as u16;
        let g = data[i + 1] as u16;
        let b = data[i + 2] as u16;
        let gray = ((r + g + b) / 3) as u8;
        // または perceptual: let gray = (0.299*r + 0.587*g + 0.114*b) as u8;
        data[i] = gray;
        data[i + 1] = gray;
        data[i + 2] = gray;
    }
    Ok(data)
}

================
File: src-tauri/src/commands/invert.rs
================
pub fn invert(mut data: Vec<u8>) -> Result<Vec<u8>, String> {
    for i in (0..data.len()).step_by(4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
        // alphaはそのまま
    }
    Ok(data)
}

================
File: src-tauri/src/commands/sepia.rs
================
pub fn sepia(mut data: Vec<u8>) -> Result<Vec<u8>, String> {
    for i in (0..data.len()).step_by(4) {
        let r = data[i] as f32;
        let g = data[i + 1] as f32;
        let b = data[i + 2] as f32;

        let tr = (0.393 * r + 0.769 * g + 0.189 * b).min(255.0) as u8;
        let tg = (0.349 * r + 0.686 * g + 0.168 * b).min(255.0) as u8;
        let tb = (0.272 * r + 0.534 * g + 0.131 * b).min(255.0) as u8;

        data[i] = tr;
        data[i + 1] = tg;
        data[i + 2] = tb;
    }
    Ok(data)
}

================
File: src-tauri/src/pipeline/parser.rs
================
#[derive(Debug)]
pub enum PipelineNode {
    // コマンド（名前と引数）
    Command { name: String, args: Vec<String> },
    // 出力指定ノード（*out(layerX) 形式）
    Output { target: String },
}

/// パイプライン文字列をパースし、PipelineNodeのベクタを返す
pub fn parse_pipeline(input: &str) -> Result<Vec<PipelineNode>, String> {
    input
        .split('>')
        .map(|part| {
            let trimmed = part.trim();
            // 出力指定ノード： out(layerX)
            if let Some(captures) = trimmed
                .strip_prefix("out(")
                .and_then(|s| s.strip_suffix(")"))
            {
                Ok(PipelineNode::Output {
                    target: captures.to_string(),
                })
            }
            // コマンド＋引数：command(arg1,arg2)
            else if let Some(idx) = trimmed.find('(') {
                if trimmed.ends_with(')') {
                    let name = &trimmed[..idx];
                    let args_str = &trimmed[idx + 1..trimmed.len() - 1];
                    let args = args_str.split(',').map(|s| s.trim().to_string()).collect();
                    Ok(PipelineNode::Command {
                        name: name.to_string(),
                        args,
                    })
                } else {
                    Err(format!("Malformed command: {trimmed}"))
                }
            }
            // 引数なしの単純なコマンド
            else {
                Ok(PipelineNode::Command {
                    name: trimmed.to_string(),
                    args: vec![],
                })
            }
        })
        .collect()
}

================
File: src/components/canvas/stacks/ImagePool.tsx
================
import interact from "interactjs";
import { Component, onMount } from "solid-js";

import styles from "@styles/components/canvas/image_pool.module.css";

const ImagePool: Component<{}> = (props) => {
  let imageRef: HTMLDivElement;

  onMount(() => {
    interact(imageRef)
      .resizable({
        // resize from all edges and corners
        edges: { left: true, right: true, bottom: true, top: true },

        listeners: {
          move(event) {
            var target = event.target;
            var x = parseFloat(target.getAttribute("data-x")) || 0;
            var y = parseFloat(target.getAttribute("data-y")) || 0;

            // update the element's style
            target.style.width = event.rect.width + "px";
            target.style.height = event.rect.height + "px";

            // translate when resizing from top or left edges
            x += event.deltaRect.left;
            y += event.deltaRect.top;

            target.style.transform = "translate(" + x + "px," + y + "px)";

            target.setAttribute("data-x", x);
            target.setAttribute("data-y", y);
          },
        },
        modifiers: [
          // keep the edges inside the parent
          interact.modifiers.restrictEdges({
            outer: "parent",
          }),

          // minimum size
          interact.modifiers.restrictSize({
            min: { width: 100, height: 50 },
          }),
        ],

        inertia: true,
      })
      .draggable({
        listeners: {
          move(event) {
            event.preventDefault();
            event.stopPropagation();
            const target = event.target;
            const x =
              (parseFloat(target.getAttribute("data-x")) || 0) + event.dx;
            const y =
              (parseFloat(target.getAttribute("data-y")) || 0) + event.dy;

            target.style.transform = `translate(${x}px, ${y}px)`;
            target.setAttribute("data-x", x);
            target.setAttribute("data-y", y);
          },
        },
      });
  });

  return (
    <div
      class={styles["resize-drag-container"]}
      ref={(r) => (imageRef = r)}
      onMouseDown={(e) => e.preventDefault()}
    >
      <div
        class={styles["image-container"]}
        onMouseDown={(e) => e.preventDefault()}
      >
        {/* <img class={styles["resize-image"]} src="/333121.jpg" /> */}
      </div>
    </div>
  );
};

export default ImagePool;

================
File: src/components/common/companion/QuotePool.ts
================
import { smartSay } from "./Companion";

type QuoteCategory =
  | "color-pick"
  | "pen-resize"
  | "canvas-resize"
  | "undo-spam"
  | "random";

const lastSaidIndexes = {
  "color-pick": -1,
  "pen-resize": -1,
  "canvas-resize": -1,
  "undo-spam": -1,
  random: -1,
};
export const quotePool = {
  "color-pick": [
    "That color again? You really love it, huh.",
    "A fine choice, but not the finest.",
    "I see you're going with [color]. Bold.",
  ],
  "pen-resize": [
    "Hmm, Not quite my size.",
    "Go bigger, I'll crash 'em harder.",
    'Have you ever heard of the word "pixel perfect"?',
  ],
  "canvas-resize": [
    "Shrinking the canvas? Afraid of commitment?",
    "Small canvas, big ideas. I like it.",
  ],
  "undo-spam": [
    "UNDO UNDO UNDO—are you OK?",
    "That's the 5th undo. I’m getting dizzy.",
  ],
  random: ["Daisy, Daisy, give me your answer do do do"],
};

export const sayRandomQuote = (category: QuoteCategory, context?: any) => {
  const quotes = quotePool[category];
  let index = Math.floor(Math.random() * quotes.length);
  // 前になんか言った
  if (lastSaidIndexes[category] != -1) {
    console.log(
      `I previously said ${lastSaidIndexes[category]}. try saying something new.`,
    );
    if (quotes.length == 1) {
      console.log(`argh. nothing to say.`);
      // もう言えることない
      return "";
    } else {
      // console.log(`how about this?. ${index}`);
      // あるなら抽選続ける
      while (index === lastSaidIndexes[category]) {
        index = Math.floor(Math.random() * quotes.length);
        // console.log(`NO. how about this?. ${index}`);
      }
      console.log(`yeah. ${index} is a brand new. let's say it.`);
    }
  }
  let quote = quotes[index];
  quote = context?.color ? quote.replace("[color]", context.color) : quote;
  if (smartSay(quote)) {
    console.log(`◯ yay!`);
    lastSaidIndexes[category] = index;
  } else {
    console.log(`✕ hmm maybe I'd keep silence now?`);
  }
};

================
File: src/components/common/DSLButton.tsx
================
import styles from "@styles/components/dsl_button.module.css";
import { Component } from "solid-js";

interface Props {
  onClick?: (e: MouseEvent) => {};
}

const DSLButton: Component<Props> = (props: Props) => {
  return (
    <div
      class={styles.root}
      onMouseOver={(e) => {
        e.preventDefault();
        e.stopPropagation();
      }}
      onClick={props.onClick}
    >
      <img src="/DSL.png" />
    </div>
  );
};

export default DSLButton;

================
File: src/components/common/Light.tsx
================
import styles from "@styles/components/light.module.css";
import { Component, Show } from "solid-js";

interface LightProps {
  class?: string;
  on?: boolean;
}

const Light: Component<LightProps> = (props: LightProps) => {
  const width = 8;
  const height = 8;
  const radius = 2;

  return (
    <svg
      class={props.class}
      style={{
        width: `${width}px`,
        height: `${height}px`,
        overflow: "visible",
      }}
      viewBox={`0 0 ${width} ${height}`}
      xmlns="http://www.w3.org/2000/svg"
    >
      <Show when={true}>
        <g class={`${styles["light-inner"]} ${props.on && styles["on"]}`}>
          <circle cx={width / 2} cy={height / 2} r={radius} fill="red" />
        </g>
      </Show>
    </svg>
  );
};

export default Light;

================
File: src/components/EdgeInfo.tsx
================
import { Component } from "solid-js";

import { projectStore } from "~/stores/project/projectStore";
import { sideAreaEdge, sideAreaEdgeText } from "~/styles/global.css";

const EdgeInfo: Component<{}> = (props) => {
  return (
    <div class={sideAreaEdge}>
      <p class={sideAreaEdgeText}>
        &nbsp;&nbsp;{projectStore.path || "path N/A"}
      </p>
      {/* <p class={sideAreaEdgeText}>{projectStore.name || "name N/A"}</p> */}
    </div>
  );
};

export default EdgeInfo;

================
File: src/components/section/item/ColorPicker.tsx
================
import iro from "@jaames/iro";
import { IroColorPicker } from "@jaames/iro/dist/ColorPicker";
import { Component, createEffect } from "solid-js";
import { setCurrentToolColor } from "~/models/types/Tool";
import { currentTool } from "~/stores/internal/toolsStore";

const ColorPicker: Component<{}> = (props) => {
  let colorPicker: IroColorPicker;

  createEffect(() => {
    colorPicker.setColors([currentTool().color]);
  });

  return (
    <div
      ref={(el) => {
        colorPicker = iro.ColorPicker(el, {
          width: 150,
          padding: 0,
          color: currentTool().color,
          handleRadius: 4,
          layoutDirection: "horizontal",
          layout: [
            {
              component: iro.ui.Box,
              options: {},
            },
            {
              component: iro.ui.Slider,
              options: {
                // can also be 'saturation', 'value', 'red', 'green', 'blue', 'alpha' or 'kelvin'
                sliderType: "hue",
              },
            },
          ],
        });
        colorPicker.on("color:change", function (color: any) {
          setCurrentToolColor(color.hexString);
        });
      }}
    ></div>
  );
};

export default ColorPicker;

================
File: src/components/ToastContainer.tsx
================
import styles from "@styles/components/toast.module.css";
import { For } from "solid-js";
import { setToasts, toasts } from "~/stores/internal/toastStore";

export default function ToastContainer() {
  return (
    <div class={styles.toastContainer}>
      <For each={toasts}>
        {(toast) => (
          <div class={styles.toast_root}>
            <div class={`${styles.toast} ${styles[toast.type]}`}>
              {toast.message}
            </div>
            {toast.isPersistent && (
              <a
                class={styles.close_persistent_button}
                onClick={() => {
                  setToasts((prev) => prev.filter((t) => t.id !== toast.id));
                }}
              >
                x
              </a>
            )}
          </div>
        )}
      </For>
    </div>
  );
}

================
File: src/io/global/globalIO.ts
================
import {
  BaseDirectory,
  mkdir,
  readTextFile,
  writeTextFile,
} from '@tauri-apps/plugin-fs'
import { globalStore, setGlobalStore } from '~/stores/global/globalStore'

const FILE_NAME = 'global.sledgeconfig'

export async function saveGlobalSettings() {
  try {
    const json = JSON.stringify(globalStore)
    await mkdir('', { baseDir: BaseDirectory.AppConfig, recursive: true })
    await writeTextFile(FILE_NAME, json, { baseDir: BaseDirectory.AppConfig })
    console.log('[globalIO] 設定保存完了')
  } catch (e) {
    console.error('[globalIO] 設定保存失敗', e)
  }
}

export async function loadGlobalSettings() {
  try {
    const json = await readTextFile(FILE_NAME, {
      baseDir: BaseDirectory.AppConfig,
    })
    const data = JSON.parse(json)

    if (data.recentOpenedFiles) {
      setGlobalStore('recentOpenedFiles', data.recentOpenedFiles)
    }
    if (data.canvasRenderingMode) {
      setGlobalStore('canvasRenderingMode', data.canvasRenderingMode)
    }

    console.log('[globalIO] 設定読み込み完了')
  } catch (e) {
    console.warn('[globalIO] 設定ファイルが存在しないか、読み込み失敗:', e)
  }
}

================
File: src/io/internal/export.ts
================
import { layerStore } from "~/stores/project/layerStore";

export function exportActiveLayerUpscaled(scale = 10) {
  const layerId = layerStore.activeLayerId;
  if (!layerId) return;

  const originalCanvas = document.getElementById(
    `canvas-${layerId}`,
  ) as HTMLCanvasElement;
  if (!originalCanvas) {
    alert("対象のレイヤーが見つかりません。");
    return;
  }

  const w = originalCanvas.width;
  const h = originalCanvas.height;

  // オフスクリーンキャンバスを作る
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = w * scale;
  exportCanvas.height = h * scale;

  const ctx = exportCanvas.getContext("2d");
  if (!ctx) {
    alert("Canvasコンテキスト取得に失敗しました。");
    return;
  }

  // ピクセル補間を無効化
  ctx.imageSmoothingEnabled = false;

  // 元のキャンバスをscale倍に引き伸ばして描画（補完なし）
  ctx.drawImage(originalCanvas, 0, 0, exportCanvas.width, exportCanvas.height);

  // エクスポート処理
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      alert("エクスポートに失敗しました。");
      return;
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${layerId}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, "image/png");
}

export function downloadImageData(
  imageData: ImageData,
  filename: string = "image",
  scale: number = 10,
) {
  // 一時的な canvas を作成
  const canvas = document.createElement("canvas");
  canvas.width = imageData.width;
  canvas.height = imageData.height;

  // ImageData を描画
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("2D context not available");
    return;
  }
  ctx.putImageData(imageData, 0, 0);

  const w = canvas.width;
  const h = canvas.height;

  // オフスクリーンキャンバスを作る
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = w * scale;
  exportCanvas.height = h * scale;

  const ctxEx = exportCanvas.getContext("2d");
  if (!ctxEx) {
    alert("Canvasコンテキスト取得に失敗しました。");
    return;
  }

  // ピクセル補間を無効化
  ctxEx.imageSmoothingEnabled = false;
  // 元のキャンバスをscale倍に引き伸ばして描画（補完なし）
  ctxEx.drawImage(canvas, 0, 0, exportCanvas.width, exportCanvas.height);

  // エクスポート処理
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      alert("エクスポートに失敗しました。");
      return;
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${filename}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, "image/png");
}

================
File: src/models/factories/canvasPreview.ts
================
export function createPreviewCanvas(
  imageData: ImageData,
  targetHeight: number,
): HTMLCanvasElement {
  const aspectRatio = imageData.width / imageData.height;
  const targetWidth = Math.round(targetHeight * aspectRatio);

  const canvas = document.createElement("canvas");
  canvas.width = targetWidth;
  canvas.height = targetHeight;

  const ctx = canvas.getContext("2d")!;
  ctx.imageSmoothingEnabled = false;

  const tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = imageData.width;
  tmpCanvas.height = imageData.height;
  tmpCanvas.getContext("2d")!.putImageData(imageData, 0, 0);

  ctx.drawImage(
    tmpCanvas,
    0,
    0,
    imageData.width,
    imageData.height,
    0,
    0,
    targetWidth,
    targetHeight,
  );

  return canvas;
}

================
File: src/models/factories/createPen.ts
================
import { v4 as uuidv4 } from "uuid";
import { Tool, ToolType } from "../types/Tool";

export const createTool = (
  type: ToolType,
  name: string,
  size: number,
  color: string,
): Tool => ({
  id: uuidv4(),
  type,
  name,
  size,
  color,
});

================
File: src/models/factories/utils.ts
================
const magnificationList: number[] = [1, 2, 4]
export const getNextMagnification = (dotMagnification: number) => {
  let index = magnificationList.findIndex((m) => m === dotMagnification)
  if (index != -1) {
    // 循環
    let nextIndex = index !== magnificationList.length - 1 ? index + 1 : 0
    return magnificationList[nextIndex]
  } else return 1
}

================
File: src/models/layer_image/HistoryManager.ts
================
import {
  layerImageStore,
  setLayerImageStore,
} from '~/stores/project/layerImageStore'
import { Vec2 } from '../types/Vector'
import { reconcile } from 'solid-js/store'
import { RGBAColor } from '~/utils/colorUtils'
import { TileIndex } from './Tile'

export type PixelDiff = {
  kind: 'pixel'
  position: Vec2
  before: RGBAColor
  after: RGBAColor
}

export type TileDiff = {
  kind: 'tile'
  index: TileIndex
  beforeColor: RGBAColor | undefined
  afterColor: RGBAColor
}

export type Diff = PixelDiff | TileDiff

export const getDiffHash = (diff: Diff) => {
  switch (diff.kind) {
    case 'pixel':
      return `px:${diff.position.x},${diff.position.y}`
    case 'tile':
      return `tile:${diff.index.row},${diff.index.column}`
  }
}

export type DiffAction = {
  diffs: Map<string, Diff>
}

export class HistoryManager {
  protected undoActionsStack: DiffAction[]
  protected redoActionsStack: DiffAction[]

  constructor(public layerId: string) {
    this.undoActionsStack = []
    this.redoActionsStack = []
  }

  public getUndoStack() {
    return this.undoActionsStack
  }

  public getRedoStack() {
    return this.undoActionsStack
  }

  public canUndo() {
    return this.undoActionsStack.length > 0
  }

  public canRedo() {
    return this.redoActionsStack.length > 0
  }

  public addAction(action: DiffAction) {
    this.undoActionsStack.push(action)
    this.redoActionsStack = []
    setLayerImageStore(
      this.layerId,
      'undoStack',
      reconcile(this.undoActionsStack)
    )
    setLayerImageStore(
      this.layerId,
      'redoStack',
      reconcile(this.redoActionsStack)
    )
  }

  public undo(): DiffAction | undefined {
    const undoedAction = this.undoActionsStack.pop()
    if (undoedAction === undefined) return undefined
    this.redoActionsStack = [undoedAction, ...this.redoActionsStack]
    setLayerImageStore(
      this.layerId,
      'undoStack',
      reconcile(this.undoActionsStack)
    )
    setLayerImageStore(
      this.layerId,
      'redoStack',
      reconcile(this.redoActionsStack)
    )
    return undoedAction
  }

  public redo(): DiffAction | undefined {
    const redoedAction = this.redoActionsStack.shift()
    if (redoedAction === undefined) return undefined
    this.undoActionsStack = [...this.undoActionsStack, redoedAction]
    setLayerImageStore(
      this.layerId,
      'undoStack',
      reconcile(this.undoActionsStack)
    )
    setLayerImageStore(
      this.layerId,
      'redoStack',
      reconcile(this.redoActionsStack)
    )
    return redoedAction
  }
}

================
File: src/models/layer_image/LayerImageManager.ts
================
import { HistoryManager } from './HistoryManager'
import LayerImageAgent from './LayerImageAgent'
import TileLayerImageAgent from './agents/TileLayerImageAgent'

export class LayerImageManager {
  private agents: Map<string, LayerImageAgent> = new Map()

  public getAgent(layerId: string): LayerImageAgent | undefined {
    return this.agents.get(layerId)
  }

  public registerAgent(layerId: string, image: ImageData): LayerImageAgent {
    const agent = new TileLayerImageAgent(image, new HistoryManager(layerId))
    this.agents.set(layerId, agent)
    return agent
  }
}

================
File: src/models/types/LayerImage.ts
================
import { DiffAction } from '../layer_image/HistoryManager'

export type LayerImage = {
  current: ImageData
  undoStack: DiffAction[]
  redoStack: DiffAction[]
}

================
File: src/routes/[...404].tsx
================
import { Title } from "@solidjs/meta";

export default function NotFound() {
  return (
    <main>
      <Title>Not Found</Title>
      <h1>Page Not Found</h1>
      <p>
        Visit{" "}
        <a href="https://start.solidjs.com" target="_blank">
          start.solidjs.com
        </a>{" "}
        to learn how to build SolidStart apps.
      </p>
    </main>
  );
}

================
File: src/routes/start.css.ts
================
import { style } from "@vanilla-extract/css";
import { ZFB03B, ZFB09 } from "~/styles/global.css";
import { flexCol, flexRow, w100, wh100 } from "~/styles/snippets.css";

export const welcomeRoot = style([
  flexCol,
  wh100,
  {
    alignItems: "center",
    justifyContent: "center",
  },
]);

export const welcomeHeadline = style({
  fontFamily: ZFB09,
  fontSize: "5rem",
  letterSpacing: "8px",
  marginBottom: "12px",
});

export const recentFilesCaption = style({
  fontFamily: ZFB03B,
  color: "#333",
  flexGrow: 1,
  marginBottom: "12px",
});

export const clear = style({
  color: "#777",
  fontFamily: ZFB03B,
});

export const recentFilesContainer = style([
  flexCol,
  w100,
  {
    gap: "8px",
    marginTop: "4px",
  },
]);

export const recentFilesItem = style([
  flexRow,
  w100,
  {
    alignItems: "center",
    gap: "8px",
  },
]);

export const recentFilesName = style({
  fontFamily: ZFB09,
  fontSize: "0.5rem",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
});

export const recentFilesPath = style({
  fontFamily: ZFB03B,
  fontSize: "0.5rem",
  color: "#00000030",
});

export const sideSection = style([
  flexCol,
  {
    gap: "1rem",
    paddingBottom: "24px",
    paddingTop: "12px",
  },
]);

export const sideSectionItem = style([
  flexCol,
  {
    cursor: "pointer",
    fontSize: "1rem",
    width: "fit-content",
    ":hover": {
      color: "red",
    },
  },
]);

================
File: src/stores/internal/toastStore.ts
================
import { createStore } from "solid-js/store";

export type ToastType = "info" | "success" | "warn" | "error";

export interface Toast {
  id: number;
  message: string;
  type: ToastType;
  timeout: number;
  isPersistent: boolean;
}

let toastId = 0;
const MAX_COUNT = 10;
export const [toasts, setToasts] = createStore<Toast[]>([]);

export function showToast(
  message: string | number,
  type: ToastType = "info",
  timeout = 10000,
) {
  if (typeof message === "number") message = message.toString();
  const id = toastId++;
  const isPersistent = timeout < 0;
  if (toasts.length >= MAX_COUNT) {
    const reducedToasts = [...toasts];
    reducedToasts.shift();
    setToasts(reducedToasts);
  }
  setToasts([...toasts, { id, message, type, timeout, isPersistent }]);

  if (!isPersistent) {
    setTimeout(() => {
      setToasts((prev) => prev.filter((t) => t.id !== id));
    }, timeout);
  }
}

================
File: src/stores/project/canvasStore.ts
================
import { createStore } from 'solid-js/store'
import { createCanvas } from '~/models/types/Canvas'

// canvas
const REFERENCE_LENGTH = 600

export const getReferencedZoom = (length?: number) => {
  if (length === undefined) {
    const width = canvasStore.canvas.width
    const height = canvasStore.canvas.height
    length = width > height ? width : height
  }

  return REFERENCE_LENGTH / length
}

export const adjustZoomToFit = (width?: number, height?: number) => {
  if (width === undefined) width = canvasStore.canvas.width
  if (height === undefined) height = canvasStore.canvas.height

  let isWide = width > height
  let longerLength = isWide ? width : height

  console.log(
    `this is ${isWide ? 'wide' : 'tall'}.
    ${REFERENCE_LENGTH} / ${longerLength} = ${REFERENCE_LENGTH / longerLength}. set zoom.`
  )
  setCanvasStore('zoom', getReferencedZoom(longerLength))
  centeringCanvas()
}

export const centeringCanvas = () => {
  const canvasSize = canvasStore.canvas
  const canvasArea = canvasStore.canvasAreaSize
  const zoom = canvasStore.zoom

  console.log(
    `area size is ${canvasArea.width} x ${canvasArea.height}.
    canvas size is ${canvasSize.width} x ${canvasSize.height}.
    current offset origin is ${canvasStore.offsetOrigin.x}, ${canvasStore.offsetOrigin.y}.
    new offset origin is ${canvasStore.canvasAreaSize.width / 2 - canvasStore.canvas.width / 2}, ${canvasStore.canvasAreaSize.height / 2 - canvasStore.canvas.height / 2}`
  )

  setCanvasStore('offsetOrigin', {
    x: canvasArea.width / 2 - (canvasSize.width * zoom) / 2,
    y: canvasArea.height / 2 - (canvasSize.height * zoom) / 2,
  })
  setCanvasStore('offset', {
    x: 0,
    y: 0,
  })
}

export const [canvasStore, setCanvasStore] = createStore({
  canvas: createCanvas(400, 400),
  canvasAreaSize: { width: 0, height: 0 },
  lastMouseWindow: { x: 0, y: 0 },
  lastMouseOnCanvas: { x: 0, y: 0 },
  lastMouseOnZoomedCanvas: { x: 0, y: 0 },
  isInStroke: false,
  zoom: 1,
  zoomMin: 0.1,
  zoomMax: 8,
  touchZoomSensitivity: 0.5,
  wheelZoomStep: 0.1,
  // オフセットの初期値
  offsetOrigin: { x: 0, y: 0 },
  offset: { x: 0, y: 0 },

  isCtrlPressed: false,
  isDragging: false,
})

================
File: src/stores/project/layerStore.ts
================
import { createStore } from 'solid-js/store'
import { Layer } from '~/models/types/Layer'

// layer

export const [layerStore, setLayerStore] = createStore({
  layers: new Array<Layer>(),
  activeLayerId: '',
})

export const allLayers = () => layerStore.layers
export const findLayerById = (id: string) =>
  allLayers().find((layer) => layer.id === id)
export const activeLayer = () =>
  findLayerById(layerStore.activeLayerId) || allLayers()[0] || undefined
export const activeIndex = () =>
  allLayers().findIndex((layer) => layer.id === layerStore.activeLayerId)

================
File: src/styles/components/canvas/canvas_area.css.ts
================
import { style } from "@vanilla-extract/css";
import { flexCol } from "../../snippets.css";

export const canvasArea = style([
  flexCol,
  {
    backgroundColor: "#fcfcfc",
    display: "flex",
    flex: 1,
    flexDirection: "column",
    height: "100vh",
    overflow: "hidden",
    position: "relative",
    width: "100%",
  },
]);

================
File: src/styles/components/companion.module.css
================
.root {
  bottom: 0;
  left: 500px;
  pointer-events: none;
  position: absolute;
  z-index: 999;
}

.wrapper {
  animation: fluffy 2s ease-in-out infinite;
  height: 300px;
  transform-origin: center center;
  width: 300px;
}

.companion {
  anchor-name: --companion;
  display: flex;
  flex-direction: column;
  height: 50px;
  image-rendering: pixelated;
  margin: 80px auto;
  margin-left: 0;
  width: 50px;
}

.giggle {
  animation: giggle 0.5s;
  animation-iteration-count: 10;
}

.quote_box_container {
  background-color: #ddd;
  bottom: calc(anchor(top) + 17px);
  justify-self: anchor-center;
  position: absolute;
  position-anchor: --companion;
  width: fit-content;
}

.quote_box {
  anchor-name: --box;
  background: #fff;
  border: solid 1px #555;
  border-radius: 3px;
  max-width: 200px;
  overflow-wrap: break-word;
  padding: 12px;
  width: fit-content;
}

.quote_box::before {
  border: 7px solid transparent;
  border-top: 7px solid #fff;
  content: "";
  padding-left: 1px;
  position: absolute;
  position-anchor: --companion;
  top: calc(anchor(--box bottom) - 2px);
  z-index: 2;
}

.quote_box::after {
  border: 8px solid transparent;
  border-top: 8px solid #555;
  content: "";
  position: absolute;
  position-anchor: --companion;
  top: calc(anchor(--box bottom) - 1px);
}

.quote {
  image-rendering: pixelated;
}

@keyframes fluffy {
  0%,
  100% {
    transform: translateY(0);
  }

  50% {
    transform: translateY(-5px);
  }
}

@keyframes giggle {
  0% {
    transform: rotate(0deg);
  }

  25% {
    transform: rotate(2deg);
  }

  50% {
    transform: rotate(0deg);
  }

  75% {
    transform: rotate(-2deg);
  }

  100% {
    transform: rotate(0deg);
  }
}

================
File: src/styles/components/dsl_button.module.css
================
.root {
  cursor: pointer;
  height: 20px;
  image-rendering: pixelated;
  margin: 4px;
  opacity: 0.7;
  pointer-events: all;
  width: 20px;
}

.root:hover {
  opacity: 0.3;
  transform: translate(0, 1px);
}

================
File: src/styles/components/edge_info.module.css
================
.root {
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 10px 0 20px 12px;
  justify-items: start;
}

.text {
  font-size: 0.5rem;
  letter-spacing: 2px;
  margin: 0;
  transform: rotate(180deg) scaleX(0.8);
  white-space: nowrap;
  writing-mode: vertical-rl;
}

================
File: src/styles/components/layer_preview.module.css
================
.canvas {
  height: 100%;
  border: 1px solid black;
  width: 100%;
}

================
File: src/styles/components/title_bar.css.ts
================
import { style } from "@vanilla-extract/css";
import { vars, ZFB08 } from "../global.css";
import { flexCol, flexRow, h100, w100 } from "../snippets.css";

export const titleBarRoot = style([
  flexRow,
  w100,
  {
    background: "#fff",
    pointerEvents: "all",
    height: "28px",
    borderBottom: "1px solid #aaa",
    alignItems: "center",
    zIndex: 9999,
  },
]);

export const titleBarTitle = style([
  flexRow,
  w100,
  {
    fontFamily: ZFB08,
    fontSize: vars.text.sm,
    marginRight: "auto",
    paddingLeft: vars.spacing.lg,
    pointerEvents: "none",
  },
]);

export const titleBarControls = style([
  flexRow,
  h100,
  {
    gap: vars.spacing.sm,
    marginRight: vars.spacing.sm,
  },
]);

export const titleBarControlButton = style([
  flexCol,
  h100,
  {
    background: "none",
    backgroundColor: "transparent",
    border: "none",
    alignItems: "center",
    justifyContent: "center",
    minWidth: "24px",
    ":hover": {
      backgroundColor: "transparent",
    },
  },
]);

export const titleBarControlMinimizeButton = style([
  titleBarControlButton,
  {
    ":hover": {
      filter:
        "invert(9%) sepia(100%) saturate(6812%) hue-rotate(247deg) brightness(96%) contrast(146%);", // 青っぽく
    },
  },
]);

export const titleBarControlMaximizeButton = style([
  titleBarControlButton,
  {
    ":hover": {
      filter:
        "invert(92%) sepia(20%) saturate(3846%) hue-rotate(112deg) brightness(105%) contrast(102%);", // 緑っぽく
    },
  },
]);

export const titleBarControlCloseButton = style([
  titleBarControlButton,
  {
    ":hover": {
      filter:
        "invert(11%) sepia(92%) saturate(7351%) hue-rotate(0deg) brightness(99%) contrast(109%);", // 赤っぽく
    },
  },
]);

export const titleBarControlButtonImg = style({
  width: "10px",
  height: "10px",
  imageRendering: "pixelated",
});

================
File: src/styles/components/toast.module.css
================
.toastContainer {
  bottom: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  padding-bottom: 20px;
  position: fixed;
  right: 1rem;
  z-index: 9999;
}

.toast_root {
  align-items: center;
  background-color: #fff;
  border: 1px solid black;
  border-radius: 6px;
  display: flex;
  flex-direction: row;
  gap: 1rem;
  padding: 0.5rem;
}

.close_persistent_button {
  height: 12px;
  width: 12px;

  &:hover {
    color: red;
  }
}

.toast {
  color: #222;
  flex-grow: 1;
  font-family: "04B09";
  font-size: 0.5rem;
  margin-top: 2px;
}

.toast.success {
  color: #4caf50;
}

.toast.error {
  color: #f44336;
}

.toast.warn {
  color: #ff9800;
}

.toast.info {
  /* background-color: #2196f3; */
}

@keyframes fade-in-out-top {
  0% {
    opacity: 0;
    transform: translateY(-10px);
  }

  10%,
  90% {
    opacity: 1;
    transform: translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateY(-10px);
  }
}

@keyframes fade-in-out-bottom {
  0% {
    opacity: 0;
    transform: translateY(10px);
  }

  10%,
  90% {
    opacity: 1;
    transform: translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateY(10px);
  }
}

================
File: src/styles/global.css.ts
================
import {
  createGlobalTheme,
  fontFace,
  globalStyle,
  style,
} from '@vanilla-extract/css'
import { flexCol, flexRow, h100 } from './snippets.css'

export const ZFB03 = fontFace({
  src: 'url("/fonts/04B_03__.ttf")',
})
export const ZFB03B = fontFace({
  src: 'url("/fonts/04B_03B_.ttf")',
})
export const ZFB08 = fontFace({
  src: 'url("/fonts/04B_08__.ttf")',
})
export const ZFB09 = fontFace({
  src: 'url("/fonts/04B_09__.ttf")',
})
export const ZFB11 = fontFace({
  src: 'url("/fonts/04B_11__.ttf")',
})
export const ZFB31 = fontFace({
  src: 'url("/fonts/04B_31__.ttf")',
})
export const Terminus = fontFace({
  src: 'url("/fonts/terminus/TerminusTTF-4.49.3.ttf")',
})
export const k8x12 = fontFace({
  src: 'url("/fonts/k8x12/k8x12.ttf")',
})
export const k8x12L = fontFace({
  src: 'url("/fonts/k8x12/k8x12L.ttf")',
})
export const k8x12S = fontFace({
  src: 'url("/fonts/k8x12/k8x12S.ttf")',
})
export const k12x8 = fontFace({
  src: 'url("/fonts/k12x8/k12x8.ttf")',
})

export const vars = createGlobalTheme(':root', {
  color: {
    primary: '#ffffff',
    secondary: '#f0f0f0',
    text: '#111111',
    danger: '#ff0000',
    muted: '#00000030',
    bg: '#ffffff',
    surface: '#f0f0f0',

    button: '#ffffff',
    button_hover: '#f0f0f0',
    button_pressed: '#f0f0f0',
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '12px',
    lg: '16px',
    xl: '24px',
  },
  text: {
    xs: '6px',
    sm: '8px',
    md: '10px',
    lg: '12px',
    xl: '16px',
  },
  font: {
    body: `${ZFB08}, ${k8x12}`,
  },
})

globalStyle('button, p, a, input', {
  fontFamily: ZFB08,
  color: vars.color.text,
})

globalStyle('a:hover', {
  color: 'red',
})

globalStyle('button', {
  background: vars.color.button,
  border: '1px black solid',
  borderRadius: '2px',
  cursor: 'pointer',
  fontSize: '0.5rem',
  height: 'fit-content',
  padding: '2px 6px',
  pointerEvents: 'all',
})

globalStyle('button:hover', {
  background: vars.color.button_hover,
})

globalStyle('button:active', {
  background: vars.color.button_pressed,
  transform: 'translateY(1px)',
})

globalStyle('#root', {
  display: 'flex',
  flexDirection: 'row',
  height: '100%',
  userSelect: 'none',
})

export const sideArea = style([flexRow, h100])

export const sideAreaEdge = style([
  flexCol,
  h100,
  {
    gap: '20px',
    width: '20px',
    margin: '10px 0 20px 2px',
    paddingBottom: '20px',
    justifyContent: 'flex-end',
  },
])

export const sideAreaEdgeText = style({
  fontSize: '0.5rem',
  letterSpacing: '2px',
  transform: 'rotate(180deg) scaleX(0.8)',
  whiteSpace: 'nowrap',
  writingMode: 'vertical-rl',
})

export const sideAreaContent = style([
  flexCol,
  {
    borderRight: '1px solid #aaa',
    gap: '1rem',
    padding: '20px 40px 10px 20px',
    width: '230px',
  },
])

export const sledgeLogo = style({
  bottom: '2px',
  position: 'absolute',
  right: '2px',
})

================
File: src/styles/reset.css.ts
================
import { globalStyle } from "@vanilla-extract/css";

globalStyle("html, body", {
  height: "100vh",
  width: "100vw",
  margin: 0,
  overflow: "hidden",
  padding: 0,
  touchAction: "none",
});

globalStyle("body", {
  height: "100vh",
  width: "100vw",
});

globalStyle("main", {
  height: "100vh",
  width: "100vw",
  userSelect: "none",
});

globalStyle("p, a", {
  fontSize: "0.5rem",
  letterSpacing: "1px",
  margin: 0,
});

globalStyle("ul", {
  listStyle: "none",
  paddingLeft: 0,
});

globalStyle("a", {
  cursor: "pointer",
});

globalStyle("input", {
  border: "none",
  outline: "none",
  borderBottom: "1px solid black",
});

globalStyle(
  "input::-webkit-outer-spin-button, input::-webkit-inner-spin-button",
  {
    appearance: "none",
    margin: 0,
  },
);

globalStyle("input[type='number']", {
  appearance: "textfield",
});

================
File: src/styles/section_global.css.ts
================
import { style } from '@vanilla-extract/css'
import { vars, ZFB11 } from './global.css'
import { flexCol, w100 } from './snippets.css'

export const sectionRoot = style([
  flexCol,
  {
    // border: '1px solid black',
  },
])

export const sectionCaption = style({
  fontFamily: ZFB11,
  fontSize: vars.text.sm,
  marginBottom: vars.spacing.md,
})

export const sectionContent = style([flexCol, w100])

================
File: src/styles/section/canvas.css.ts
================
import { style } from "@vanilla-extract/css";
import { vars } from "../global.css";
import { flexRow } from "../snippets.css";

export const canvasSizeForm = style([
  flexRow,
  {
    alignItems: "flex-end",
    marginBottom: "6px",
  },
]);

export const canvasSizeLabel = style({
  fontSize: vars.text.sm,
});

export const canvasSizeInput = style({
  fontSize: vars.text.md,
  margin: `${vars.spacing.xs}`,
  width: "50px",
});

export const canvasSizeButton = style({
  margin: vars.spacing.sm,
});

================
File: src/styles/section/color.css.ts
================
import { style } from "@vanilla-extract/css";
import { vars, ZFB03 } from "../global.css";
import { flexCol } from "../snippets.css";

export const swatchContainer = style([
  flexCol,
  {
    position: "relative",
    gap: vars.spacing.xs,
    marginRight: vars.spacing.md,
  },
]);

export const descriptionContainer = style([
  flexCol,
  {
    justifyContent: "end",
    marginBottom: vars.spacing.sm,
  },
]);

export const colorElemDescription = style({
  color: vars.color.muted,
  fontFamily: ZFB03,
  fontSize: vars.text.sm,
  transform: "rotate(180deg)",
  whiteSpace: "nowrap",
  writingMode: "vertical-rl",
});

export const colorContent = style([
  flexCol,
  {
    marginLeft: vars.spacing.sm,
  },
]);

================
File: src/styles/section/layer.css.ts
================
import { style } from "@vanilla-extract/css";
import { vars, ZFB03B } from "../global.css";
import { flexCol, flexRow, w100 } from "../snippets.css";

export const layerList = style([
  flexCol,
  w100,
  {
    flexGrow: 1,
    gap: vars.spacing.xs,
    position: "relative",
  },
]);

export const layerItem = style([
  flexRow,
  w100,
  {
    height: "24px",
    padding: vars.spacing.sm,
    flexGrow: 1,
    cursor: "pointer",
    backgroundColor: vars.color.surface,
    borderLeft: "1px solid black",
    ":hover": {
      filter: "brightness(0.94)",
      transform: "translate(0, 1px)",
    },
  },
]);

export const layerItemDisabled = style({
  color: vars.color.muted,
});

export const layerItemType = style([
  w100,
  {
    fontSize: vars.text.sm,
    opacity: 0.4,
    position: "absolute",
    right: 0,
    textAlign: "end",
  },
]);

export const layerItemName = style([
  {
    fontSize: vars.text.xl,
    fontFamily: ZFB03B,
    margin: `${vars.spacing.sm} 0 0 ${vars.spacing.lg}`,
  },
]);

export const dotMagnifContainer = style([
  {
    alignSelf: "center",
    border: "1px black solid",
    borderRadius: vars.spacing.xs,
    cursor: "pointer",
    marginLeft: "auto",
    marginRight: 0,
    padding: `2px ${vars.spacing.xs}`,
    pointerEvents: "all",

    ":hover": {
      color: vars.color.muted,
    },
  },
]);

export const dotMagnifText = style([
  {
    fontFamily: ZFB03B,
    fontSize: vars.text.md,
  },
]);

export const activeLight = style([
  {
    alignSelf: "center",
    margin: `${vars.spacing.sm}px 0`,
    marginLeft: vars.spacing.sm,
  },
]);

export const dropPlaceholder = style([
  {
    border: "2px dashed #aaa",
    borderRadius: vars.spacing.md,
    height: "32px",
    margin: `${vars.spacing.xs}px 0`,
  },
]);

================
File: src/styles/section/pen.css.ts
================
import { style } from "@vanilla-extract/css";
import { vars } from "../global.css";
import { flexRow, w100 } from "../snippets.css";

export const penConfigRow = style([
  flexRow,
  w100,
  {
    gap: vars.spacing.md,
    alignItems: "center",
  },
]);

export const penConfigRowName = style({
  cursor: "pointer",
  fontSize: vars.text.sm,
  padding: `${vars.spacing.md} 0`,
  pointerEvents: "all",
  width: "20%",
});

================
File: src/styles/section/project.css.ts
================
import { style } from "@vanilla-extract/css";
import { vars } from "../global.css";

export const projectNameInput = style({
  border: "none",
  fontSize: vars.text.xl,
  marginBottom: vars.spacing.sm,
  marginLeft: "-2px",
  outline: "none",

  "::placeholder": {
    opacity: 0.5,
  },
});

export const saveLog = style({
  color: "limegreen",
  marginLeft: vars.spacing.sm,
});

================
File: src/utils/colorUtils.ts
================
export type RGBColor = [number, number, number]
export type RGBAColor = [number, number, number, number]

// "#rrggbb" -> r/g/b
export function hexToRGB(hex: string): RGBColor {
  const r = parseInt(hex.slice(1, 3), 16)
  const g = parseInt(hex.slice(3, 5), 16)
  const b = parseInt(hex.slice(5, 7), 16)
  return [r, g, b]
}

// "#rrggbbaa" -> r/g/b/a
export function hexToRGBA(hex: string): RGBAColor {
  const r = parseInt(hex.slice(1, 3), 16)
  const g = parseInt(hex.slice(3, 5), 16)
  const b = parseInt(hex.slice(5, 7), 16)
  let a = parseInt(hex.slice(7, 9), 16)
  if (!a) a = 255 // ここがなかったので a=NaN となり、塗る際にエラー？
  return [r, g, b, a]
}

export function colorMatch(a: RGBAColor, b: RGBAColor): boolean {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]
}

================
File: src/utils/ImageUtils.ts
================
export function setPixel(
  image: ImageData,
  x: number,
  y: number,
  r: number,
  g: number,
  b: number,
  a: number,
) {
  if (x < 0 || x >= image.width || y < 0 || y >= image.height) return;
  const i = (y * image.width + x) * 4;
  image.data[i + 0] = r;
  image.data[i + 1] = g;
  image.data[i + 2] = b;
  image.data[i + 3] = a;
}

export function encodeImageData(imageData: ImageData): string {
  const bytes = new Uint8Array(imageData.data.buffer);
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary); // Base64 encode
}

export function decodeImageData(
  encoded: string,
  width: number,
  height: number,
): ImageData {
  const binary = atob(encoded);
  const buffer = new Uint8ClampedArray(binary.length);
  for (let i = 0; i < binary.length; i++) {
    buffer[i] = binary.charCodeAt(i);
  }
  return new ImageData(buffer, width, height);
}

================
File: todo.md
================
# TODO

## roadmap

- [x] phase0: prototype/mock
- [x] phase1: drawing features (pen, eraser, layer)
- [ ] phase2: in-app settings (add+edit layers / add+edit pens / edit canvas size + misc)
- [ ] phase3: more ui feature (dialog, toast, internal log), import/export
- [ ] phase4: effects (js implementation)
- [ ] phase5: extra features (optimization, animation, etc)

## pen / tools

- [x] `tool:` pen
- [x] `tool:` eraser
- [ ] `tool:` erase along edge
- [ ] `tool:` spoiler
- [ ] `tool:` bucket(fill)
- [ ] `tool:` shape(circle)
- [ ] `tool:` shape(rect)
- [x] `ui:` size slider

## colors

- [x] `ui:` color picker
- [x] `ui:` color select(standard)

## layers

- [ ] `layer:` dot layer (w/dotMagnifier)
- [ ] `layer:` automate layer (w/dotMagnifier, mode: langton, life)
- [x] `ui:` layer list
- [x] `ui:` sorting
- [x] `ui:` enable/disable
- [x] `ui:` active layer selection
- [ ] `ui:` DSL edit button (-> GUI editor)
- [ ] `data:` compose layers into one image (image-level DSL)

## image_pool

- [x] `ui:` drag
- [x] `ui:` resize
- [ ] `ui:` image DSL edit button

## dsl(rust)

- [ ] `ui:` DSL GUI editor
- [ ] `ui:` DSL CLI editor

> TODO of nodes are in ./todo_dsl.md

## i/o

- [x] `data:` import: image to image_pool
- [x] `data:` import: instant bounce to active layer
- [x] `data:` layer-level export: w/o DSL
- [ ] `data:` layer-level export: with DSL
- [ ] `data:` image-level export: w/o DSL
- [ ] `data:` image-level export: with DSL

## misc

- [x] `misc:` document(dsl)
- [ ] `misc:` document(sledge)
- [ ] `ui:` setting screen
- [ ] `ui:` dialog
- [ ] `ui:` toast
- [ ] `ui:` logging in GUI
- [ ] `ui:` magnifier(mouse-pivot zoomed scope)
- [x] `ui:` companion

================
File: .stylelintrc.json
================
{
  "extends": ["stylelint-config-standard"],
  "plugins": ["stylelint-order"],
  "rules": {
    "selector-class-pattern": [
      "^[a-zA-Z0-9_-]+$",
      {
        "message": "Class names should use kebab-case or snake_case",
        "severity": "warning"
      }
    ],

    "font-family-no-missing-generic-family-keyword": null,

    "declaration-property-value-no-unknown": [
      true,
      {
        "ignoreProperties": {
          "justify-self": ["anchor-center"]
        }
      }
    ]
  }
}

================
File: dist-tcm/styles/components/companion.module.css.d.ts
================
declare const styles: {
  readonly "companion": string;
  readonly "fluffy": string;
  readonly "giggle": string;
  readonly "quote": string;
  readonly "quote_box": string;
  readonly "quote_box_container": string;
  readonly "root": string;
  readonly "wrapper": string;
};
export = styles;

================
File: dist-tcm/styles/reset.css.d.ts
================
export {};

================
File: src-tauri/src/commands/jpeg_glitch.rs
================
use image::{RgbImage, Rgba, RgbaImage};
use jpeg_decoder::Decoder;
use jpeg_encoder::{ColorType, Encoder};
use rand::rngs::StdRng;
use rand::{Rng, SeedableRng};
use std::io::Cursor;

pub fn jpeg_glitch(
    mut data: Vec<u8>,
    width: usize,
    height: usize,
    seed: u64,
    quality: u8,
    amount: f32, // 0.0〜1.0
) -> Result<Vec<u8>, String> {
    // RGBA → RGB
    let mut rgb = RgbImage::new(width as u32, height as u32);
    for (i, pixel) in data.chunks(4).enumerate() {
        let x = (i % width) as u32;
        let y = (i / width) as u32;
        rgb.put_pixel(x, y, image::Rgb([pixel[0], pixel[1], pixel[2]]));
    }

    // Encode to JPEG
    let mut jpeg_data: Vec<u8> = Vec::new();
    {
        let mut encoder = Encoder::new(&mut jpeg_data, quality);
        encoder
            .encode(&rgb, width as u16, height as u16, ColorType::Rgb)
            .map_err(|e| format!("JPEG encode failed: {e}"))?;
    }

    // Glitch parameters
    let mut rng = StdRng::seed_from_u64(seed);
    let start = 300;
    let length = jpeg_data.len().saturating_sub(start);
    let count = ((length as f32) * amount.clamp(0.0, 1.0)).round() as usize;

    for _ in 0..count {
        let idx = start + rng.random_range(0..length);
        jpeg_data[idx] = rng.random();
    }

    // Decode JPEG
    let mut decoder = Decoder::new(Cursor::new(&jpeg_data));
    let pixels = decoder
        .decode()
        .map_err(|e| format!("JPEG decode failed: {e}"))?;
    let info = decoder.info().ok_or("Missing JPEG info")?;

    // RGB → RGBA
    let mut rgba = RgbaImage::new(info.width as u32, info.height as u32);
    for (i, pixel) in pixels.chunks(3).enumerate() {
        let x = (i % info.width as usize) as u32;
        let y = (i / info.width as usize) as u32;
        rgba.put_pixel(x, y, Rgba([pixel[0], pixel[1], pixel[2], 255]));
    }

    Ok(rgba.into_raw())
}

================
File: src-tauri/src/commands/mod.rs
================
pub mod base64_utils;
pub use base64_utils::{decode_image_base64, encode_image_base64};

pub mod brightness;
pub use brightness::brightness;

pub mod grayscale;
pub use grayscale::grayscale;

pub mod invert;
pub use invert::invert;

pub mod jpeg_glitch;
pub use jpeg_glitch::jpeg_glitch;

pub mod sepia;
pub use sepia::sepia;

// デバッグ用など
#[tauri::command]
pub fn hello_from_rust(name: String) -> String {
    format!("Hello, {name}! This is Rust talking.")
}

================
File: src-tauri/src/pipeline/runner.rs
================
use super::parser::{parse_pipeline, PipelineNode};
use crate::commands::{brightness, grayscale, invert, jpeg_glitch, sepia};
use crate::commands::{decode_image_base64, encode_image_base64};

#[tauri::command]
pub fn run_pipeline(
    dsl: String,
    encoded: String,
    width: usize,
    height: usize,
) -> Result<String, String> {
    // DSL文字列をパースしてASTにする
    let nodes = parse_pipeline(&dsl)?;

    // 画像をデコードしてRGBAのバッファを作る
    let mut buffer = decode_image_base64(&encoded)?;

    // パイプラインノードを順に処理
    for node in nodes {
        match node {
            PipelineNode::Command { name, args } => {
                // matchで対応コマンドを呼び分け（必要なら引数あり）
                buffer = match name.as_str() {
                    "grayscale" => grayscale(buffer)?,
                    "jpeg_glitch" => {
                        if args.len() < 2 {
                            return Err("jpeg_glitch requires 2 arguments: seed, quality".into());
                        }
                        let seed = args[0].parse().map_err(|_| "Invalid seed")?;
                        let quality = args[1].parse().map_err(|_| "Invalid quality")?;
                        let amount = args[2].parse().map_err(|_| "Invalid amount")?;
                        jpeg_glitch(buffer, width, height, seed, quality, amount)?
                    }

                    "invert" => invert(buffer)?,
                    "sepia" => sepia(buffer)?,
                    "brightness" => {
                        if args.len() != 1 {
                            return Err("brightness requires 1 argument".to_string());
                        }
                        let delta: i8 = args[0]
                            .parse()
                            .map_err(|_| "Invalid number for brightness".to_string())?;

                        brightness(buffer, delta)?
                    }
                    _ => return Err(format!("Unknown command: {name}")),
                };
            }

            PipelineNode::Output { target: _ } => {
                // 今のところ *out(layerX) は文字列だけ保持 → JSに返すだけ
                // ここで base64 して return
                return encode_image_base64(&buffer);
            }
        }
    }

    Err("No *out(...) specified in pipeline.".to_string())
}

================
File: src/components/canvas/stacks/CanvasOverlaySVG.tsx
================
import { Component, For } from "solid-js";
import Tile from "~/models/layer_image/Tile";
import { currentTool } from "~/stores/internal/toolsStore";
import { canvasStore } from "~/stores/project/canvasStore";

const CanvasOverlaySVG: Component<{ dirtyRects?: Tile[] }> = (props) => {
  const borderWidth = () => canvasStore.canvas.width * canvasStore.zoom;
  const borderHeight = () => canvasStore.canvas.height * canvasStore.zoom;

  const zoomedPenSize = () => currentTool().size * canvasStore.zoom;

  return (
    <svg
      viewBox={`0 0 ${borderWidth()} ${borderHeight()}`}
      xmlns="http://www.w3.org/2000/svg"
      style={{
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        "pointer-events": "none",
        "image-rendering": "pixelated",
      }}
    >
      {/* border rect */}
      <rect
        width={borderWidth()}
        height={borderHeight()}
        fill="none"
        stroke="black"
        stroke-width={1}
        pointer-events="none"
      />

      {/* pen hover preview */}
      <rect
        width={zoomedPenSize()}
        height={zoomedPenSize()}
        x={
          Math.round(canvasStore.lastMouseOnZoomedCanvas.x) -
          zoomedPenSize() / 2
        }
        y={
          Math.round(canvasStore.lastMouseOnZoomedCanvas.y) -
          zoomedPenSize() / 2
        }
        fill="none"
        stroke="black"
        stroke-width={1}
        pointer-events="none"
      />

      <For each={props.dirtyRects}>
        {dirtyRect => {
          return <rect
            width={dirtyRect.globalTileSize * canvasStore.zoom}
            height={dirtyRect.globalTileSize * canvasStore.zoom}
            x={dirtyRect.getOffset().x * canvasStore.zoom}
            y={dirtyRect.getOffset().y * canvasStore.zoom}
            fill={dirtyRect.isDirty ? "#ff000060" : "#00ffff60"}
            stroke="none"
            pointer-events="none"
          />
        }}
      </For>
    </svg >
  );
};

export default CanvasOverlaySVG;

================
File: src/components/common/ImportImageButton.tsx
================
import { importImageToActiveLayer } from "~/io/internal/import"; // 上で作った関数

const ImportImageButton = () => {
  let fileInputRef: HTMLInputElement | undefined;

  const handleClick = () => {
    fileInputRef?.click(); // hidden input を手動でクリック
  };

  const handleFileChange = (e: Event) => {
    const target = e.currentTarget as HTMLInputElement;
    const file = target.files?.[0];
    if (file) {
      importImageToActiveLayer(file);
      target.value = ""; // 同じファイルを再選択可能にする
    }
  };

  return (
    <>
      <button onClick={handleClick}>Import</button>

      <input
        type="file"
        accept="image/*"
        ref={fileInputRef}
        style={{ display: "none" }}
        onChange={handleFileChange}
      />
    </>
  );
};

export default ImportImageButton;

================
File: src/components/SideSections.tsx
================
import { Component } from "solid-js";
import CanvasSettings from "./section/CanvasSettings";
import Color from "./section/Color";
import LayerList from "./section/LayerList";
import PenConfig from "./section/PenConfig";
import Project from "./section/Project";

import { sideAreaContent } from "~/styles/global.css";
import GlobalSettings from "./section/GlobalSettings";

const SideSections: Component<{}> = (props) => {
  return (
    <div class={sideAreaContent}>
      <a onClick={() => (window.location.href = "/")}>&lt; back</a>
      <Project />
      <Color />
      <PenConfig />
      <LayerList />
      <CanvasSettings />
      <GlobalSettings />
    </div>
  );
};

export default SideSections;

================
File: src/io/internal/import.ts
================
import { registerNewHistory } from '~/models/layer/layerImage'
import { layerImageStore } from '~/stores/project/layerImageStore'
import { layerStore } from '~/stores/project/layerStore'

// 画像ファイルをキャンバスに焼き込む（補完なし・左上合わせ・切り捨て）
export function importImageToActiveLayer(file: File) {
  const layerId = layerStore.activeLayerId
  if (!layerId) return

  const imageData = layerImageStore[layerId]?.current
  if (!imageData) {
    alert('現在のレイヤーに描画できません。')
    return
  }

  const img = new Image()
  const reader = new FileReader()

  reader.onload = (e) => {
    img.onload = () => {
      const w = imageData.width
      const h = imageData.height

      // オフスクリーンCanvasで描画 → ImageData取得
      const canvas = document.createElement('canvas')
      canvas.width = w
      canvas.height = h
      const ctx = canvas.getContext('2d')
      if (!ctx) return

      ctx.imageSmoothingEnabled = false
      ctx.clearRect(0, 0, w, h)
      ctx.drawImage(img, 0, 0, w, h) // 左上にそのまま描く（拡大/縮小なし）

      const importedData = ctx.getImageData(0, 0, w, h)
      registerNewHistory(layerId, importedData)
    }
    img.src = e.target?.result as string
  }

  reader.readAsDataURL(file)
}

================
File: src/models/dsl/DSLRunner.ts
================
import { decodeImageData, encodeImageData } from '~/utils/ImageUtils'
import { safeInvoke } from '~/utils/tauriUtils'
import { DSL } from './DSL'

export async function runDSL(
  dsl: DSL,
  image: ImageData
): Promise<ImageData | undefined> {
  const encoded = encodeImageData(image)

  const dslStr = dsl.build(true)
  if (dslStr === undefined) return

  const result = await safeInvoke<string>('run_pipeline', {
    dsl: dslStr,
    encoded,
    width: image.width,
    height: image.height,
  })

  if (!result) return
  return decodeImageData(result, image.width, image.height)
}

================
File: src/models/layer_canvas/LayerCanvasOperator.ts
================
import { LayerCanvasRef } from '~/components/canvas/stacks/LayerCanvas'
import { Vec2 } from '~/models/types/Vector'
import { currentTool } from '~/stores/internal/toolsStore'
import { hexToRGBA } from '~/utils/colorUtils'
import { Tool } from '../types/Tool'
import { setBottomInfo } from '~/components/BottomInfo'
import { DrawState } from './DrawState'
import { getToolInstance } from '../tools/ToolBase'
import LayerImageAgent from '../layer_image/LayerImageAgent'
import TileLayerImageAgent from '../layer_image/agents/TileLayerImageAgent'
import { setLayerImageStore } from '~/stores/project/layerImageStore'
import { reconcile } from 'solid-js/store'

export default class LayerCanvasOperator {
  constructor(private readonly getActiveLayerCanvas: () => LayerCanvasRef) {}

  public handleDraw(state: DrawState, position: Vec2, last?: Vec2) {
    const layerCanvasRef = this.getActiveLayerCanvas()
    const layer = layerCanvasRef.getLayer()
    const agent = layerCanvasRef.getAgent()
    const image = agent.getImage()
    if (!image) return

    position = this.getMagnificatedPosition(position, layer.dotMagnification)
    if (last) last = this.getMagnificatedPosition(last, layer.dotMagnification)

    const result = this.useTool(
      agent,
      state,
      image,
      currentTool(),
      position,
      last
    )

    if (result) {
      agent.setDrawingBuffer(result)
      if (state === DrawState.end) {
        agent.registerDiffAction()
        agent.setImage(result)
        setLayerImageStore(layer.id, 'current', reconcile(result))

        if (agent instanceof TileLayerImageAgent) {
          ;(agent as TileLayerImageAgent).resetAllDirtyStates()
        }
      }
    }
  }

  private useTool(
    agent: LayerImageAgent,
    state: DrawState,
    image: ImageData,
    tool: Tool,
    position: Vec2,
    last?: Vec2
  ) {
    const toolInstance = getToolInstance(tool.type)
    const toolArgs = {
      image,
      position,
      lastPosition: last,
      size: tool.size,
      color: hexToRGBA(tool.color),
    }
    const startTime = Date.now()
    let isDrawnAction
    switch (state) {
      case DrawState.start:
        isDrawnAction = toolInstance.onStart(agent, toolArgs)
        break
      case DrawState.move:
        isDrawnAction = toolInstance.onMove(agent, toolArgs)
        break
      case DrawState.end:
        isDrawnAction = toolInstance.onEnd(agent, toolArgs)
        break
    }
    const endTime = Date.now()
    if (isDrawnAction) {
      if (agent instanceof TileLayerImageAgent) {
        setBottomInfo(
          `${tool.type} finished. ${endTime - startTime} ms. (updated ${(agent as TileLayerImageAgent).getDirtyTiles().length} dirty tiles)`
        )
      } else {
        setBottomInfo(`${tool.type} finished. ${endTime - startTime} ms.`)
      }
    }
    return image
  }

  private getMagnificatedPosition(position: Vec2, dotMagnification: number) {
    return {
      x: Math.floor(position.x / dotMagnification),
      y: Math.floor(position.y / dotMagnification),
    }
  }
}

================
File: src/models/layer_image/Tile.ts
================
import { RGBAColor } from '~/utils/colorUtils'
import { Vec2 } from '../types/Vector'

export interface TileIndex {
  row: number
  column: number
}

export default class Tile {
  // 一連の動作全体で変更があったか（累計表示、UI表示用）
  public isDirtyThroughAction: boolean
  // 前回の描画更新から変更があったか（canvas更新用）
  public isDirty: boolean

  // このタイルが単色（すべて同一RGBA）なら true
  public isUniform = false
  // 単色時のカラーキャッシュ
  public uniformColor: RGBAColor | undefined = undefined

  constructor(
    public readonly row: number,
    public readonly column: number,
    public readonly globalTileSize: number
  ) {
    this.isDirtyThroughAction = false
    this.isDirty = false
  }

  toString(): string {
    return `Tile[${this.row},${this.column}]`
  }

  public getOffset(): Vec2 {
    return {
      x: this.column * this.globalTileSize,
      y: this.row * this.globalTileSize,
    }
  }

  public isInBounds(positionInTile: Vec2) {
    return (
      positionInTile.x >= 0 &&
      positionInTile.x < this.globalTileSize &&
      positionInTile.y >= 0 &&
      positionInTile.y < this.globalTileSize
    )
  }

  updateState() {}
}

================
File: src/models/tools/ToolBase.ts
================
import { RGBAColor } from '~/utils/colorUtils'
import LayerImageAgent from '../layer_image/LayerImageAgent'
import { ToolType } from '../types/Tool'
import { Vec2 } from '../types/Vector'
import { EraserTool } from './eraser/EraserTool'
import { FillTool } from './fill/FillTool'
import { PenTool } from './pen/PenTool'

export interface Tool {
  onStart: (agent: LayerImageAgent, args: ToolArgs) => boolean

  onMove: (agent: LayerImageAgent, args: ToolArgs) => boolean

  onEnd: (agent: LayerImageAgent, args: ToolArgs) => boolean
}

export interface ToolArgs {
  position: Vec2
  lastPosition?: Vec2
  color: RGBAColor // RGBA
  size?: number
  // TODO: pressure, tilt, ...
}

export const getToolInstance = (toolType: ToolType) => {
  switch (toolType) {
    case ToolType.Pen:
      return new PenTool()
    case ToolType.Eraser:
      return new EraserTool()
    case ToolType.Fill:
      return new FillTool()

    default:
      return new PenTool()
  }
}

================
File: src/models/types/Canvas.ts
================
export type Canvas = {
  width: number;
  height: number;
};

export const createCanvas = (width = 800, height = 1200): Canvas => {
  return {
    width,
    height,
  };
};

================
File: src/models/types/Layer.ts
================
import { DSL } from "~/models/dsl/DSL";

export enum LayerType {
  Dot,
  Image,
  Automate,
}

export type Layer = {
  id: string;
  name: string;
  type: LayerType;
  typeDescription: string; // 各タイプの説明
  enabled: boolean;
  dotMagnification: number;
  dsl: DSL;
};

================
File: src/stores/global/globalStore.ts
================
import { createStore } from 'solid-js/store'
import { saveGlobalSettings } from '~/io/global/globalIO'

// project
export type FileLocation = {
  path: string
  name: string
}

export type CanvasRenderingMode = 'auto' | 'pixelated' | 'crispEdges'

export const [globalStore, setGlobalStore] = createStore({
  recentOpenedFiles: [
    {
      path: 'C:\\Users\\innsb\\Documents',
      name: 'project.sledge',
    },
  ],

  canvasRenderingMode: 'auto' as CanvasRenderingMode,
})

export const addRecent = (loc: FileLocation) => {
  const path = loc.path
  const name = loc.name

  // add to recent
  setGlobalStore((store) => {
    console.log('path: ' + path)
    console.log('name: ' + name)
    if (name && path && store.recentOpenedFiles) {
      // 履歴にあっても一旦削除
      let oldRecentFiles = store.recentOpenedFiles.filter((f) => {
        return f.name !== name || f.path !== path?.toString()
      })
      // その後、一番上に追加
      const newRecentFiles: FileLocation[] = [
        {
          name: name,
          path: path,
        },
        ...oldRecentFiles,
      ]
      setGlobalStore('recentOpenedFiles', newRecentFiles)
      saveGlobalSettings()
    }
    return store
  })
}

================
File: src/stores/project/projectStore.ts
================
import { trackStore } from '@solid-primitives/deep'
import { createEffect } from 'solid-js'
import { createStore } from 'solid-js/store'
import { canvasStore } from './canvasStore'
import { layerImageStore } from './layerImageStore'
import { layerStore } from './layerStore'

// project
export const [projectStore, setProjectStore] = createStore({
  name: '',
  path: '',
  isProjectChangedAfterSave: false,
})

createEffect(() => {
  trackStore(canvasStore.canvas)
  trackStore(layerImageStore)
  trackStore(layerStore)
  setProjectStore('isProjectChangedAfterSave', true)
})

================
File: src/styles/components/canvas/controls.module.css
================
* {
  z-index: 1000;
}

.cursor {
  background-color: black;
  height: 4px;
  left: 220px;
  position: absolute;
  top: 170px;
  width: 4px;
}

.top-right-button-container {
  display: flex;
  flex-direction: row;
  gap: 10px;
  position: absolute;
  right: 30px;
  top: 20px;
}

.top-right-nav {
  display: flex;
  flex-direction: row;
  gap: 25px;
  position: absolute;
  right: 30px;
  top: 30px;
}

.bottom-history {
  bottom: 50px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  position: absolute;
}

.history-row {
  display: flex;
  gap: 20px;
  opacity: 0.2;
  width: 60%;
}

.history-text {
  white-space: nowrap;
}

.undo_redo {
  cursor: pointer;
  height: 24px;
  image-rendering: pixelated;
  padding: 8px;
  pointer-events: all;
  width: 24px;
}

================
File: src-tauri/capabilities/default.json
================
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "enables the default permissions",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "dialog:default",
    "fs:default",

    "dialog:allow-save",
    "dialog:allow-open",

    "fs:allow-open",
    "fs:allow-write",
    "fs:allow-read",
    "fs:allow-rename",
    "fs:allow-mkdir",
    "fs:allow-remove",
    "fs:allow-write-text-file",
    "fs:allow-read-text-file",
    "fs:read-all",
    {
      "identifier": "fs:scope",
      "allow": [{ "path": "**" }]
    },

    "core:window:allow-hide",
    "core:window:allow-minimize",
    "core:window:allow-maximize",
    "core:window:allow-close",
    "core:window:allow-toggle-maximize",
    "core:window:allow-start-dragging"
  ]
}

================
File: src/components/common/Slider.tsx
================
import styles from "@styles/components/slider.module.css";
import { Component, createSignal } from "solid-js";

interface SliderProps {
  min: number;
  max: number;
  default: number;
  allowFloat?: boolean;

  onValueChanged?: (newValue: number) => void;
}

const Slider: Component<SliderProps> = (props) => {
  let sliderRef: HTMLDivElement | undefined;
  const [isDrag, setDrag] = createSignal(false);
  const [value, setValue] = createSignal(props.default);

  const percent = () => ((value() - props.min) / (props.max - props.min)) * 100;

  const handlePointerDown = (e: PointerEvent) => {
    setDrag(true);

    window.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("pointerup", handlePointerUp);
  };

  const handlePointerMove = (e: PointerEvent) => {
    if (!sliderRef || !isDrag()) return;
    const rect = sliderRef.getBoundingClientRect();
    let pos = e.clientX - rect.left;
    pos = Math.max(0, Math.min(pos, rect.width)); // clamp

    const newValueRaw =
      props.min + (pos / rect.width) * (props.max - props.min);
    const newValue = props.allowFloat ? newValueRaw : Math.round(newValueRaw);
    setValue(newValue);
    if (props.onValueChanged) props.onValueChanged(newValue);
  };

  const handlePointerUp = (e: PointerEvent) => {
    setDrag(false);
    window.removeEventListener("pointermove", handlePointerMove);
    window.removeEventListener("pointerup", handlePointerUp);
  };

  const onLineClick = (e: MouseEvent) => {
    if (!sliderRef) return;
    const rect = sliderRef.getBoundingClientRect();
    let pos = e.clientX - rect.left;
    pos = Math.max(0, Math.min(pos, rect.width)); // clamp

    const newValueRaw =
      props.min + (pos / rect.width) * (props.max - props.min);
    const newValue = props.allowFloat ? newValueRaw : Math.round(newValueRaw);
    setValue(newValue);
    if (props.onValueChanged) props.onValueChanged(newValue);
  };

  return (
    <div class={styles.root}>
      <div class={styles.slider} ref={sliderRef}>
        <div
          class={styles["line-hitbox"]}
          onPointerDown={handlePointerDown}
          onClick={onLineClick}
        >
          <div class={styles.line} />
        </div>
        <div style={{ left: `${percent()}%` }} class={styles.handle} />
      </div>
    </div>
  );
};

export default Slider;

================
File: src/components/section/Project.tsx
================
import { Component, createSignal } from "solid-js";
import { saveProject } from "~/io/project/project";

import { exportActiveLayerUpscaled } from "~/io/internal/export";
import { projectStore, setProjectStore } from "~/stores/project/projectStore";
import { projectNameInput } from "~/styles/section/project.css";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";
import { flexCol, flexRow } from "~/styles/snippets.css";

const Project: Component<{}> = (props) => {
  const [saveLog, setSaveLog] = createSignal<string | undefined>(undefined);

  const save = () => {
    if (projectStore.name && projectStore.path) {
      // 上書き保存
      saveProject(`${projectStore.path}`).then(() => {
        setSaveLog("saved!");
        setProjectStore("isProjectChangedAfterSave", false);
      });
    } else {
      saveProject().then(() => {
        setSaveLog("saved!");
        setProjectStore("isProjectChangedAfterSave", false);
      });
    }
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>project.</p>
      <div class={sectionContent}>
        <div class={flexCol}>
          <input
            class={projectNameInput}
            type="text"
            name="height"
            onChange={(e) => {
              setProjectStore("name", e.target.value);
            }}
            value={projectStore.name}
            placeholder="project name"
            autocomplete="off"
            required
          />

          {/* <p class={styles.project_file_path}>{projectStore.path}</p> */}
        </div>
        {/* <button class={styles.loadsave_button} onClick={() => importProjectJsonFromFileSelection()}>
                        load.
                    </button> */}

        <div
          class={flexRow}
          style={{ "align-items": "center", "margin-top": "12px" }}
        >
          <button onClick={() => exportActiveLayerUpscaled()}>export.</button>
          {/*   {!projectStore.isProjectChangedAfterSave && <p class={styles.save_log}>{saveLog()}</p>} */}
        </div>
      </div>
    </div>
  );
};

export default Project;

================
File: src/components/TitleBar.tsx
================
import { Window } from "@tauri-apps/api/window";
import { createSignal } from "solid-js";
import {
  titleBarControlButtonImg,
  titleBarControlCloseButton,
  titleBarControlMaximizeButton,
  titleBarControlMinimizeButton,
  titleBarControls,
  titleBarRoot,
  titleBarTitle,
} from "~/styles/components/title_bar.css";

export default function TitleBar() {
  const appWindow = new Window("main");

  const [isMaximized, setMaximized] = createSignal(false);

  appWindow.onResized(async (handler) => {
    console.log("resize");
    setMaximized(await appWindow.isMaximized());
  });

  return (
    <header style={{ "pointer-events": "all" }}>
      <nav class={titleBarRoot} data-tauri-drag-region="p, button">
        <p class={titleBarTitle}>sledge.</p>
        <div class={titleBarControls}>
          <button
            class={titleBarControlMinimizeButton}
            onClick={() => appWindow.minimize()}
          >
            <img class={titleBarControlButtonImg} src={"/minimize.png"} />
          </button>

          <button
            class={titleBarControlMaximizeButton}
            onClick={() => appWindow.toggleMaximize()}
          >
            <img
              class={titleBarControlButtonImg}
              src={isMaximized() ? "/leave_maximize.png" : "/maximize.png"}
            />
          </button>

          <button
            class={titleBarControlCloseButton}
            onClick={() => appWindow.close()}
          >
            <img class={titleBarControlButtonImg} src={"/close.png"} />
          </button>
        </div>
      </nav>
    </header>
  );
}

================
File: src/io/project/project.ts
================
// src/io/project.ts
import { path } from '@tauri-apps/api'
import { open as dialogOpen, save } from '@tauri-apps/plugin-dialog'
import {
  BaseDirectory,
  mkdir,
  readTextFile,
  writeTextFile,
} from '@tauri-apps/plugin-fs'
import { initLayerImage } from '~/models/layer/layerImage'
import { Layer } from '~/models/types/Layer'
import { addRecent } from '~/stores/global/globalStore'
import {
  adjustZoomToFit,
  canvasStore,
  centeringCanvas,
  setCanvasStore,
} from '~/stores/project/canvasStore'
import {
  layerImageStore,
  setLayerImageStore,
} from '~/stores/project/layerImageStore'
import {
  findLayerById,
  layerStore,
  setLayerStore,
} from '~/stores/project/layerStore'
import { projectStore, setProjectStore } from '~/stores/project/projectStore'
import { decodeImageData, encodeImageData } from '~/utils/ImageUtils'
import { getFileNameAndPath } from '~/utils/pathUtils'

export async function importProjectJsonFromFileSelection(): Promise<
  string | undefined
> {
  const home = await path.homeDir()
  const file = await dialogOpen({
    multiple: false,
    directory: false,
    defaultPath: await path.join(home, 'sledge'),
    filters: [
      {
        name: 'sledge files',
        extensions: ['sledge'],
      },
    ],
  })
  if (!file) {
    console.log('ファイルが選択されていません')
    return undefined
  }
  console.log(file)
  const jsonText = await readTextFile(file)
  const projectJson = JSON.parse(jsonText)

  await importProjectJson(projectJson)

  return file
}

export async function importProjectJsonFromPath(filePath: string) {
  if (!filePath) {
    console.log('ファイルが選択されていません')
    return
  }
  const jsonText = await readTextFile(filePath)
  const projectJson = JSON.parse(jsonText)

  importProjectJson(projectJson)
}

export async function importProjectJson(projectJson: any) {
  if (projectJson.project) {
    console.log(projectJson.project)
    setProjectStore('name', projectJson.project.name)
    setProjectStore('path', projectJson.project.path)
  }

  if (projectJson.canvas) {
    const { width, height } = projectJson.canvas
    setCanvasStore('canvas', 'width', width)
    setCanvasStore('canvas', 'height', height)
  }

  if (projectJson.images) {
    setLayerImageStore({})
    Object.keys(projectJson.images).forEach((id) => {
      console.log(`read ${id}`)
      const imageData = projectJson.images[id]
      console.log(imageData)
      initLayerImage(id, Number(imageData.dotMagnification || 1))
      setLayerImageStore(
        id,
        'current',
        decodeImageData(
          imageData.current,
          Number(imageData.width),
          Number(imageData.height)
        )
      )
    })
  }

  if (
    projectJson.layer &&
    projectJson.layer.layers &&
    Array.isArray(projectJson.layer.layers)
  ) {
    const layers: Layer[] = []
    projectJson.layer.layers.map((l: any) => {
      layers.push({
        ...l,
        dsl: undefined,
      } as Layer)
    })

    setLayerStore('layers', layers)
    setLayerStore('activeLayerId', projectJson.layer.activeLayerId)
  }

  adjustZoomToFit()
  centeringCanvas()
}

export const parseCurrentProject = (): string => {
  return JSON.stringify({
    project: projectStore,
    canvas: canvasStore.canvas,
    images: Object.fromEntries(
      Object.entries(layerImageStore).map(([id, state]) => [
        id,
        {
          current: encodeImageData(state.current),
          width: state.current.width,
          height: state.current.height,
          dotMagnification: findLayerById(id)?.dotMagnification,
        },
      ])
    ),
    layer: {
      layers: layerStore.layers.map((layer) => ({
        ...layer,
        dsl: undefined, // TODO: save dsl
      })),
      activeLayerId: layerStore.activeLayerId,
    },
  })
}

export async function saveProject(existingPath?: string) {
  let selectedPath: String | null
  if (existingPath) {
    selectedPath = existingPath
  } else {
    try {
      await mkdir('sledge', {
        baseDir: BaseDirectory.Home,
        recursive: true,
      })
    } catch (e) {
      console.warn('ディレクトリ作成スキップまたは失敗:', e)
    }

    const home = await path.homeDir()
    selectedPath = await save({
      title: 'Sledge プロジェクトを保存',
      defaultPath: await path.join(home, `sledge/${projectStore.name}.sledge`),
      filters: [{ name: 'Sledge Project', extensions: ['sledge'] }],
    })
  }

  if (typeof selectedPath === 'string') {
    setProjectStore('path', selectedPath)
    const data = parseCurrentProject()
    await writeTextFile(selectedPath, data)
    console.log('プロジェクト保存:', selectedPath)

    const fileLoc = getFileNameAndPath(selectedPath)
    if (fileLoc !== undefined) addRecent(fileLoc)
  } else {
    console.log('保存キャンセルされました')
  }
}

================
File: src/models/dsl/DSL.ts
================
import { SledgeNode } from "~/models/dsl/nodes/DSLNodes";
import { findLayerById } from "~/stores/project/layerStore";
import { LayerIn } from "./nodes/pass/LayerIn";
import { LayerOut } from "./nodes/pass/LayerOut";

export class DSL {
  layerIn: LayerIn;
  readonly nodes: SledgeNode[];
  layerOut: LayerOut;

  constructor(inLayerId: string, outLayerId: string) {
    this.layerIn = new LayerIn(inLayerId);
    this.nodes = [];
    this.layerOut = new LayerOut(outLayerId);
  }

  public addNode(node: SledgeNode) {
    this?.nodes.push(node);
  }

  public build(exceptIn: boolean = false): string | undefined {
    const nodes = exceptIn
      ? [...this.nodes, this.layerOut]
      : [this.layerIn, ...this.nodes, this.layerOut];

    let nodeStrings: string[] = [];
    let isAllNodeParseSuccessful = true;
    nodes.forEach((node, i) => {
      const nodeStr = node.getNodeString();
      if (nodeStr !== undefined) nodeStrings.push(nodeStr);
      else {
        isAllNodeParseSuccessful = false;
        throw `DSL parse failed in: ${node.name} [${i}]`;
      }
    });

    if (isAllNodeParseSuccessful) {
      // if all nodes parsed successfully
      return nodeStrings.join(" > "); // in(inLayerId) > out(outLayerId) by default
    } else {
      // if some nodes failed to parse
      return undefined;
    }
  }

  public toString(): string {
    let str = this.build();
    if (str === undefined) throw "DSL parse failed.";
    else {
      // 読みやすくする
      const inId = this.layerIn.layerId;
      const outId = this.layerOut.layerId;
      if (inId !== undefined)
        str = str.replaceAll(inId, `${findLayerById(inId)?.name || "N/A"} ID`);
      if (outId !== undefined)
        str = str.replaceAll(
          outId,
          `${findLayerById(outId)?.name || "N/A"} ID`,
        );
      str = str.replaceAll(" > ", "\n> ");
      return str;
    }
  }
}

================
File: src/models/layer_image/agents/RawLayerImageAgent.ts
================
import { Vec2 } from '~/models/types/Vector'
import LayerImageAgent from '../LayerImageAgent'
import { PixelDiff } from '../HistoryManager'
import { RGBAColor } from '~/utils/colorUtils'

export default class RawLayerImageAgent extends LayerImageAgent {
  putImageInto(ctx: CanvasRenderingContext2D) {
    ctx.putImageData(this.image, 0, 0)
  }

  putDrawingBufferInto(ctx: CanvasRenderingContext2D) {
    if (this.drawingBuffer) ctx.putImageData(this.drawingBuffer, 0, 0)
  }

  public setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.setPixelInPosition(
      position,
      color,
      excludePositionMatch,
      excludeColorMatch
    )
  }

  public deletePixel(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.deletePixelInPosition(
      position,
      excludePositionMatch,
      excludeColorMatch
    )
  }

  public getPixel(position: Vec2): RGBAColor {
    const i = (position.y * this.image.width + position.x) * 4
    const d = this.image.data
    return [d[i], d[i + 1], d[i + 2], d[i + 3]]
  }
}

================
File: src/models/layer_image/agents/TileLayerImageAgent.ts
================
import { HistoryManager, TileDiff } from './../HistoryManager'
import { Vec2 } from '~/models/types/Vector'
import LayerImageAgent from '../LayerImageAgent'
import Tile, { TileIndex } from '../Tile'
import { PixelDiff } from '../HistoryManager'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'

export default class TileLayerImageAgent extends LayerImageAgent {
  readonly TILE_SIZE = 16

  private tiles: Tile[][] = []

  getTile(index: TileIndex) {
    // console.log(`tile access to ${index.row}. ${index.column}`)
    return this.tiles[index.row][index.column]
  }

  getTiles() {
    return this.tiles
  }

  constructor(imageData: ImageData, historyManager: HistoryManager) {
    super(imageData, historyManager)
  }

  initTile() {
    const tileRowCount = Math.ceil(this.getHeight() / this.TILE_SIZE)
    const tileColumnCount = Math.ceil(this.getWidth() / this.TILE_SIZE)
    for (let row = 0; row < tileRowCount; row++) {
      this.tiles[row] = []
      for (let column = 0; column < tileColumnCount; column++) {
        this.tiles[row][column] = new Tile(row, column, this.TILE_SIZE)
      }
    }
    this.scanAllTilesUniformity()
  }

  scanAllTilesUniformity() {
    const { TILE_SIZE } = this
    const w = this.getWidth()
    const h = this.getHeight()

    for (const row of this.tiles) {
      for (const tile of row) {
        const { x: ox, y: oy } = tile.getOffset()

        // ①タイルの左上ピクセルを基準色に
        const base = this.getPixel({ x: ox, y: oy })

        let uniform = true
        // ②タイル内を走査（画像端は超えないよう clamp）
        for (let dy = 0; dy < TILE_SIZE && uniform; dy++) {
          const py = oy + dy
          if (py >= h) break
          for (let dx = 0; dx < TILE_SIZE; dx++) {
            const px = ox + dx
            if (px >= w) break
            if (!colorMatch(this.getPixel({ x: px, y: py }), base)) {
              uniform = false
              break
            }
          }
        }
        // ③結果を保存
        tile.isUniform = uniform
        tile.uniformColor = uniform ? base : undefined
      }
    }
  }

  setImage(image: ImageData): void {
    super.setImage(image)
    this.initTile()
  }

  putImageInto(ctx: CanvasRenderingContext2D) {
    if (this.getDirtyTiles().length > 0) {
      this.putOnlyForDirtyTiles(ctx, this.image)
    }
  }

  putDrawingBufferInto(ctx: CanvasRenderingContext2D) {
    if (this.getDirtyTiles().length > 0) {
      if (this.drawingBuffer) this.putOnlyForDirtyTiles(ctx, this.drawingBuffer)
    }
  }

  private putOnlyForDirtyTiles(
    ctx: CanvasRenderingContext2D,
    image: ImageData
  ) {
    const dirtyTiles = this.getDirtyTiles()

    dirtyTiles.forEach((dirtyTile) => {
      const offset = dirtyTile.getOffset()
      ctx.putImageData(
        image,
        0,
        0,
        offset.x,
        offset.y,
        this.TILE_SIZE,
        this.TILE_SIZE
      )
    })

    this.resetDirtyStates()
  }

  public getTileIndex(layerPosition: Vec2): TileIndex {
    const row = Math.floor(layerPosition.y / this.TILE_SIZE)
    const column = Math.floor(layerPosition.x / this.TILE_SIZE)
    return { row, column }
  }

  public resetDirtyStates() {
    this.tiles = this.tiles.map((tR) => {
      tR = tR.map((t) => {
        t.isDirty = false
        return t
      })
      return tR
    })
  }

  public resetAllDirtyStates() {
    this.tiles = this.tiles.map((tR) => {
      tR = tR.map((t) => {
        t.isDirty = false
        t.isDirtyThroughAction = false
        return t
      })
      return tR
    })
  }

  public getDirtyTiles(): Tile[] {
    return this.tiles.flatMap((tR) => tR.filter((t) => t.isDirty))
  }
  public getDirtyTilesInAction(): Tile[] {
    return this.tiles.flatMap((tR) => tR.filter((t) => t.isDirtyThroughAction))
  }

  protected undoTileDiff(tileDiff: TileDiff): void {
    console.log(`tilediff. fill ${tileDiff.beforeColor}`)
    if (tileDiff.beforeColor)
      this.fillWholeTile(tileDiff.index, tileDiff.beforeColor, false)
  }

  protected redoTileDiff(tileDiff: TileDiff): void {
    console.log(`tilediff. fill ${tileDiff.afterColor}`)
    this.fillWholeTile(tileDiff.index, tileDiff.afterColor, false)
  }

  public setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    const result = this.setPixelInPosition(
      position,
      color,
      excludePositionMatch,
      excludeColorMatch
    )
    if (result !== undefined) {
      const tileIndex = this.getTileIndex(position)
      this.tiles[tileIndex.row][tileIndex.column].isDirty = true
      this.tiles[tileIndex.row][tileIndex.column].isDirtyThroughAction = true

      const tile = this.getTile(tileIndex)
      if (
        tile.isUniform &&
        tile.uniformColor !== undefined &&
        colorMatch(tile.uniformColor, color)
      ) {
        this.tiles[tileIndex.row][tileIndex.column].isUniform = false
        this.tiles[tileIndex.row][tileIndex.column].uniformColor = undefined
      }
    }
    return result
  }

  fillWholeTile(index: TileIndex, color: RGBAColor, collectDiff = true) {
    const tile = this.getTile(index)
    if (
      tile.isUniform &&
      tile.uniformColor &&
      colorMatch(tile.uniformColor, color)
    )
      return

    const [r, g, b, a] = color
    const { x: ox, y: oy } = tile.getOffset()
    const { TILE_SIZE } = this
    const { width, data } = this.image

    for (let dy = 0; dy < TILE_SIZE; dy++) {
      const y = oy + dy
      if (y >= this.getHeight()) break
      let i = (y * width + ox) * 4 // 行頭インデックス
      for (let dx = 0; dx < TILE_SIZE; dx++) {
        const x = ox + dx
        if (x >= this.getWidth()) break

        data[i] = r
        data[i + 1] = g
        data[i + 2] = b
        data[i + 3] = a
        i += 4
      }
    }

    if (collectDiff)
      this.addDiffs([
        {
          kind: 'tile',
          index,
          beforeColor: tile.uniformColor,
          afterColor: [r, g, b, a],
        },
      ])

    // 状態更新
    tile.isDirty = tile.isDirty = true
    tile.isDirty = tile.isDirtyThroughAction = true
    tile.isUniform = true
    tile.uniformColor = color
  }

  public deletePixel(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    const result = this.deletePixelInPosition(
      position,
      excludePositionMatch,
      excludeColorMatch
    )
    if (result !== undefined) {
      const tileIndex = this.getTileIndex(position)
      this.tiles[tileIndex.row][tileIndex.column].isDirty = true
      this.tiles[tileIndex.row][tileIndex.column].isDirtyThroughAction = true
    }
    return result
  }

  public getPixel(position: Vec2): RGBAColor {
    const i = (position.y * this.image.width + position.x) * 4
    const d = this.image.data

    return [d[i], d[i + 1], d[i + 2], d[i + 3]]
  }

  public getTileRowCount() {
    return this.tiles.length
  }

  public getTileColumnCount() {
    return this.tiles[0].length
  }

  public isTileInBounds(index: TileIndex) {
    return (
      index.row >= 0 &&
      index.row < this.getTileRowCount() &&
      index.column >= 0 &&
      index.column < this.getTileColumnCount()
    )
  }
}

================
File: src/models/tools/eraser/EraserTool.ts
================
import { Tool, ToolArgs } from '../ToolBase'
import { drawCompletionLine, drawSquarePixel } from '../DrawUtils'
import LayerImageAgent from '~/models/layer_image/LayerImageAgent'

export class EraserTool implements Tool {
  onStart(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }

  onMove(agent: LayerImageAgent, { position, lastPosition, size }: ToolArgs) {
    if (!size) return false

    drawSquarePixel(position, size, (px, py) => {
      const diff = agent.deletePixel({ x: px, y: py }, true, true)
      if (diff !== undefined) {
        agent.addDiffs([diff])
      }
    })

    if (lastPosition !== undefined) {
      drawCompletionLine(position, lastPosition, (x, y) => {
        drawSquarePixel({ x, y }, size, (px, py) => {
          const diff = agent.deletePixel({ x: px, y: py }, true, true)
          if (diff !== undefined) {
            agent.addDiffs([diff])
          }
        })
      })
    }

    return true
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }
}

================
File: src/models/tools/fill/FillTool.ts
================
import { Tool, ToolArgs } from '../ToolBase'
import LayerImageAgent from '~/models/layer_image/LayerImageAgent'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'
import { Vec2 } from '~/models/types/Vector'
import { TileFloodFill } from './TileFloodFill'

export interface FillProps {
  agent: LayerImageAgent
  color: RGBAColor
  position: Vec2
}
export interface Fill {
  fill: (props: FillProps) => void
}

export class FillTool implements Tool {
  onStart(agent: LayerImageAgent, { position, lastPosition, color }: ToolArgs) {
    const fill = new TileFloodFill()

    fill.fill({ agent, color, position })

    return true
  }

  onMove(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }

  onEnd(agent: LayerImageAgent, args: ToolArgs) {
    return false
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "allowJs": true,
    "strict": true,
    "noEmit": true,
    "isolatedModules": true,
    "paths": {
      "~/*": ["./src/*", "./dist-tcm/*"],
      "@styles/*": ["./src/styles/*", "./dist-tcm/styles/*"]
    },
    "rootDirs": ["src", "dist-tcm"]
  }
}

================
File: src/components/common/ColorBox.tsx
================
import { Component } from "solid-js";
import { toolStore } from "~/stores/internal/toolsStore";
import { sayRandomQuote } from "./companion/QuotePool";

interface ColorBoxProps {
  enableUsingSelection?: boolean;
  sizePx?: number;
  color: string;
  onClick?: (color: string) => void;
}

const ColorBox: Component<ColorBoxProps> = (props: ColorBoxProps) => {
  const size = props.sizePx || 10;

  const isSelected = () =>
    props.enableUsingSelection &&
    toolStore.tools[toolStore.usingIndex].color === props.color;
  const isWhiteOrNone = () =>
    props.color === "none" || props.color.toLowerCase() === "#ffffff";

  const onColorClicked = (color: string) => {
    sayRandomQuote("color-pick", { color: color });
    if (props.onClick) props.onClick(color);
  };

  return (
    <div
      style={{
        position: "relative",
        display: "flex",
        width: `${size}px`,
        height: `${size}px`,
        "align-items": "center",
        "justify-content": "center",
        cursor: "pointer",
        "background-color": props.color,
        border:
          isWhiteOrNone() || isSelected()
            ? "0.05rem solid black"
            : "0.05rem solid transparent",
      }}
      onClick={() => {
        onColorClicked(props.color);
      }}
    >
      {props.enableUsingSelection && isSelected() && (
        <div
          style={{
            width: `${Math.round(size / 3)}px`,
            height: `${Math.round(size / 3)}px`,
            margin: 0,
            padding: 0,
            "background-color": "black",
          }}
          onClick={() => {
            onColorClicked(props.color);
          }}
        />
      )}
    </div>
  );
};

export default ColorBox;

================
File: src/components/common/DSLEditor.tsx
================
import { Component, createSignal, For, onMount } from "solid-js";
import { ALL_NODES } from "~/dsl/nodes/AvailableNodes";
import {
  activeIndex,
  activeLayer,
  setLayerStore,
} from "~/stores/project/layerStore";

const DSLEditor: Component<{}> = (props) => {
  let [activeDSLStr, setDSLStr] = createSignal("");

  onMount(() => {
    setDSLStr(activeLayer()?.dsl.toString() || "");
  });

  return (
    <div style={{ display: "flex", position: "relative" }}>
      <p style={{ "white-space": "pre-wrap" }}>{activeDSLStr()}</p>
      <div
        style={{
          display: "flex",
          "flex-direction": "column",
          gap: "10px",
          "z-index": 10,
        }}
      >
        <p>select command.</p>
        <For each={ALL_NODES}>
          {(node) => {
            return (
              <a
                onClick={async () => {
                  const dsl = activeLayer()?.dsl;
                  if (dsl === undefined) return;
                  dsl.addNode(node);
                  setLayerStore("layers", activeIndex(), "dsl", dsl);
                  setDSLStr(dsl.toString());
                }}
                style={{ cursor: "pointer" }}
              >
                &lt; {node.name}
              </a>
            );
          }}
        </For>
      </div>
      ;
    </div>
  );
};

export default DSLEditor;

================
File: src/main.tsx
================
import { render } from "solid-js/web";
import App from "./app";
import "./styles/global.css";
import "./styles/reset.css";

render(() => <App />, document.getElementById("root")!);

================
File: src/models/layer_image/LayerImageAgent.ts
================
import { Vec2 } from '~/models/types/Vector'
import {
  Diff,
  DiffAction,
  getDiffHash,
  HistoryManager,
  PixelDiff,
  TileDiff,
} from './HistoryManager'
import { colorMatch, RGBAColor } from '~/utils/colorUtils'
import { setBottomInfo } from '~/components/BottomInfo'

interface DrawingBufferChangeEvent {}
interface ImageChangeEvent {}

// それぞれのLayerCanvasの描画、表示までの処理過程を記述するクラス
export default abstract class LayerImageAgent {
  protected image: ImageData
  protected drawingBuffer: ImageData | undefined
  protected historyManager

  protected onImageChangedListeners: {
    [key: string]: (e: ImageChangeEvent) => void
  } = {}
  protected onDrawingBufferChangedListeners: {
    [key: string]: (e: DrawingBufferChangeEvent) => void
  } = {}

  constructor(imageData: ImageData, historyManager?: HistoryManager) {
    this.image = imageData
    this.drawingBuffer = imageData
    this.historyManager = historyManager
  }

  getHistoryManager() {
    return this.historyManager
  }

  getImage() {
    return this.image
  }

  setImage(image: ImageData, silentlySet?: boolean) {
    this.image = image
    if (silentlySet) this.callOnImageChangeListeners()
    this.resetDrawingBuffer()
  }

  getDrawingBuffer() {
    return this.drawingBuffer
  }

  setDrawingBuffer(imageData?: ImageData) {
    this.drawingBuffer = imageData
    this.callOnDrawingBufferChangeListeners()
  }

  resetDrawingBuffer() {
    this.setDrawingBuffer(this.image)
  }

  abstract putImageInto(ctx: CanvasRenderingContext2D): void
  abstract putDrawingBufferInto(ctx: CanvasRenderingContext2D): void

  putImageIntoForce(ctx: CanvasRenderingContext2D) {
    ctx.putImageData(this.image, 0, 0)
  }
  putDrawingBufferIntoForce(ctx: CanvasRenderingContext2D) {
    if (this.drawingBuffer) ctx.putImageData(this.drawingBuffer, 0, 0)
  }

  setOnImageChangeListener(
    key: string,
    listener: (e: ImageChangeEvent) => void
  ) {
    this.onImageChangedListeners[key] = listener
  }

  setOnDrawingBufferChangeListener(
    key: string,
    listener: (e: DrawingBufferChangeEvent) => void
  ) {
    this.onDrawingBufferChangedListeners[key] = listener
  }

  callOnImageChangeListeners() {
    Object.values(this.onImageChangedListeners).forEach((listener) =>
      listener({})
    )
  }

  callOnDrawingBufferChangeListeners() {
    Object.values(this.onDrawingBufferChangedListeners).forEach((listener) =>
      listener({})
    )
  }

  getWidth = (): number => this.image.width
  getHeight = (): number => this.image.height

  public currentDiffAction: DiffAction = { diffs: new Map() }

  addDiffs(diffs: Diff[]) {
    diffs.forEach((d) => this.currentDiffAction.diffs.set(getDiffHash(d), d))
  }

  public registerDiffAction() {
    this.historyManager?.addAction(this.currentDiffAction)
    this.currentDiffAction = { diffs: new Map() }
  }

  public canUndo = () => this.historyManager?.canUndo()
  public canRedo = () => this.historyManager?.canRedo()

  public undo() {
    const undoStart = Date.now()
    const undoedAction = this.historyManager?.undo()
    if (undoedAction === undefined) return
    setBottomInfo(`undo.`)
    undoedAction.diffs.forEach((diff) => {
      switch (diff.kind) {
        case 'pixel':
          this.setPixelInPosition(diff.position, diff.before, false, false)
          break
        case 'tile':
          this.undoTileDiff(diff)
          break
      }
    })
    const undoEnd = Date.now()
    setBottomInfo(
      `undo done. (${undoedAction.diffs.size} px updated, ${undoEnd - undoStart}ms)`
    )

    this.callOnImageChangeListeners()
  }

  protected undoTileDiff(tileDiff: TileDiff) {}

  public redo() {
    const redoStart = Date.now()
    const redoedAction = this.historyManager?.redo()
    if (redoedAction === undefined) return
    setBottomInfo(`redo.`)
    redoedAction.diffs.forEach((diff) => {
      switch (diff.kind) {
        case 'pixel':
          this.setPixelInPosition(diff.position, diff.after, false, false)
          break
        case 'tile':
          this.redoTileDiff(diff)
          break
      }
    })
    const redoEnd = Date.now()
    setBottomInfo(
      `redo done. (${redoedAction.diffs.size} px updated, ${redoEnd - redoStart}ms)`
    )

    this.callOnImageChangeListeners()
  }

  protected redoTileDiff(tileDiff: TileDiff) {}

  public abstract setPixel(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean,
    excludeColorMatch: boolean
  ): PixelDiff | undefined

  protected setPixelInPosition(
    position: Vec2,
    color: RGBAColor,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    if (!this.isInBounds(position)) return undefined
    if (
      excludePositionMatch &&
      this.currentDiffAction.diffs.has(`${position.x},${position.y}`)
    )
      return undefined
    const i = (position.y * this.getWidth() + position.x) * 4
    const beforeColor: RGBAColor = [
      this.image.data[i + 0],
      this.image.data[i + 1],
      this.image.data[i + 2],
      this.image.data[i + 3],
    ]
    if (excludeColorMatch && colorMatch(beforeColor, color)) return undefined

    if (!this.drawingBuffer) return

    this.drawingBuffer.data[i + 0] = color[0]
    this.drawingBuffer.data[i + 1] = color[1]
    this.drawingBuffer.data[i + 2] = color[2]
    this.drawingBuffer.data[i + 3] = color[3]

    return {
      kind: 'pixel',
      position,
      before: beforeColor,
      after: color,
    }
  }

  public abstract deletePixel(
    position: Vec2,
    excludePositionMatch: boolean,
    excludeColorMatch: boolean
  ): PixelDiff | undefined

  protected deletePixelInPosition(
    position: Vec2,
    excludePositionMatch: boolean = true,
    excludeColorMatch: boolean = true
  ): PixelDiff | undefined {
    return this.setPixelInPosition(
      position,
      [0, 0, 0, 0],
      excludePositionMatch,
      excludeColorMatch
    )
  }

  public abstract getPixel(position: Vec2): RGBAColor

  public isInBounds(position: Vec2) {
    return (
      position.x >= 0 &&
      position.y >= 0 &&
      position.x < this.getWidth() &&
      position.y < this.getHeight()
    )
  }
}

================
File: src/routes/editor/index.tsx
================
import { useLocation } from "@solidjs/router";
import { createSignal, onMount } from "solid-js";
import BottomInfo from "~/components/BottomInfo";
import CanvasArea from "~/components/canvas/CanvasArea";
import EdgeInfo from "~/components/EdgeInfo";
import SideSections from "~/components/SideSections";
import { importProjectJsonFromPath } from "~/io/project/project";
import { adjustZoomToFit, centeringCanvas } from "~/stores/project/canvasStore";
import { flexCol, flexRow } from "~/styles/snippets.css";
import { welcomeRoot } from "../start.css";

export default function Editor() {
  const location = useLocation();

  const [isImporting, setIsImporting] = createSignal(false);

  if (location.search) {
    setIsImporting(true);
    const sp = new URLSearchParams(location.search);
    const fileName = sp.get("name");
    const filePath = sp.get("path");
    const path = `${filePath}\\${fileName}`;
    console.log(path);
    importProjectJsonFromPath(path).then(() => {
      setIsImporting(false);
    });
  }

  onMount(() => {
    adjustZoomToFit();
    centeringCanvas();
  });

  return (
    <>
      {isImporting() && (
        <div id="root">
          <div class={welcomeRoot}>
            <p style={{ "font-size": "3rem" }}>please wait.</p>
          </div>
        </div>
      )}

      {!isImporting() && (
        <div id="root">
          <div class={flexRow}>
            <EdgeInfo />
            <SideSections />
          </div>

          <div class={flexCol} style={{ "flex-grow": 1 }}>
            <CanvasArea />
            <BottomInfo />
          </div>
          {/* <Companion /> */}
        </div>
      )}
    </>
  );
}

================
File: src/styles/components/canvas/canvas_stack.module.css
================
.canvas_stack {
  align-items: center;
  display: flex;
  justify-content: center;
  position: relative;
}

.image-container:focus-within {
  border: 2px black solid;
}

.resize-image {
  height: 100%;
  object-fit: fill;
  width: 100%;
}

================
File: src-tauri/Cargo.toml
================
[package]
name = "app"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
license = ""
repository = ""
edition = "2021"
rust-version = "1.77.2"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
name = "app_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2.1.1", features = [] }

[dependencies]
serde_json = "1.0"
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
tauri = { version = "2.4.1", features = [] }
tauri-plugin-log = "2.0.0-rc"
base64 = "0.22.1"
rand = "0.9.0"
image = "0.25.6"
jpeg-decoder = "0.3.1"
jpeg-encoder = "0.6.1"
tauri-plugin-dialog = "2.2.1"
tauri-plugin-fs = "2.2.1"
serde_bytes = "0.11.17"

================
File: src/components/canvas/stacks/CanvasStack.tsx
================
import { Component, createEffect, createSignal, For, onMount } from "solid-js";
import { canvasStore } from "~/stores/project/canvasStore";
import {
  activeLayer,
  allLayers,
} from "~/stores/project/layerStore";

import styles from "@styles/components/canvas/canvas_stack.module.css";

import CanvasOverlaySVG from "./CanvasOverlaySVG";
import { LayerCanvas, LayerCanvasRef } from "./LayerCanvas";
import { TouchableCanvas } from "./TouchableCanvas";
import LayerCanvasOperator from "~/models/layer_canvas/LayerCanvasOperator";
import { LayerImageManager } from "~/models/layer_image/LayerImageManager";
import TileLayerImageAgent from "~/models/layer_image/agents/TileLayerImageAgent";
import Tile from "~/models/layer_image/Tile";

export const layerImageManager = new LayerImageManager();

const CanvasStack: Component<{}> = (props) => {
  const layerCanvasRefs: {
    [id: string]: LayerCanvasRef;
  } = {};

  const [dirtyRects, setDirtyRects] = createSignal<Tile[]>();


  const activeCanvasRef = () => {
    const active = activeLayer();

    if (active) return layerCanvasRefs[active.id];
    else return undefined;
  };

  onMount(() => {
    window.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key === "z") {
        const active = activeLayer();
        if (active) {
          const agent = layerImageManager.getAgent(active.id);
          agent?.undo();
        }
      } else if (e.ctrlKey && e.key === "y") {
        const active = activeLayer();
        if (active) {
          const agent = layerImageManager.getAgent(active.id);
          agent?.redo();
        }
      }
    });
  });

  createEffect(() => {
    const active = activeLayer();

    if (active) {
      const agent = layerImageManager.getAgent(active.id);
      console.log(agent)
      if (!agent) return;
      agent.setOnDrawingBufferChangeListener("stack_dirty_rect", () => {
        setDirtyRects([...getDirtyRects()]);
      })
      agent.setOnImageChangeListener("stack_dirty_rect", () => {
        setDirtyRects([...getDirtyRects()]);
      })
    }
  })

  const getDirtyRects = () => {
    const active = activeLayer();
    if (active) {
      const agent = layerImageManager.getAgent(active.id);
      if (agent instanceof TileLayerImageAgent) {
        return (agent as TileLayerImageAgent).getDirtyTilesInAction();
      }
    }
    return [];
  }

  return (
    <div style={{ position: "relative" }}>
      <CanvasOverlaySVG dirtyRects={dirtyRects()} />

      <div
        class={styles.canvas_stack}
        style={{
          width: `${canvasStore.canvas.width}px`,
          height: `${canvasStore.canvas.height}px`,
        }}
      >
        <TouchableCanvas operator={new LayerCanvasOperator(() => activeCanvasRef()!!)} />

        <For each={allLayers()}>
          {(layer, index) => (
            <LayerCanvas manager={layerImageManager}
              ref={layerCanvasRefs[layer.id]}
              layer={layer}
              zIndex={allLayers().length - index()}
            />
          )}
        </For>
      </div>
    </div>
  );
};

export default CanvasStack;

================
File: src/components/common/companion/Companion.tsx
================
import { Component, createEffect, createSignal } from "solid-js";

import styles from "@styles/components/companion.module.css";

const [sayRequest, setSayRequest] = createSignal<string | null>(null);

export const CompanionEvents = {
  sayRequest,
  setSayRequest,
};

const Companion: Component = () => {
  const [quote, setQuote] = createSignal("");

  const say = (text: string) => {
    window.speak?.(text, {
      amplitude: 5,
      pitch: 10,
      speed: 200,
      wordgap: 0,
    });
  };

  createEffect(() => {
    const message = CompanionEvents.sayRequest();
    if (message) {
      say(message);
      setQuote(message);
      const element = document.getElementById("companion");
      setTimeout(() => {
        setQuote("");
        if (element)
          element.className = element.className.replace(
            ` ${styles["giggle"]}`,
            "",
          );
      }, 5000);
      window.requestAnimationFrame(function (time) {
        window.requestAnimationFrame(function (time) {
          if (element) element.className += ` ${styles["giggle"]}`;
        });
      });
      CompanionEvents.setSayRequest(null); // 一度で消費
    }
  });

  return (
    <div class={styles.root}>
      <div class={styles.wrapper}>
        <div class={styles.companion} id="companion">
          <img src="/companion.png" alt="you challenge me?" />
        </div>
        {quote() && (
          <div class={styles.quote_box_container}>
            <div class={styles.quote_box}>
              <p class={styles.quote}>{quote()}</p>
            </div>
          </div>
        )}
      </div>
      <div id="audio" />
    </div>
  );
};

let lastSpoke = 0;
export const smartSay = (text: string): boolean => {
  const now = Date.now();
  if (now - lastSpoke > 5000) {
    CompanionEvents.setSayRequest(text);
    lastSpoke = now;
    return true;
  }
  return false;
};

export default Companion;

================
File: src/components/section/LayerList.tsx
================
import {
  closestCenter,
  DragDropProvider,
  DragDropSensors,
  SortableProvider,
} from "@thisbeyond/solid-dnd";
import { Component, createEffect, createSignal, For, onMount } from "solid-js";
import { addLayer } from "~/models/factories/addLayer";
import { removeLayer } from "~/models/factories/removeLayer";
import {
  activeLayer,
  allLayers,
  layerStore,
  setLayerStore,
} from "~/stores/project/layerStore";
import { layerList } from "~/styles/section/layer.css";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";
import { flexRow } from "~/styles/snippets.css";
import LayerItem from "./item/LayerItem";
// 並べ替え用ユーティリティ関数

const LayerList: Component<{}> = () => {
  const [items, setItems] = createSignal(allLayers());
  const [activeItem, setActiveItem] = createSignal(null);
  const ids = () => items().map((l) => l.id);

  onMount(() => {
    setItems(allLayers());
  });

  createEffect(() => {
    setItems(allLayers());
  });

  const onDragStart = ({ draggable }: { draggable: any }) =>
    setActiveItem(draggable.id);

  function moveLayer(draggedId: string, targetIndex: number) {
    const fromIndex = layerStore.layers.findIndex((l) => l.id === draggedId);
    if (fromIndex === -1 || fromIndex === targetIndex) return;

    const updated = [...layerStore.layers];
    const [moved] = updated.splice(fromIndex, 1);
    updated.splice(targetIndex, 0, moved);
    setLayerStore("layers", updated);
    setItems(allLayers());
  }

  const onDragEnd = ({
    draggable,
    droppable,
  }: {
    draggable: any;
    droppable: any;
  }) => {
    if (draggable && droppable) {
      const currentItems = ids();
      const fromIndex = currentItems.indexOf(draggable.id);
      const toIndex = currentItems.indexOf(droppable.id);
      if (fromIndex !== toIndex) {
        moveLayer(draggable.id, toIndex);
      }
    }
  };

  return (
    <DragDropProvider
      onDragStart={onDragStart}
      onDragEnd={(e) => {
        onDragEnd({ draggable: e.draggable, droppable: e.droppable });
      }}
      collisionDetector={closestCenter}
    >
      <DragDropSensors>
        <div class={sectionRoot}>
          <div class={flexRow} style={{ "margin-bottom": "6px" }}>
            <p class={sectionCaption} style={{ "flex-grow": 1 }}>
              layers.
            </p>

            <div class={flexRow} style={{ gap: "4px" }}>
              <button
                onClick={() => {
                  addLayer("dot1");
                  setItems(allLayers());
                }}
              >
                + add.
              </button>

              <button
                onClick={() => {
                  removeLayer(activeLayer()?.id);
                  setItems(allLayers());
                }}
              >
                - remove.
              </button>
            </div>
          </div>
          <div class={sectionContent}>
            <div class={layerList}>
              <SortableProvider ids={ids()}>
                <For each={items()}>
                  {(layer, index) => (
                    <LayerItem layer={layer} index={index()} />
                  )}
                </For>
              </SortableProvider>
            </div>
            {/* <DragOverlay>
                                    <div class="sortable"><LayerItem layer={activeItemLayer()} /></div>
                                </DragOverlay> */}
          </div>
        </div>
      </DragDropSensors>
    </DragDropProvider>
  );
};

export default LayerList;

================
File: src/components/section/PenConfig.tsx
================
import { Component, For } from "solid-js";
import { toolStore } from "~/stores/internal/toolsStore";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";
import PenItem from "./item/PenItem";

const PenConfig: Component<{}> = (props) => {
  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>pen config.</p>
      <div class={sectionContent}>
        <For each={toolStore.tools}>
          {(item, index) => (
            <PenItem pen={item} isInUse={index() === toolStore.usingIndex} />
          )}
        </For>
      </div>
    </div>
  );
};

export default PenConfig;

================
File: src/models/factories/addLayer.ts
================
import { allLayers, setLayerStore } from "~/stores/project/layerStore";
import { DSL } from "../dsl/DSL";
import { LayerType } from "../types/Layer";
import { createLayer } from "./createLayer";

export const addLayer = (
  name: string,
  type: LayerType = LayerType.Dot,
  enabled = true,
  dotMagnification = 1,
  dsl?: DSL,
) => {
  const newLayer = createLayer(name, type, enabled, dotMagnification, dsl);

  const layers = [...allLayers()];
  layers.push(newLayer);

  setLayerStore("layers", layers);

  return layers;
};

================
File: src/models/factories/createLayer.ts
================
import { v4 as uuidv4 } from 'uuid'
import { showToast } from '~/stores/internal/toastStore'
import { layerStore } from '~/stores/project/layerStore'
import { DSL } from '../dsl/DSL'
import { initLayerImage } from '../layer/layerImage'
import { Layer, LayerType } from '../types/Layer'

export const createLayer = (
  name: string,
  type: LayerType,
  enabled = true,
  dotMagnification = 1,
  dsl?: DSL
): Layer => {
  // check if name already exists
  const endNums = name.match(/^(.*)(\d+)$/)
  if (endNums && endNums.length >= 3) {
    const nameWithoutNum = endNums[1]
    const endNum = Number(endNums[2])
    showToast(nameWithoutNum, 'info', 1000)
    showToast(endNum, 'info', 1000)

    const foundSameNameNums: number[] = []
    layerStore.layers.forEach((layer) => {
      const layerEndNums = layer.name.match(/^(.*)(\d+)$/)
      if (layerEndNums && layerEndNums.length >= 3) {
        const layerNameWithoutNum = layerEndNums[1]
        const layerEndNum = Number(layerEndNums[2])
        if (nameWithoutNum === layerNameWithoutNum) {
          foundSameNameNums.push(layerEndNum)
        }
      }
    })

    showToast(foundSameNameNums.join(','), 'info', 1000)

    let num = endNum
    while (foundSameNameNums.find((foundNum) => foundNum === num)) {
      num++
    }

    showToast(`num ok!! ${num}`, 'success', 1000)
    name = nameWithoutNum + num
  }

  const id = uuidv4()
  initLayerImage(id, dotMagnification)
  return {
    id,
    name,
    type,
    typeDescription: getTypeString(type),
    enabled,
    dotMagnification,
    dsl: dsl || new DSL(id, id),
  }
}

function getTypeString(type: LayerType): string {
  switch (type) {
    case LayerType.Dot:
      return 'dot layer.'
    case LayerType.Image:
      return 'image layer.'
    case LayerType.Automate:
      return 'automate layer.'
    default:
      return 'N/A.'
  }
}

================
File: src/models/factories/removeLayer.ts
================
import {
  layerImageStore,
  setLayerImageStore,
} from '~/stores/project/layerImageStore'
import { allLayers, setLayerStore } from '~/stores/project/layerStore'

export const removeLayer = (layerId?: string) => {
  if (layerId === undefined) return
  const layers = [...allLayers()]
  const index = layers.findIndex((l) => l.id === layerId)
  let newActiveIndex = 0
  if (index !== 0) newActiveIndex = index - 1

  layers.splice(index, 1)
  const images = Object.assign({}, layerImageStore)
  delete images[layerId]

  setLayerStore('layers', layers)
  setLayerStore('activeLayerId', layers[newActiveIndex].id)
  setLayerImageStore(images)
}

================
File: src/models/layer/layerImage.ts
================
import { canvasStore } from '~/stores/project/canvasStore'
import { setLayerImageStore } from '~/stores/project/layerImageStore'

export function initLayerImage(layerId: string, dotMagnification: number) {
  const blank = new ImageData(
    Math.round(canvasStore.canvas.width / dotMagnification),
    Math.round(canvasStore.canvas.height / dotMagnification)
  )
  setLayerImageStore(layerId, {
    current: blank,
    undoStack: [],
    redoStack: [],
  })
}

================
File: src/components/canvas/CanvasAreaInteract.tsx
================
import { Vec2 } from "~/models/types/Vector";
import {
  canvasStore,
  getReferencedZoom,
  setCanvasStore,
} from "~/stores/project/canvasStore";

class CanvasAreaInteract {
  private dragPosition: Vec2 = { x: 0, y: 0 };

  private lastX: number[] = [0, 0];
  private lastY: number[] = [0, 0];
  private lastDist: number = 0;

  constructor() { }

  private getMutualMove = (move0: number, move1: number) => {
    // 逆方向なら0
    if (Math.sign(move0) !== Math.sign(move1)) return 0;
    return Math.min(move1, move0);
  };

  private handleTouchMove(e: TouchEvent, canvasStack: HTMLDivElement) {
    if (canvasStore.isInStroke) return;

    if (e.touches.length === 1) {
      const xMove0 = e.touches[0].clientX - this.lastX[0];
      if (xMove0 !== 0 && this.lastX[0] !== 0) {
        setCanvasStore("offset", {
          x: canvasStore.offset.x + xMove0,
          y: canvasStore.offset.y,
        });
      }
      const yMove0 = e.touches[0].clientY - this.lastY[0];
      if (yMove0 !== 0 && this.lastY[0] !== 0) {
        setCanvasStore("offset", {
          x: canvasStore.offset.x,
          y: canvasStore.offset.y + yMove0,
        });
      }
      this.lastX[0] = e.touches[0].clientX;
      this.lastY[0] = e.touches[0].clientY;
    }
    if (e.touches.length >= 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist =
        Math.sqrt(dx * dx + dy * dy) * canvasStore.touchZoomSensitivity;
      if (this.lastDist !== 0) {
        const scaleFactor = dist / this.lastDist;
        const zoomOld = canvasStore.zoom;
        const zoomNew = zoomOld * scaleFactor;
        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const rect = canvasStack.getBoundingClientRect();
        const canvasX = (midX - rect.left) / zoomOld;
        const canvasY = (midY - rect.top) / zoomOld;
        setCanvasStore("zoom", zoomNew);
        setCanvasStore("offset", {
          x: canvasStore.offset.x + canvasX * (zoomOld - zoomNew),
          y: canvasStore.offset.y + canvasY * (zoomOld - zoomNew),
        });
      }
      const xMove0 = e.touches[0].clientX - this.lastX[0];
      const xMove1 = e.touches[1].clientX - this.lastX[1];
      const mutualMoveX = this.getMutualMove(xMove0, xMove1);
      if (mutualMoveX !== 0 && this.lastX[0] !== 0 && this.lastX[1] !== 0) {
        setCanvasStore("offset", {
          x: canvasStore.offset.x + mutualMoveX,
          y: canvasStore.offset.y,
        });
      }
      const yMove0 = e.touches[0].clientY - this.lastY[0];
      const yMove1 = e.touches[1].clientY - this.lastY[1];
      const mutualMoveY = this.getMutualMove(yMove0, yMove1);
      if (mutualMoveY !== 0 && this.lastY[0] !== 0 && this.lastY[1] !== 0) {
        setCanvasStore("offset", {
          x: canvasStore.offset.x,
          y: canvasStore.offset.y + mutualMoveY,
        });
      }
      this.lastX[0] = e.touches[0].clientX;
      this.lastX[1] = e.touches[1].clientX;
      this.lastY[0] = e.touches[0].clientY;
      this.lastY[1] = e.touches[1].clientY;
      this.lastDist = dist;
    }
  }

  private handleTouchEnd(e: TouchEvent) {
    this.lastX = [0, 0];
    this.lastY = [0, 0];
    this.lastDist = 0;
  }

  private handleWheel(e: WheelEvent, canvasStack: HTMLDivElement) {
    e.preventDefault();
    const referencedZoom = getReferencedZoom();
    const delta =
      (e.deltaY > 0 ? -canvasStore.wheelZoomStep : canvasStore.wheelZoomStep) *
      referencedZoom;

    const zoomOld = canvasStore.zoom;
    const zoomNew = Math.max(
      canvasStore.zoomMin * referencedZoom,
      Math.min(canvasStore.zoomMax * referencedZoom, canvasStore.zoom + delta),
    );
    const rect = canvasStack.getBoundingClientRect();
    const canvasX = (e.clientX - rect.left) / zoomOld;
    const canvasY = (e.clientY - rect.top) / zoomOld;
    setCanvasStore("zoom", zoomNew);
    setCanvasStore("offset", {
      x: canvasStore.offset.x + canvasX * (zoomOld - zoomNew),
      y: canvasStore.offset.y + canvasY * (zoomOld - zoomNew),
    });
  }

  private handleMouseDown(e: MouseEvent) {
    if (e.buttons === 4 || (e.buttons === 1 && canvasStore.isCtrlPressed)) {
      e.preventDefault();
      e.stopPropagation();
      setCanvasStore("isDragging", true);
      this.dragPosition = { x: e.clientX, y: e.clientY };
    }
  }

  private handleMouseMove(e: MouseEvent) {
    if (e.buttons === 4 || (e.buttons === 1 && canvasStore.isCtrlPressed)) {
      e.preventDefault();
      e.stopPropagation();
      if (canvasStore.isDragging) {
        const dx = e.clientX - this.dragPosition.x;
        const dy = e.clientY - this.dragPosition.y;
        setCanvasStore("offset", {
          x: canvasStore.offset.x + dx,
          y: canvasStore.offset.y + dy,
        });
        this.dragPosition = { x: e.clientX, y: e.clientY };
      }
    }
  }

  private handleMouseOff(e: MouseEvent) {
    setCanvasStore("isDragging", false);
  }

  private handleKeyDown(e: KeyboardEvent) {
    if (e.ctrlKey) setCanvasStore("isCtrlPressed", true);
  }

  private handleKeyUp(e: KeyboardEvent) {
    if (e.key === "Control") setCanvasStore("isCtrlPressed", false);
  }

  public setInteractListeners(
    wrapper: HTMLDivElement,
    canvasStack: HTMLDivElement,
  ) {
    wrapper.addEventListener("touchmove", (e) =>
      this.handleTouchMove.bind(this)(e, canvasStack),
    );
    wrapper.addEventListener("touchend", this.handleTouchEnd.bind(this));

    wrapper.addEventListener("wheel", (e) =>
      this.handleWheel.bind(this)(e, canvasStack),
    );

    wrapper.addEventListener("mousedown", this.handleMouseDown.bind(this));
    wrapper.addEventListener("mousemove", this.handleMouseMove.bind(this));
    wrapper.addEventListener("mouseup", this.handleMouseOff.bind(this));
    wrapper.addEventListener("mouseleave", this.handleMouseOff.bind(this));
    wrapper.addEventListener("mouseout", this.handleMouseOff.bind(this));

    window.addEventListener("keydown", this.handleKeyDown.bind(this));
    window.addEventListener("keyup", this.handleKeyUp.bind(this));
  }

  public removeInteractListeners(
    wrapper: HTMLDivElement,
    canvasStack: HTMLDivElement,
  ) {
    wrapper.removeEventListener("touchmove", (e) =>
      this.handleTouchMove.bind(this)(e, canvasStack),
    );
    wrapper.removeEventListener("touchend", this.handleTouchEnd.bind(this));

    wrapper.removeEventListener("wheel", (e) =>
      this.handleWheel.bind(this)(e, canvasStack),
    );

    wrapper.removeEventListener("mousedown", this.handleMouseDown.bind(this));
    wrapper.removeEventListener("mousemove", this.handleMouseMove.bind(this));
    wrapper.removeEventListener("mouseup", this.handleMouseOff.bind(this));
    wrapper.removeEventListener("mouseleave", this.handleMouseOff.bind(this));
    wrapper.removeEventListener("mouseout", this.handleMouseOff.bind(this));

    window.removeEventListener("keydown", this.handleKeyDown.bind(this));
    window.removeEventListener("keyup", this.handleKeyUp.bind(this));
  }
}

export default CanvasAreaInteract;

================
File: src/components/canvas/stacks/LayerCanvas.tsx
================
import {
  Component,
  createEffect,
  createRenderEffect,
  onMount,
  Ref,
} from "solid-js";
import { Layer } from "~/models/types/Layer";
import { canvasStore } from "~/stores/project/canvasStore";
import { layerImageStore } from "~/stores/project/layerImageStore";

import styles from "@styles/components/canvas/layer_canvas.module.css";
import { LayerImageManager } from "~/models/layer_image/LayerImageManager";
import LayerImageAgent from "~/models/layer_image/LayerImageAgent";
import { layerCanvas } from "~/styles/components/canvas/layer_canvas.css";
import { globalStore } from "~/stores/global/globalStore";

type Props = {
  manager: LayerImageManager,
  ref?: LayerCanvasRef;
  layer: Layer;
  zIndex: number;
};

export type LayerCanvasRef = {
  getLayer: () => Layer;
  getManager: () => LayerImageManager;
  getAgent: () => LayerImageAgent;
};

export const LayerCanvas: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;
  let ctx: CanvasRenderingContext2D | null = null;

  const agent = () => props.manager.getAgent(props.layer.id);

  createRefContent(
    () => props.ref,
    () => ({
      getLayer() {
        return props.layer
      },
      getManager() {
        return props.manager
      },
      getAgent() {
        return agent()
      },
    }),
  );

  const styleWidth = () => canvasStore.canvas.width;
  const styleHeight = () => canvasStore.canvas.height;
  const internalWidth = () =>
    canvasStore.canvas.width / props.layer.dotMagnification;
  const internalHeight = () =>
    canvasStore.canvas.height / props.layer.dotMagnification;

  onMount(() => {
    const agent = props.manager.registerAgent(props.layer.id, layerImageStore[props.layer.id]?.current)

    ctx = canvasRef?.getContext("2d") ?? null;
    if (ctx) agent.putImageInto(ctx)

    agent.setOnImageChangeListener("layercanvas_refresh", () => {
      if (ctx) {
        agent.putImageIntoForce(ctx)
      }
    })
    agent.setOnDrawingBufferChangeListener("layercanvas_refresh", () => {
      if (ctx) {
        agent.putDrawingBufferIntoForce(ctx)
      }
    })
  });

  createEffect(() => {
    const image = layerImageStore[props.layer.id].current
    agent()?.setImage(image, true)
    if (ctx) agent()?.putImageIntoForce(ctx)
  });

  return (
    <canvas
      ref={canvasRef}
      id={`canvas-${props.layer.id}`}
      data-layer-id={props.layer.name}
      class={layerCanvas({
        rendering: globalStore.canvasRenderingMode,
        hidden: !props.layer.enabled
      })}
      width={internalWidth()}
      height={internalHeight()}
      style={{
        width: `${styleWidth()}px`,
        height: `${styleHeight()}px`,
        "z-index": props.zIndex,
      }}
    />
  );
};

function createRefContent<T extends Exclude<unknown, Function>>(
  getRef: () => Ref<T>,
  createRef: () => T,
) {
  createRenderEffect(() => {
    const refProp = getRef();
    if (typeof refProp !== "function") {
      throw new Error(
        "Should never happen, as solid always passes refs as functions",
      );
    }

    let refFunc = refProp as (value: T) => void;

    refFunc(createRef());
  });
}

================
File: src/components/section/Color.tsx
================
import { Component, For } from "solid-js";
import { colorStore } from "~/stores/internal/colorStore";

import ColorPicker from "~/components/section/item/ColorPicker";
import { setCurrentToolColor } from "~/models/types/Tool";
import {
  colorElemDescription,
  descriptionContainer,
  swatchContainer,
} from "~/styles/section/color.css";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";
import ColorBox from "../common/ColorBox";

const Color: Component<{}> = (props) => {
  const onColorClicked = (color: string, index: number) => {
    setCurrentToolColor(color);
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>color.</p>
      <div
        class={sectionContent}
        style={{ "flex-direction": "row", margin: "8px 0" }}
      >
        <div class={descriptionContainer}>
          <p class={colorElemDescription}>swatch.</p>
        </div>
        <div class={swatchContainer}>
          <For each={colorStore.swatches}>
            {(item, index) => (
              <ColorBox
                color={item}
                sizePx={8}
                onClick={(color) => onColorClicked(color, index())}
                enableUsingSelection={true}
              />
            )}
          </For>
        </div>
        <div class={descriptionContainer}>
          <p class={colorElemDescription}>picker.</p>
        </div>
        <ColorPicker />
      </div>
    </div>
  );
};

export default Color;

================
File: src/components/section/item/PenItem.tsx
================
import { Component } from "solid-js";
import ColorBox from "~/components/common/ColorBox";
import { sayRandomQuote } from "~/components/common/companion/QuotePool";
import Light from "~/components/common/Light";
import Slider from "~/components/common/Slider";
import { Tool } from "~/models/types/Tool";
import { toolStore, setToolStore } from "~/stores/internal/toolsStore";
import { penConfigRow, penConfigRowName } from "~/styles/section/pen.css";

interface Props {
  pen: Tool;
  isInUse: boolean;
}

const PenItem: Component<Props> = (props: Props) => {
  return (
    <div class={penConfigRow}>
      <Light on={props.isInUse} />

      <p
        class={penConfigRowName}
        style={{
          color: props.isInUse ? "red" : "unset",
        }}
        onClick={() => {
          setToolStore({ usingIndex: toolStore.tools.indexOf(props.pen) });
        }}
      >
        {props.pen.name}.
      </p>

      <ColorBox color={props.pen.color} sizePx={8} />

      <div style={{ "flex-grow": 1 }}>
        <Slider
          min={1}
          max={30}
          default={props.pen.size}
          onValueChanged={(newValue) => {
            sayRandomQuote("pen-resize");
            console.log("size set to " + newValue);
            const penIndex = toolStore.tools.findIndex(
              (p) => p.id === props.pen.id,
            );
            setToolStore("tools", penIndex, "size", newValue);
          }}
        />
      </div>

      <p style={{ width: "auto" }}>{props.pen.size}.</p>
    </div>
  );
};

export default PenItem;

================
File: src-tauri/src/lib.rs
================
mod commands;
mod pipeline;
mod standalone;

use pipeline::run_pipeline;
use standalone::{flood_fill, flood_fill_raw};

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            run_pipeline,
            flood_fill,
            flood_fill_raw
        ])
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_dialog::init())
        .setup(|app| {
            if cfg!(debug_assertions) {
                app.handle().plugin(
                    tauri_plugin_log::Builder::default()
                        .level(log::LevelFilter::Info)
                        .build(),
                )?;
            }
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

================
File: src-tauri/tauri.conf.json
================
{
  "$schema": "../node_modules/@tauri-apps/cli/config.schema.json",
  "productName": "sledge",
  "version": "0.1.0",
  "identifier": "com.innsbluck",
  "build": {
    "frontendDist": "../dist",
    "devUrl": "http://localhost:5173",
    "beforeDevCommand": "npm run dev",
    "beforeBuildCommand": "npm run prettier && npm run build"
  },
  "app": {
    "windows": [
      {
        "title": "sledge",
        "label": "main",
        "width": 1200,
        "height": 800,
        "acceptFirstMouse": true,
        "resizable": true,
        "closable": true,
        "maximizable": true,
        "minimizable": true,
        "decorations": false,
        "fullscreen": false
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "fileAssociations": [
      {
        "ext": ["sledge"],
        "description": "Sledge Project File"
      }
    ],
    "active": true,
    "targets": "all",
    "icon": [
      "icons_light/icon.ico",
      "icons_light/32x32.png",
      "icons_light/128x128.png",
      "icons_light/256x256.png"
    ]
  }
}

================
File: src/components/section/item/LayerItem.tsx
================
import { createSortable, useDragDropContext } from "@thisbeyond/solid-dnd";
import { Component } from "solid-js";
import Light from "~/components/common/Light";
import { getNextMagnification } from "~/models/factories/utils";
import { Layer, LayerType } from "~/models/types/Layer";
import { layerStore, setLayerStore } from "~/stores/project/layerStore";
import {
  activeLight,
  dotMagnifContainer,
  dotMagnifText,
  layerItem,
  layerItemDisabled,
  layerItemName,
  layerItemType,
} from "~/styles/section/layer.css";
import { w100 } from "~/styles/snippets.css";
import LayerPreview from "../../common/LayerPreview";

interface LayerItemProps {
  index: number;
  layer: Layer;
  draggingId?: string | null;
}

const LayerItem: Component<LayerItemProps> = (props) => {
  const { layer, draggingId } = props;

  const sortable = createSortable(layer.id);
  const context = useDragDropContext();
  const state = context?.[0];

  let detClass: "dot" | "image" | "automate" | undefined;
  switch (layer.type) {
    case LayerType.Dot:
      detClass = "dot";
      break;
    case LayerType.Image:
      detClass = "image";
      break;
    case LayerType.Automate:
      detClass = "automate";
      break;
  }

  const onDetClicked = () => {
    setLayerStore("activeLayerId", layer.id);
  };

  const onPreviewClicked = () => {
    if (props.index !== -1) {
      setLayerStore("layers", props.index, "enabled", (v: boolean) => !v);
    }
  };

  const onMagnifClicked = () => {
    const next = getNextMagnification(layer.dotMagnification);
    if (props.index !== -1) {
      setLayerStore("layers", props.index, "dotMagnification", next);
    }
  };

  const isActive = () => layerStore.activeLayerId === layer.id;

  return (
    <div
      class={w100}
      classList={{
        "opacity-50": sortable.isActiveDraggable,
        "transition-transform": state && !!state.active.draggable,
      }}
      style={{ opacity: draggingId === layer.id ? 0.4 : 1 }}
      ref={sortable}
    >
      <p class={layerItemType}>{layer.typeDescription}</p>
      <p>{props.index}.</p>
      <div style={{ display: "flex", "align-items": "center" }}>
        {/* <DSLButton /> */}
        <div
          class={[layerItem, !layer.enabled && layerItemDisabled]
            .filter(Boolean)
            .join(" ")}
          onClick={onDetClicked}
        >
          <LayerPreview layer={layer} onClick={onPreviewClicked} maxHeight={30} maxWidth={30} />
          <p class={layerItemName}> {layer.name}</p>
          <div
            class={dotMagnifContainer}
            onClick={(e) => {
              e.stopPropagation();
              onMagnifClicked();
            }}
            onMouseOver={(e) => e.stopPropagation()}
          >
            <p class={dotMagnifText}>x{layer.dotMagnification}</p>
          </div>
          <Light class={activeLight} on={isActive()} />
        </div>
      </div>
    </div>
  );
};

export default LayerItem;

================
File: src/utils/DSLUtils.ts
================
import { runDSL } from '~/models/dsl/DSLRunner'
import { layerImageStore } from '~/stores/project/layerImageStore'
import { findLayerById } from '~/stores/project/layerStore'
import { downloadImageData } from '../io/internal/export'

export const testDSLTime = (layerId: string) => {
  const layer = findLayerById(layerId)
  if (layer === undefined) {
    throw 'layer not found.'
    return
  }
  const imageData = layerImageStore[layerId].current

  const start = new Date().getTime()
  console.log(`DSL run started.\n${layer.dsl.build()}`)
  runDSL(layer.dsl, imageData).then((im) => {
    const end = new Date().getTime()
    console.log(`DSL run end.`)
    console.log(
      `result: ${im ? 'success' : 'failed'}. TOTAL TIME IS ${end - start}ms.`
    )

    if (im) downloadImageData(im, 'test-' + end + '.png')
  })
}

================
File: vite.config.js
================
import { defineConfig } from 'vite'
import solidPlugin from 'vite-plugin-solid'
import tsconfigPaths from 'vite-tsconfig-paths'
import path from 'path'
import { vanillaExtractPlugin } from '@vanilla-extract/vite-plugin'

export default defineConfig({
  plugins: [
    vanillaExtractPlugin({ devStyleRuntime: 'vanilla-extract' }),
    solidPlugin(),
    tsconfigPaths(),
  ],
  build: {
    target: 'esnext',
    outDir: 'dist',
  },
  server: {
    host: true,
    port: 5173,
  },
  alias: {
    '~': path.resolve(__dirname, 'src'),
  },
})

================
File: src/components/canvas/Controls.tsx
================
import { Component, For } from "solid-js";
import { canvasStore } from "~/stores/project/canvasStore";
import { activeLayer, layerStore } from "~/stores/project/layerStore";

import styles from "@styles/components/canvas/controls.module.css";
import { layerImageManager } from "./stacks/CanvasStack";
import { canRedo, canUndo, layerImageStore } from "~/stores/project/layerImageStore";

const Controls: Component<{}> = (props) => {
  // const zoom = () => canvasStore.zoom;
  const lastMouseWindow = () => canvasStore.lastMouseWindow;
  const lastMouseOnCanvas = () => canvasStore.lastMouseOnCanvas;

  return (
    <>
      <p>canvas.</p>
      <p>
        ({lastMouseWindow().x}, {lastMouseWindow().y}) ON WINDOW.
      </p>
      <p>
        ({lastMouseOnCanvas().x}, {lastMouseOnCanvas().y}) ON CANVAS.
      </p>
      {/* <p>x{zoom().toFixed(2)}</p> */}
      <p>active: {activeLayer()?.name}</p>
      <p>
        offset:({canvasStore.offset.x}, {canvasStore.offset.y})
      </p>

      <p>UNDO STACKS.</p>
      <For each={layerImageManager.getAgent(activeLayer()?.id)?.getHistoryManager()?.getUndoStack()}>
        {(item, i) => {
          if (i() === 0) {
            <>
              <p>pixel diffs: {item.diffs.values().toArray().filter(d => d.kind === "pixel").length}px.</p>
              <p>tile diffs: {item.diffs.values().toArray().filter(d => d.kind === "tile").length}px.</p>
            </>
          } else return <></>
        }
        }
      </For>
      <div class={styles["top-right-button-container"]}>
        {/* <ImportImageButton />
        <p class={styles.button} onClick={() => exportActiveLayerUpscaled()}>
          export
        </p> */}
      </div>
      <div class={styles["top-right-nav"]}>
        <img
          class={styles.undo_redo}
          src="/undo.png"
          style={{
            opacity: canUndo() ? "1.0" : "0.3",
            cursor: canUndo()
              ? "pointer"
              : "unset",
          }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            layerImageManager.getAgent(layerStore.activeLayerId)?.undo();
          }}
        />
        <img
          class={styles.undo_redo}
          src="/redo.png"
          style={{
            opacity: canRedo() ? "1.0" : "0.3",
            cursor: canRedo()
              ? "pointer"
              : "unset",
          }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            layerImageManager.getAgent(layerStore.activeLayerId)?.redo();
          }}
        />

        {/* <DSLEditor /> */}
      </div>
    </>
  );
};

export default Controls;

================
File: src/components/canvas/stacks/TouchableCanvas.tsx
================
import { Component, createSignal, onCleanup, onMount } from "solid-js";
import { canvasStore, setCanvasStore } from "~/stores/project/canvasStore";
import { Vec2 } from "~/models/types/Vector";
import LayerCanvasOperator from "~/models/layer_canvas/LayerCanvasOperator";
import { DrawState } from "~/models/layer_canvas/DrawState";
import { LayerImageManager } from "~/models/layer_image/LayerImageManager";

interface Props {
  operator: LayerCanvasOperator,
}

// レイヤーごとのキャンバスの上でタッチイベントを受けるだけのキャンバス
export const TouchableCanvas: Component<Props> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;

  const styleWidth = () => canvasStore.canvas.width;
  const styleHeight = () => canvasStore.canvas.height;

  const [lastPos, setLastPos] = createSignal<
    Vec2 | undefined
  >(undefined);
  const [temporaryOut, setTemporaryOut] = createSignal(false);

  function getOffset() {
    const rect = canvasRef!.getBoundingClientRect();
    return { x: rect.left, y: rect.top };
  }

  function getWindowMousePosition(e: MouseEvent | PointerEvent | TouchEvent) {
    let x = 0;
    let y = 0;

    if ("clientX" in e && "clientY" in e) {
      x = e.clientX;
      y = e.clientY;
    } else if ("touches" in e && e.touches.length > 0) {
      console.log("touch");
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }
    return { x, y };
  }

  function getCanvasMousePosition(e: MouseEvent | PointerEvent | TouchEvent) {
    const offset = getOffset();

    let x = 0;
    let y = 0;

    if ("clientX" in e && "clientY" in e) {
      x = e.clientX;
      y = e.clientY;
    } else if ("touches" in e && e.touches.length > 0) {
      console.log("touch");
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }

    const zoom = canvasStore.zoom;

    return {
      x: (x - offset.x) / zoom,
      y: (y - offset.y) / zoom,
    };
  }

  function isDrawableClick(e: PointerEvent): boolean {
    if (e.pointerType === "touch" || canvasStore.isCtrlPressed) return false;
    // right=1, left=2, middle=4
    // console.log(e.buttons)
    if (e.pointerType === "mouse" && e.buttons !== 1) return false;

    return true;
  }

  function handlePointerDown(e: PointerEvent) {
    if (!isDrawableClick(e)) return;

    const position = getCanvasMousePosition(e);
    props.operator.handleDraw(DrawState.start, position, lastPos());
    setCanvasStore("isInStroke", true);
    setLastPos(position);
  }

  function handlePointerCancel(e: PointerEvent) {
    console.warn("pointercancel", e);
    endStroke(getCanvasMousePosition(e));
  }

  function handlePointerMove(e: PointerEvent) {
    const windowPosition = getWindowMousePosition(e);
    const position = getCanvasMousePosition(e);
    setCanvasStore("lastMouseWindow", windowPosition);
    setCanvasStore("lastMouseOnCanvas", position);
    setCanvasStore("lastMouseOnZoomedCanvas", {
      x: position.x * canvasStore.zoom,
      y: position.y * canvasStore.zoom,
    });

    if (!isDrawableClick(e)) return;

    // 押したまま外に出てから戻ってきたときはそこから再開
    if (temporaryOut()) {
      setTemporaryOut(false);
      setCanvasStore("isInStroke", true);
      setLastPos(position);
    }
    if (!canvasStore.isInStroke || !lastPos()) return;

    props.operator.handleDraw(DrawState.move, position, lastPos());
    setLastPos(position);
  }

  function handlePointerUp(e: PointerEvent) {
    const position = getCanvasMousePosition(e);
    if (canvasStore.isInStroke) endStroke(position);
  }

  function handlePointerOut(e: PointerEvent) {
    // 出た時点でストロークを切る場合
    // const position = getCanvasMousePosition(e);
    // if (canvasStore.isInStroke) endStroke(position);

    // 出た時点でも押したままキャンバス内に戻ってきたらストロークを再開する場合
    if (canvasStore.isDragging) {
      const position = getCanvasMousePosition(e);
      props.operator.handleDraw(DrawState.move, position, lastPos());
      setTemporaryOut(true);
    }
  }

  function handleWheel(e: WheelEvent) {
    const windowPosition = getWindowMousePosition(e);
    const position = getCanvasMousePosition(e);
    setCanvasStore("lastMouseWindow", windowPosition);
    setCanvasStore("lastMouseOnCanvas", position);
    setCanvasStore("lastMouseOnZoomedCanvas", {
      x: position.x * canvasStore.zoom,
      y: position.y * canvasStore.zoom,
    });
  }

  function endStroke(position: Vec2) {
    props.operator.handleDraw(DrawState.end, position, lastPos());
    setCanvasStore("isInStroke", false);
    setLastPos(undefined);
    setTemporaryOut(false);
  }

  onMount(() => {
    window.addEventListener("pointerup", handlePointerUp);
    window.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("pointercancel", handlePointerCancel);
    window.addEventListener("wheel", handleWheel);
  });

  onCleanup(() => {
    window.removeEventListener("pointerup", handlePointerUp);
    window.removeEventListener("pointermove", handlePointerMove);
    window.removeEventListener("pointercancel", handlePointerCancel);
    window.removeEventListener("wheel", handleWheel);
  });

  return (
    <canvas
      ref={(el) => {
        canvasRef = el;
      }}
      width={canvasStore.canvas.width}
      height={canvasStore.canvas.height}
      onPointerDown={handlePointerDown}
      onPointerOut={handlePointerOut}
      style={{
        "touch-action": "none",
        width: `${styleWidth()}px`,
        height: `${styleHeight()}px`,
        "pointer-events": "all",
        "z-index": "100", // どのレイヤーよりも上だが、image poolよりも下
      }}
    />
  );
};

================
File: src/components/section/CanvasSettings.tsx
================
import { Component, createSignal } from "solid-js";
import { initLayerImage } from "~/models/layer/layerImage";
import { canvasStore, setCanvasStore } from "~/stores/project/canvasStore";
import { allLayers, layerStore } from "~/stores/project/layerStore";

import { adjustZoomToFit } from "~/stores/project/canvasStore";
import {
  canvasSizeButton,
  canvasSizeForm,
  canvasSizeInput,
  canvasSizeLabel,
} from "~/styles/section/canvas.css";
import {
  sectionCaption,
  sectionContent,
  sectionRoot,
} from "~/styles/section_global.css";

const CanvasSettings: Component<{}> = (props) => {
  const [width, setWidth] = createSignal(canvasStore.canvas.width);
  const [height, setHeight] = createSignal(canvasStore.canvas.height);

  const changeCanvasSize = (e: any) => {
    e.preventDefault();
    setCanvasStore("canvas", "width", width());
    setCanvasStore("canvas", "height", height());

    allLayers().forEach((layer, i) => {
      initLayerImage(layer.id, layer.dotMagnification);
    });

    adjustZoomToFit(width(), height());
  };

  const resetAllLayers = (e: any) => {
    layerStore.layers.forEach((l) => {
      initLayerImage(l.id, l.dotMagnification);
    });
  };

  return (
    <div class={sectionRoot}>
      <p class={sectionCaption}>canvas.</p>

      <form
        class={sectionContent}
        onSubmit={(e) => {
          changeCanvasSize(e);
        }}
      >
        <div class={canvasSizeForm}>
          <div>
            <p class={canvasSizeLabel}>width</p>
            <input
              class={canvasSizeInput}
              type="number"
              name="width"
              onChange={(e) => setWidth(Number(e.target.value))}
              value={width()}
              min={0}
              max={10000}
              required
            />
          </div>
          <div>
            <p class={canvasSizeLabel}>height</p>
            <input
              class={canvasSizeInput}
              type="number"
              name="height"
              onChange={(e) => setHeight(Number(e.target.value))}
              value={height()}
              min={0}
              max={10000}
              required
            />
          </div>
          <button class={canvasSizeButton} type="submit">
            change
          </button>
        </div>
      </form>

      <button class={canvasSizeButton} onClick={resetAllLayers}>
        RESET ALL LAYERS
      </button>
    </div>
  );
};

export default CanvasSettings;

================
File: src/app.tsx
================
// @refresh reload
import { MetaProvider } from "@solidjs/meta";
import { Route, Router } from "@solidjs/router";
import { onMount, Suspense } from "solid-js";
import TitleBar from "./components/TitleBar";
import ToastContainer from "./components/ToastContainer";
import { loadGlobalSettings } from "./io/global/globalIO";
import Home from "./routes";
import Editor from "./routes/editor";

import { sledgeLogo } from "./styles/global.css";
import { flexCol, h100 } from "./styles/snippets.css";

export default function App() {
  onMount(() => {
    loadGlobalSettings();
  });

  return (
    <Router
      root={(props) => (
        <MetaProvider>
          <title>Sledge</title>
          <Suspense>
            <div
              class={[flexCol, h100].join(" ")}
              style={{ "pointer-events": "all" }}
            >
              <TitleBar />

              <main>{props.children}</main>

              <ToastContainer />

              {/* <p class={sledgeLogo}>sledge.</p> */}
            </div>
          </Suspense>
        </MetaProvider>
      )}
    >
      <Route path="/" component={Home} />
      <Route path="/editor" component={Editor} />
    </Router>
  );
}

================
File: README.md
================
# Sledge

<img src="./public/readme_intro.png" alt="the picture of a well-drawn sledgehammer." width="500px"/>\

> this project is pre-alpha.  
> feel free to DM me: [@alphendp](https://x.com/alphendp)

## build

if you don't have tauri, install first (https://v2.tauri.app/ja/)

```bash
git clone https://gitlab.com/Innsbluck/sledge.git
cd sledge
npm install # install solidjs dependencies
npm tauri dev # launch
```

## what you'll get

### ■&ensp;&nbsp;pixel-perfect drawing experience

- **no alpha channels**. \
  erasing just works. nothing left behind.

- **dot magnification** factor, such as `x1` or `x4`. \
  it enables you to put some _out-of-place_ pixel art on a high-definition background.

  <!-- some introduction picture for layers -->

### \>\_ &nbsp;useful (or _unstable_) effects

- built-in stuff:

  - **standard effects** — `brightness`, `contrast`, `invert`

  - **filter and split functions** — `splitV`, `colorRange`, `rect`

  - **destructive effects** — `JPEG glitches`

- all effects are written in Rust.

  <!-- some introduction picture for the effects -->

### :)&ensp;companion

- pretty companion improves your drawing experiment.

## DSL(Data Shaping Line)

sledge's DSL(Data Shaping Line) is a flexible and powerful effect pipelines.

```shell
# layer_N: unique id for layerN
# in(layer_N): read the image data from layer.
# out(layer_N): output the image data to layer.

in(layer_0) > out(layer_0)  # do nothing.

in(layer_0) > contrast(20%) > invert() > out(layer_0)  # apply contrast+20%, then invert it.

in(layer_1) > splitV(50%) > multiout(*upper, *lower)  # apply grayscale, split vertically in half.
upper > jpeg_glitch(9, 72) > *merged                # apply jpeg_glitch for the upper half of layer1.
lower > invert() > merged                          # invert the lower half of layer1.
merged > out(layer_1)                               # merge split images and throw back to layer1.

# note 1: *upper, *lower, and *merged are called "subout nodes" (basically like named pipes.)
# note 2: subout nodes automatically merge/override multiple inputs.
```

- supports the GUI node editor to add / swap / mutate effects.
- of course, raw command-line input is also available.\
  either way, dsl effects are applied to the image immediately and reactively.

## tech

- [SolidJS](https://www.solidjs.com/) (UI)
- [Tauri](https://tauri.app/) (desktop wrapper)
- [Rust](https://www.rust-lang.org/) (effect processing)
- [speak.js](https://github.com/kripken/speak.js/) (TTS engine)

================
File: src/routes/index.tsx
================
import { useNavigate } from "@solidjs/router";
import { For } from "solid-js";
import EdgeInfo from "~/components/EdgeInfo";
import { importProjectJsonFromFileSelection } from "~/io/project/project";
import { createLayer } from "~/models/factories/createLayer";
import { LayerType } from "~/models/types/Layer";
import {
  FileLocation,
  addRecent,
  globalStore,
  setGlobalStore,
} from "~/stores/global/globalStore";
import { setLayerStore } from "~/stores/project/layerStore";
import { sideArea } from "~/styles/global.css";
import { sectionRoot } from "~/styles/section_global.css";
import { flexCol, flexRow, w100 } from "~/styles/snippets.css";
import { getFileNameAndPath } from "~/utils/pathUtils";
import {
  clear,
  recentFilesCaption,
  recentFilesContainer,
  recentFilesItem,
  recentFilesName,
  recentFilesPath,
  sideSection,
  sideSectionItem,
  welcomeHeadline,
  welcomeRoot,
} from "./start.css";

export default function Home() {
  const navigate = useNavigate();

  const moveToEditor = async (recentFile: FileLocation) => {
    const params = new URLSearchParams();
    params.append("name", recentFile.name);
    params.append("path", recentFile.path);
    navigate(`/editor?${params.toString()}`, { replace: false });
  };

  const createNew = () => {
    const DEFAULT_LAYERS = [createLayer("dot1", LayerType.Dot, true, 1)];
    setLayerStore("layers", DEFAULT_LAYERS);
    setLayerStore("activeLayerId", DEFAULT_LAYERS[0].id);
    navigate(`/editor`, { replace: false });
  };

  const openProject = () => {
    importProjectJsonFromFileSelection().then((file: string | undefined) => {
      if (file !== undefined) {
        const loc = getFileNameAndPath(file);
        if (loc !== undefined) addRecent(loc);
        navigate(`/editor`, { replace: false });
      }
    });
  };

  const clearRecentFiles = () => {
    setGlobalStore("recentOpenedFiles", []);
  };

  return (
    <div id="root">
      <div class={sideArea}>
        <EdgeInfo />
      </div>

      <div class={welcomeRoot}>
        <div class={flexCol}>
          <p class={welcomeHeadline}>hello.</p>
          <div class={sideSection}>
            <a class={sideSectionItem} onClick={() => createNew()}>
              + new.
            </a>
            <a
              class={sideSectionItem}
              style={{ "margin-left": "2px" }}
              onClick={(e) => openProject()}
            >
              &gt; open.
            </a>
          </div>

          <div class={sectionRoot}>
            <div class={[flexRow, w100].join(" ")}>
              <p class={recentFilesCaption}>recent files.</p>
              <p class={clear} onClick={() => clearRecentFiles()}>
                clear
              </p>
            </div>
            <div class={recentFilesContainer}>
              <For each={globalStore.recentOpenedFiles}>
                {(item, i) => {
                  console.log(item);
                  return (
                    <div class={recentFilesItem}>
                      <p>■</p>
                      <a
                        class={recentFilesName}
                        onClick={(e) => moveToEditor(item)}
                      >
                        {item.name}
                      </a>
                      <p class={recentFilesPath}>{item.path}</p>
                    </div>
                  );
                }}
              </For>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/canvas/CanvasArea.tsx
================
import CanvasStack from "./stacks/CanvasStack";

import {
  adjustZoomToFit,
  canvasStore,
  centeringCanvas,
  setCanvasStore,
} from "~/stores/project/canvasStore";

import { createMemo, onCleanup, onMount } from "solid-js";
import Controls from "./Controls";

import { canvasArea } from "~/styles/components/canvas/canvas_area.css";
import CanvasAreaInteract from "./CanvasAreaInteract";

export default () => {
  let wrapper: HTMLDivElement;
  let canvasStack: HTMLDivElement;

  let interact: CanvasAreaInteract = new CanvasAreaInteract();

  onMount(() => {
    // set Canvas to center
    setCanvasStore("canvasAreaSize", {
      width: wrapper.clientWidth,
      height: wrapper.clientHeight,
    });
    adjustZoomToFit();
    centeringCanvas();

    interact.setInteractListeners(wrapper, canvasStack);
  });

  onCleanup(() => {
    if (interact !== undefined) {
      interact.removeInteractListeners(wrapper, canvasStack);
    }
  });

  const offsetX = () => canvasStore.offsetOrigin.x + canvasStore.offset.x;
  const offsetY = () => canvasStore.offsetOrigin.y + canvasStore.offset.y;

  const transform = createMemo(() => {
    return `translate(${offsetX()}px, ${offsetY()}px) scale(${canvasStore.zoom})`;
  });

  return (
    <div class={canvasArea}>
      <div
        id="zoompan-wrapper"
        ref={(el) => {
          wrapper = el;
        }}
        style={{
          display: "flex",
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          padding: 0,
          margin: 0,
          width: "100%",
          height: "100%",
          "touch-action": "none",
        }}
      >
        <div
          ref={(el) => (canvasStack = el)}
          style={{
            padding: 0,
            margin: 0,
            "transform-origin": "0 0",
            transform: transform(),
          }}
        >
          <CanvasStack />
        </div>
      </div>

      <Controls />
    </div>
  );
};

================
File: package.json
================
{
  "name": "sledge",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "tauri:dev": "tauri dev",
    "tauri:build": "tauri build --debug",
    "tcm-watch": "tcm -o dist-tcm src --watch",
    "postinstall": "patch-package",
    "prettier": "prettier --write 'src/**/*.{ts,tsx,css,module.css}' --config .vscode/.prettierrc",
    "stylelint": "stylelint -c .\\.stylelintrc.json \"src/**/*.css\" --fix"
  },
  "dependencies": {
    "@jaames/iro": "^5.5.2",
    "@solid-primitives/deep": "^0.3.1",
    "@solidjs/meta": "^0.29.4",
    "@solidjs/router": "^0.15.0",
    "@tauri-apps/api": "^2.4.1",
    "@tauri-apps/plugin-dialog": "^2.2.1",
    "@tauri-apps/plugin-fs": "^2.2.1",
    "@thisbeyond/solid-dnd": "^0.7.5",
    "@vanilla-extract/css": "^1.17.1",
    "@vanilla-extract/recipes": "^0.5.5",
    "interactjs": "^1.10.27",
    "solid-js": "^1.9.5",
    "solidjs-use": "^2.3.0",
    "uuid": "^11.1.0"
  },
  "engines": {
    "node": ">=22"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2.4.1",
    "@vanilla-extract/vite-plugin": "^5.0.1",
    "patch-package": "^8.0.0",
    "prettier": "^3.5.3",
    "prettier-plugin-organize-imports": "^4.1.0",
    "stylelint": "^16.18.0",
    "stylelint-config-standard": "^38.0.0",
    "stylelint-order": "^6.0.4",
    "vite": "^6.2.4",
    "vite-plugin-solid": "^2.11.6",
    "vite-tsconfig-paths": "^5.1.4"
  }
}



================================================================
End of Codebase
================================================================
