This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
build.rs
capabilities/default.json
Cargo.toml
src/commands/base64_utils.rs
src/commands/brightness.rs
src/commands/glitch.rs
src/commands/grayscale.rs
src/commands/invert.rs
src/commands/jpeg_glitch.rs
src/commands/mod.rs
src/commands/sepia.rs
src/lib.rs
src/main.rs
src/pipeline/mod.rs
src/pipeline/parser.rs
src/pipeline/runner.rs
tauri.conf.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/
/gen/schemas
</file>

<file path="build.rs">
fn main() {
  tauri_build::build()
}
</file>

<file path="capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "enables the default permissions",
  "windows": [
    "main"
  ],
  "permissions": [
    "core:default"
  ]
}
</file>

<file path="Cargo.toml">
[package]
name = "app"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
license = ""
repository = ""
edition = "2021"
rust-version = "1.77.2"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
name = "app_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2.1.1", features = [] }

[dependencies]
serde_json = "1.0"
serde = { version = "1.0", features = ["derive"] }
log = "0.4"
tauri = { version = "2.4.1", features = [] }
tauri-plugin-log = "2.0.0-rc"
base64 = "0.22.1"
rand = "0.9.0"
image = "0.25.6"
</file>

<file path="src/commands/base64_utils.rs">
use base64::engine::general_purpose::STANDARD;
use base64::prelude::*;

pub fn decode_image_base64(encoded: &str) -> Result<Vec<u8>, String> {
    STANDARD.decode(encoded).map_err(|e| e.to_string())
}

pub fn encode_image_base64(data: &[u8]) -> Result<String, String> {
    Ok(STANDARD.encode(data))
}
</file>

<file path="src/commands/brightness.rs">
use crate::commands::base64_utils::{decode_image_base64, encode_image_base64};

#[tauri::command]
pub fn brightness(
    encoded: String,
    width: usize,
    height: usize,
    delta: i8,
) -> Result<String, String> {
    let mut data = decode_image_base64(&encoded)?;

    for i in (0..data.len()).step_by(4) {
        data[i] = data[i].saturating_add_signed(delta);
        data[i + 1] = data[i + 1].saturating_add_signed(delta);
        data[i + 2] = data[i + 2].saturating_add_signed(delta);
    }

    encode_image_base64(&data)
}
</file>

<file path="src/commands/glitch.rs">
use crate::commands::base64_utils::{decode_image_base64, encode_image_base64};
use rand::rngs::StdRng;
use rand::{Rng, SeedableRng};

#[tauri::command]
pub fn glitch(encoded: String, seed: u64) -> Result<String, String> {
    let mut data = decode_image_base64(&encoded)?;

    // 乱数生成器の初期化
    let mut rng = StdRng::seed_from_u64(seed);

    // 64バイトぶん、ランダム位置を破壊（数は調整可）
    for _ in 0..64 {
        let idx = rng.random_range(0..data.len());
        data[idx] = rng.random();
    }

    encode_image_base64(&data)
}
</file>

<file path="src/commands/grayscale.rs">
use crate::commands::base64_utils::{decode_image_base64, encode_image_base64};

#[tauri::command]
pub fn grayscale(encoded: String, width: usize, height: usize) -> Result<String, String> {
    let mut data = decode_image_base64(&encoded)?;

    for i in (0..data.len()).step_by(4) {
        let r = data[i] as u16;
        let g = data[i + 1] as u16;
        let b = data[i + 2] as u16;
        let gray = ((r + g + b) / 3) as u8;
        // または perceptual: let gray = (0.299*r + 0.587*g + 0.114*b) as u8;
        data[i] = gray;
        data[i + 1] = gray;
        data[i + 2] = gray;
    }

    encode_image_base64(&data)
}
</file>

<file path="src/commands/invert.rs">
use crate::commands::base64_utils::{decode_image_base64, encode_image_base64};

#[tauri::command]
pub fn invert(encoded: String, width: usize, height: usize) -> Result<String, String> {
    let mut decoded = decode_image_base64(&encoded)?;

    for i in (0..decoded.len()).step_by(4) {
        decoded[i] = 255 - decoded[i];
        decoded[i + 1] = 255 - decoded[i + 1];
        decoded[i + 2] = 255 - decoded[i + 2];
        // alphaはそのまま
    }

    encode_image_base64(&decoded)
}
</file>

<file path="src/commands/jpeg_glitch.rs">
use crate::commands::base64_utils::decode_image_base64;
use base64::engine::general_purpose::STANDARD;
use base64::Engine;
use image::codecs::jpeg::JpegEncoder;
use image::{ImageBuffer, RgbaImage};
use rand::rngs::StdRng;
use rand::{Rng, SeedableRng};

use std::fs::File;
use std::io::Cursor;
use std::path::Path;

#[tauri::command]
pub fn jpeg_glitch(
    encoded: String,
    width: usize,
    height: usize,
    seed: u64,
) -> Result<String, String> {
    // RGBA raw バッファを取得
    let raw = decode_image_base64(&encoded)?;
    if raw.len() != width * height * 4 {
        return Err("Invalid image size".to_string());
    }

    // RGBA → image crate の ImageBuffer に変換
    let img: RgbaImage = ImageBuffer::from_raw(width as u32, height as u32, raw)
        .ok_or("Image buffer conversion failed")?;

    // JPEGデータを書き込む Vec<u8> バッファを用意
    let mut jpeg_buffer: Vec<u8> = Vec::new();
    let mut encoder = JpegEncoder::new_with_quality(&mut jpeg_buffer, 80);
    encoder.encode_image(&img).map_err(|e| e.to_string())?;

    // バイナリ破壊処理：ヘッダー除いてランダムに改変
    let mut rng = StdRng::seed_from_u64(seed);
    for _ in 0..10 {
        let idx = rng.random_range(100..jpeg_buffer.len());
        jpeg_buffer[idx] = rng.random();
    }

    // base64エンコードして data URI に
    let b64 = STANDARD.encode(&jpeg_buffer);
    let mime = format!("data:image/jpeg;base64,{}", b64);

    Ok(mime)
}
</file>

<file path="src/commands/mod.rs">
pub mod base64_utils;
pub use base64_utils::{decode_image_base64, encode_image_base64};

pub mod brightness;
pub use brightness::brightness;

pub mod grayscale;
pub use grayscale::grayscale;

pub mod invert;
pub use invert::invert;

pub mod jpeg_glitch;
pub use jpeg_glitch::jpeg_glitch;

pub mod glitch;
pub use glitch::glitch;

pub mod sepia;
pub use sepia::sepia;

// デバッグ用など
#[tauri::command]
pub fn hello_from_rust(name: String) -> String {
    format!("Hello, {name}! This is Rust talking.")
}
</file>

<file path="src/commands/sepia.rs">
use crate::commands::base64_utils::{decode_image_base64, encode_image_base64};

#[tauri::command]
pub fn sepia(encoded: String, width: usize, height: usize) -> Result<String, String> {
    let mut data = decode_image_base64(&encoded)?;

    for i in (0..data.len()).step_by(4) {
        let r = data[i] as f32;
        let g = data[i + 1] as f32;
        let b = data[i + 2] as f32;

        let tr = (0.393 * r + 0.769 * g + 0.189 * b).min(255.0) as u8;
        let tg = (0.349 * r + 0.686 * g + 0.168 * b).min(255.0) as u8;
        let tb = (0.272 * r + 0.534 * g + 0.131 * b).min(255.0) as u8;

        data[i] = tr;
        data[i + 1] = tg;
        data[i + 2] = tb;
    }

    encode_image_base64(&data)
}
</file>

<file path="src/lib.rs">
mod commands;
mod pipeline; // 今後用

use commands::{brightness, glitch, grayscale, invert, jpeg_glitch, sepia};
use pipeline::run_pipeline;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            brightness,
            glitch,
            grayscale,
            invert,
            jpeg_glitch,
            sepia,
            run_pipeline,
        ])
        .setup(|app| {
            if cfg!(debug_assertions) {
                app.handle().plugin(
                    tauri_plugin_log::Builder::default()
                        .level(log::LevelFilter::Info)
                        .build(),
                )?;
            }
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path="src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    app_lib::run();
}
</file>

<file path="src/pipeline/mod.rs">
pub mod parser;
pub mod runner;

pub use parser::*;
pub use runner::*;
</file>

<file path="src/pipeline/parser.rs">
#[derive(Debug)]
pub enum PipelineNode {
    // コマンド（名前と引数）
    Command { name: String, args: Vec<String> },
    // 出力指定ノード（*out(layerX) 形式）
    Output { target: String },
}

/// パイプライン文字列をパースし、PipelineNodeのベクタを返す
pub fn parse_pipeline(input: &str) -> Result<Vec<PipelineNode>, String> {
    input
        .split('>')
        .map(|part| {
            let trimmed = part.trim();
            // 出力指定ノード： out(layerX)
            if let Some(captures) = trimmed
                .strip_prefix("out(")
                .and_then(|s| s.strip_suffix(")"))
            {
                Ok(PipelineNode::Output {
                    target: captures.to_string(),
                })
            }
            // コマンド＋引数：command(arg1,arg2)
            else if let Some(idx) = trimmed.find('(') {
                if trimmed.ends_with(')') {
                    let name = &trimmed[..idx];
                    let args_str = &trimmed[idx + 1..trimmed.len() - 1];
                    let args = args_str.split(',').map(|s| s.trim().to_string()).collect();
                    Ok(PipelineNode::Command {
                        name: name.to_string(),
                        args,
                    })
                } else {
                    Err(format!("Malformed command: {trimmed}"))
                }
            }
            // 引数なしの単純なコマンド
            else {
                Ok(PipelineNode::Command {
                    name: trimmed.to_string(),
                    args: vec![],
                })
            }
        })
        .collect()
}
</file>

<file path="src/pipeline/runner.rs">
use super::parser::{parse_pipeline, PipelineNode};
use crate::commands::{brightness, glitch, grayscale, invert, jpeg_glitch, sepia};
use crate::commands::{decode_image_base64, encode_image_base64};

#[tauri::command]
pub fn run_pipeline(
    dsl: String,
    encoded: String,
    width: usize,
    height: usize,
) -> Result<String, String> {
    // DSL文字列をパースしてASTにする
    let nodes = parse_pipeline(&dsl)?;

    // 画像をデコードしてRGBAのバッファを作る
    let mut buffer = decode_image_base64(&encoded)?;

    // パイプラインノードを順に処理
    for node in nodes {
        match node {
            PipelineNode::Command { name, args } => {
                // matchで対応コマンドを呼び分け（必要なら引数あり）
                buffer = match name.as_str() {
                    "grayscale" => {
                        let encoded = encode_image_base64(&buffer)?;
                        decode_image_base64(&grayscale(encoded, width, height)?)?
                    }
                    "glitch" => {
                        if args.len() != 1 {
                            return Err("glitch requires 1 argument (seed)".to_string());
                        }
                        let seed: u64 = args[0]
                            .parse()
                            .map_err(|_| "Invalid seed value".to_string())?;

                        let encoded = encode_image_base64(&buffer)?;
                        decode_image_base64(&glitch(encoded, seed)?)?
                    }
                    "jpeg_glitch" => {
                        if args.len() != 1 {
                            return Err("jpeg_glitch requires 1 argument (seed)".to_string());
                        }
                        let seed: u64 = args[0]
                            .parse()
                            .map_err(|_| "Invalid seed value".to_string())?;

                        let encoded = encode_image_base64(&buffer)?;
                        return jpeg_glitch(encoded, width, height, seed);
                    }
                    "invert" => {
                        let encoded = encode_image_base64(&buffer)?;
                        decode_image_base64(&invert(encoded, width, height)?)?
                    }
                    "sepia" => {
                        let encoded = encode_image_base64(&buffer)?;
                        decode_image_base64(&sepia(encoded, width, height)?)?
                    }
                    "brightness" => {
                        if args.len() != 1 {
                            return Err("brightness requires 1 argument".to_string());
                        }
                        let delta: i8 = args[0]
                            .parse()
                            .map_err(|_| "Invalid number for brightness".to_string())?;
                        let encoded = encode_image_base64(&buffer)?;
                        decode_image_base64(&brightness(encoded, width, height, delta)?)?
                    }
                    _ => return Err(format!("Unknown command: {name}")),
                };
            }

            PipelineNode::Output { target: _ } => {
                // 今のところ *out(layerX) は文字列だけ保持 → JSに返すだけ
                // ここで base64 して return
                return encode_image_base64(&buffer);
            }
        }
    }

    Err("No *out(...) specified in pipeline.".to_string())
}
</file>

<file path="tauri.conf.json">
{
  "$schema": "../node_modules/@tauri-apps/cli/config.schema.json",
  "productName": "sledge",
  "version": "0.1.0",
  "identifier": "com.tauri.dev",
  "build": {
    "frontendDist": "../dist",
    "devUrl": "http://localhost:5173",
    "beforeDevCommand": "npm run dev",
    "beforeBuildCommand": "npm run build"
  },
  "app": {
    "windows": [
      {
        "title": "sledge",
        "width": 1400,
        "height": 900,
        "resizable": true,
        "fullscreen": false
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": ["icons_light/icon.ico"]
  }
}
</file>

</files>
